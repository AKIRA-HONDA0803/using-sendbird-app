{"ast":null,"code":"/**\n * Copyright (c) 2016 Sendbird DBA (Smile Family, Inc.)\n * Sendbird JavaScript SDK v3.1.27\n */\n!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t(require(\"axios\"), require(\"form-data\"), require(\"ws\")) : \"function\" == typeof define && define.amd ? define([\"axios\", \"form-data\", \"ws\"], t) : (e = \"undefined\" != typeof globalThis ? globalThis : e || self).SendBird = t(e.axios, e.FormData, e.WebSocket);\n}(this, function (e, t, n) {\n  \"use strict\";\n\n  function r(e) {\n    return e && \"object\" == typeof e && \"default\" in e ? e : {\n      default: e\n    };\n  }\n\n  var i = r(e),\n      s = r(t),\n      a = r(n);\n\n  function o(e, t) {\n    var n = Object.keys(e);\n\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), n.push.apply(n, r);\n    }\n\n    return n;\n  }\n\n  function l(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? o(Object(n), !0).forEach(function (t) {\n        p(e, t, n[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o(Object(n)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n      });\n    }\n\n    return e;\n  }\n\n  function u(e) {\n    return u = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n      return typeof e;\n    } : function (e) {\n      return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n    }, u(e);\n  }\n\n  function c(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function d(e, t) {\n    for (var n = 0; n < t.length; n++) {\n      var r = t[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n    }\n  }\n\n  function h(e, t, n) {\n    return t && d(e.prototype, t), n && d(e, n), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), e;\n  }\n\n  function p(e, t, n) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = n, e;\n  }\n\n  function f(e, t) {\n    if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n    e.prototype = Object.create(t && t.prototype, {\n      constructor: {\n        value: e,\n        writable: !0,\n        configurable: !0\n      }\n    }), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), t && g(e, t);\n  }\n\n  function _(e) {\n    return _ = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n      return e.__proto__ || Object.getPrototypeOf(e);\n    }, _(e);\n  }\n\n  function g(e, t) {\n    return g = Object.setPrototypeOf || function (e, t) {\n      return e.__proto__ = t, e;\n    }, g(e, t);\n  }\n\n  function y(e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n  }\n\n  function m(e, t) {\n    if (t && (\"object\" == typeof t || \"function\" == typeof t)) return t;\n    if (void 0 !== t) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return y(e);\n  }\n\n  function E(e) {\n    var t = function () {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n      } catch (e) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var n,\n          r = _(e);\n\n      if (t) {\n        var i = _(this).constructor;\n\n        n = Reflect.construct(r, arguments, i);\n      } else n = r.apply(this, arguments);\n\n      return m(this, n);\n    };\n  }\n\n  function v(e, t) {\n    for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _(e));) {\n      ;\n    }\n\n    return e;\n  }\n\n  function b() {\n    return b = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, n) {\n      var r = v(e, t);\n\n      if (r) {\n        var i = Object.getOwnPropertyDescriptor(r, t);\n        return i.get ? i.get.call(arguments.length < 3 ? e : n) : i.value;\n      }\n    }, b.apply(this, arguments);\n  }\n\n  function C(e, t) {\n    return function (e) {\n      if (Array.isArray(e)) return e;\n    }(e) || function (e, t) {\n      var n = null == e ? null : \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n      if (null == n) return;\n      var r,\n          i,\n          s = [],\n          a = !0,\n          o = !1;\n\n      try {\n        for (n = n.call(e); !(a = (r = n.next()).done) && (s.push(r.value), !t || s.length !== t); a = !0) {\n          ;\n        }\n      } catch (e) {\n        o = !0, i = e;\n      } finally {\n        try {\n          a || null == n.return || n.return();\n        } finally {\n          if (o) throw i;\n        }\n      }\n\n      return s;\n    }(e, t) || N(e, t) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function A(e) {\n    return function (e) {\n      if (Array.isArray(e)) return S(e);\n    }(e) || function (e) {\n      if (\"undefined\" != typeof Symbol && null != e[Symbol.iterator] || null != e[\"@@iterator\"]) return Array.from(e);\n    }(e) || N(e) || function () {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function N(e, t) {\n    if (e) {\n      if (\"string\" == typeof e) return S(e, t);\n      var n = Object.prototype.toString.call(e).slice(8, -1);\n      return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(e) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? S(e, t) : void 0;\n    }\n  }\n\n  function S(e, t) {\n    (null == t || t > e.length) && (t = e.length);\n\n    for (var n = 0, r = new Array(t); n < t; n++) {\n      r[n] = e[n];\n    }\n\n    return r;\n  }\n\n  function I(e, t) {\n    var _n2 = \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n\n    if (!_n2) {\n      if (Array.isArray(e) || (_n2 = N(e)) || t && e && \"number\" == typeof e.length) {\n        _n2 && (e = _n2);\n\n        var r = 0,\n            i = function i() {};\n\n        return {\n          s: i,\n          n: function n() {\n            return r >= e.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: e[r++]\n            };\n          },\n          e: function e(_e2) {\n            throw _e2;\n          },\n          f: i\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var s,\n        a = !0,\n        o = !1;\n    return {\n      s: function s() {\n        _n2 = _n2.call(e);\n      },\n      n: function n() {\n        var e = _n2.next();\n\n        return a = e.done, e;\n      },\n      e: function e(_e3) {\n        o = !0, s = _e3;\n      },\n      f: function f() {\n        try {\n          a || null == _n2.return || _n2.return();\n        } finally {\n          if (o) throw s;\n        }\n      }\n    };\n  }\n\n  var T = function () {\n    function e() {}\n\n    return Object.defineProperty(e, \"OS_VERSION\", {\n      get: function get() {\n        return \"undefined\" != typeof navigator && navigator.userAgent ? navigator.userAgent.replace(/,/g, \".\") : \"noAgent\";\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e, \"SDK_VERSION\", {\n      get: function get() {\n        return \"3.1.27\";\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e, \"SDK_MAJOR_VERSION\", {\n      get: function get() {\n        return e.SDK_VERSION.split(\".\")[0];\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e, \"DEFAULT_MAX_UNREAD_COUNT_OF_SUPER_GROUP_CHANNEL\", {\n      get: function get() {\n        return 100;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e, \"INTERNAL_CALL\", {\n      get: function get() {\n        return \"ic\";\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e;\n  }(),\n      O = {},\n      U = function () {\n    function e(e) {\n      this._container = e;\n    }\n\n    return e.create = function (t, n) {\n      return O[t] = new e(n), O[t];\n    }, e.get = function (e) {\n      return e || (e = ji.getInstance()._iid), O[e];\n    }, Object.defineProperty(e.prototype, \"container\", {\n      get: function get() {\n        return this._container;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.get = function (e) {\n      return this._container[e];\n    }, e.prototype.set = function (e, t) {\n      this._container[e] = t;\n    }, e.prototype.remove = function (e) {\n      this._container.hasOwnProperty(e) && delete this._container[e];\n    }, e;\n  }(),\n      _M = function M(e, t) {\n    return _M = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (e, t) {\n      e.__proto__ = t;\n    } || function (e, t) {\n      for (var n in t) {\n        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n      }\n    }, _M(e, t);\n  };\n\n  function k(e, t) {\n    if (\"function\" != typeof t && null !== t) throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n\n    function n() {\n      this.constructor = e;\n    }\n\n    _M(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }\n\n  var _R = function R() {\n    return _R = Object.assign || function (e) {\n      for (var t, n = 1, r = arguments.length; n < r; n++) {\n        for (var i in t = arguments[n]) {\n          Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);\n        }\n      }\n\n      return e;\n    }, _R.apply(this, arguments);\n  };\n\n  function L(e, t, n, r) {\n    return new (n || (n = Promise))(function (i, s) {\n      function a(e) {\n        try {\n          l(r.next(e));\n        } catch (e) {\n          s(e);\n        }\n      }\n\n      function o(e) {\n        try {\n          l(r.throw(e));\n        } catch (e) {\n          s(e);\n        }\n      }\n\n      function l(e) {\n        var t;\n        e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n          e(t);\n        })).then(a, o);\n      }\n\n      l((r = r.apply(e, t || [])).next());\n    });\n  }\n\n  function P(e, t) {\n    var n,\n        r,\n        i,\n        s,\n        a = {\n      label: 0,\n      sent: function sent() {\n        if (1 & i[0]) throw i[1];\n        return i[1];\n      },\n      trys: [],\n      ops: []\n    };\n    return s = {\n      next: o(0),\n      throw: o(1),\n      return: o(2)\n    }, \"function\" == typeof Symbol && (s[Symbol.iterator] = function () {\n      return this;\n    }), s;\n\n    function o(s) {\n      return function (o) {\n        return function (s) {\n          if (n) throw new TypeError(\"Generator is already executing.\");\n\n          for (; a;) {\n            try {\n              if (n = 1, r && (i = 2 & s[0] ? r.return : s[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, s[1])).done) return i;\n\n              switch (r = 0, i && (s = [2 & s[0], i.value]), s[0]) {\n                case 0:\n                case 1:\n                  i = s;\n                  break;\n\n                case 4:\n                  return a.label++, {\n                    value: s[1],\n                    done: !1\n                  };\n\n                case 5:\n                  a.label++, r = s[1], s = [0];\n                  continue;\n\n                case 7:\n                  s = a.ops.pop(), a.trys.pop();\n                  continue;\n\n                default:\n                  if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                    a = 0;\n                    continue;\n                  }\n\n                  if (3 === s[0] && (!i || s[1] > i[0] && s[1] < i[3])) {\n                    a.label = s[1];\n                    break;\n                  }\n\n                  if (6 === s[0] && a.label < i[1]) {\n                    a.label = i[1], i = s;\n                    break;\n                  }\n\n                  if (i && a.label < i[2]) {\n                    a.label = i[2], a.ops.push(s);\n                    break;\n                  }\n\n                  i[2] && a.ops.pop(), a.trys.pop();\n                  continue;\n              }\n\n              s = t.call(e, a);\n            } catch (e) {\n              s = [6, e], r = 0;\n            } finally {\n              n = i = 0;\n            }\n          }\n\n          if (5 & s[0]) throw s[1];\n          return {\n            value: s[0] ? s[1] : void 0,\n            done: !0\n          };\n        }([s, o]);\n      };\n    }\n  }\n\n  function w(e, t, n) {\n    if (n || 2 === arguments.length) for (var r, i = 0, s = t.length; i < s; i++) {\n      !r && i in t || (r || (r = Array.prototype.slice.call(t, 0, i)), r[i] = t[i]);\n    }\n    return e.concat(r || Array.prototype.slice.call(t));\n  }\n\n  var D,\n      H = function (e) {\n    function t(n, r) {\n      var i = e.call(this, r) || this;\n      return i.name = \"SendBirdException\", i.code = r || 0, i.message = n, Object.setPrototypeOf(i, t.prototype), i;\n    }\n\n    return k(t, e), Object.defineProperty(t.prototype, \"isInvalidTokenError\", {\n      get: function get() {\n        return this.code === t.INVALID_TOKEN;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"isSessionKeyExpiredError\", {\n      get: function get() {\n        return this.code === t.SESSION_KEY_EXPIRED;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"isSessionTokenExpiredError\", {\n      get: function get() {\n        return this.code === t.SESSION_TOKEN_EXPIRED;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"isSessionTokenRevokedError\", {\n      get: function get() {\n        return this.code === t.SESSION_TOKEN_REVOKED;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"INVALID_TOKEN\", {\n      get: function get() {\n        return 400111;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"SESSION_KEY_EXPIRED\", {\n      get: function get() {\n        return 400309;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"USER_DEACTIVATED\", {\n      get: function get() {\n        return 400300;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"NON_EXISTING_USER\", {\n      get: function get() {\n        return 400301;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"SESSION_TOKEN_EXPIRED\", {\n      get: function get() {\n        return 400302;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"SESSION_TOKEN_REVOKED\", {\n      get: function get() {\n        return 400310;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"INVALID_INITIALIZATION\", {\n      get: function get() {\n        return 800100;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"CONNECTION_REQUIRED\", {\n      get: function get() {\n        return 800101;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"CONNECTION_CANCELED\", {\n      get: function get() {\n        return 800102;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"INVALID_PARAMETER\", {\n      get: function get() {\n        return 800110;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"NETWORK_ERROR\", {\n      get: function get() {\n        return 800120;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"NETWORK_ROUTING_ERROR\", {\n      get: function get() {\n        return 800121;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"MALFORMED_DATA\", {\n      get: function get() {\n        return 800130;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"MALFORMED_ERROR_DATA\", {\n      get: function get() {\n        return 800140;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"WRONG_CHANNEL_TYPE\", {\n      get: function get() {\n        return 800150;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"MARK_AS_READ_RATE_LIMIT_EXCEEDED\", {\n      get: function get() {\n        return 800160;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"QUERY_IN_PROGRESS\", {\n      get: function get() {\n        return 800170;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"ACK_TIMEOUT\", {\n      get: function get() {\n        return 800180;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"LOGIN_TIMEOUT\", {\n      get: function get() {\n        return 800190;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"WEBSOCKET_CONNECTION_CLOSED\", {\n      get: function get() {\n        return 800200;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"WEBSOCKET_CONNECTION_FAILED\", {\n      get: function get() {\n        return 800210;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"REQUEST_FAILED\", {\n      get: function get() {\n        return 800220;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"FILE_UPLOAD_CANCEL_FAILED\", {\n      get: function get() {\n        return 800230;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"REQUEST_CANCELED\", {\n      get: function get() {\n        return 800240;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"REQUEST_DUPLICATED\", {\n      get: function get() {\n        return 800250;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"FILE_SIZE_LIMIT_EXCEEDED\", {\n      get: function get() {\n        return 800260;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"SESSION_TOKEN_REQUEST_FAILED\", {\n      get: function get() {\n        return 800500;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"SESSION_REFRESH_SUCCESS\", {\n      get: function get() {\n        return 800501;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"SESSION_REFRESH_FAILED\", {\n      get: function get() {\n        return 800502;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"CHANNEL_NOT_FOUND\", {\n      get: function get() {\n        return 900500;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"USER_NOT_MEMBER\", {\n      get: function get() {\n        return 900020;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(Error),\n      F = function () {\n    function e() {\n      this.sessionToken = null, this.sessionKey = null, this.eKey = null;\n    }\n\n    return e.prototype.hasSession = function () {\n      return !!this.sessionKey;\n    }, e;\n  }(),\n      G = {},\n      x = function () {\n    function e(e, t) {\n      void 0 === t && (t = {});\n      var n = this;\n      this._iid = e, Object.keys(t).forEach(function (e) {\n        var r = t[e];\n        \"function\" == typeof r && (n[e] = n.getClonedClass(r));\n      }), G[e] = this;\n    }\n\n    return e.get = function (e) {\n      return e ? G[e] : {};\n    }, e.prototype.getClonedClass = function (e) {\n      var t = this._iid,\n          n = function (n) {\n        function r() {\n          for (var e = [], t = 0; t < arguments.length; t++) {\n            e[t] = arguments[t];\n          }\n\n          return n.apply(this, e) || this;\n        }\n\n        return k(r, n), Object.defineProperty(r, \"_iid\", {\n          get: function get() {\n            return t;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), Object.defineProperty(r, \"_name\", {\n          get: function get() {\n            return e.name;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), Object.defineProperty(r.prototype, \"_iid\", {\n          get: function get() {\n            return t;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), r;\n      }(e);\n\n      return n;\n    }, e;\n  }(),\n      j = {\n    verbose: \"VERBOSE\",\n    info: \"INFO\",\n    debug: \"DEBUG\",\n    warn: \"WARN\",\n    error: \"ERROR\",\n    none: \"NONE\"\n  },\n      B = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n() {\n      return c(this, n), t.apply(this, arguments);\n    }\n\n    return h(n, [{\n      key: \"log\",\n      value: function value(e) {\n        for (var t, n, r, i, s, a = this.getLogLevelText(e); a.length < 8;) {\n          a += \" \";\n        }\n\n        for (var o = arguments.length, l = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++) {\n          l[u - 1] = arguments[u];\n        }\n\n        switch (l.unshift(\"[\".concat(a, \"]\")), e) {\n          case \"verbose\":\n            (t = console).log.apply(t, l);\n            break;\n\n          case \"debug\":\n            (n = console).log.apply(n, l);\n            break;\n\n          case \"info\":\n            (r = console).info.apply(r, l);\n            break;\n\n          case \"warn\":\n            (i = console).warn.apply(i, l);\n            break;\n\n          case \"error\":\n            (s = console).error.apply(s, l);\n        }\n      }\n    }, {\n      key: \"groupStart\",\n      value: function value() {\n        var e;\n        (e = console).group.apply(e, arguments);\n      }\n    }, {\n      key: \"groupEnd\",\n      value: function value() {\n        var e;\n        (e = console).groupEnd.apply(e, arguments);\n      }\n    }]), n;\n  }(function () {\n    function e() {\n      c(this, e);\n    }\n\n    return h(e, [{\n      key: \"getLogLevelText\",\n      value: function value(e) {\n        return j[e];\n      }\n    }]), e;\n  }()),\n      V = {\n    DEBUG: \"debug\",\n    PRODUCTION: \"production\"\n  },\n      q = V.PRODUCTION,\n      K = {\n    VERBOSE: \"verbose\",\n    DEBUG: \"debug\",\n    INFO: \"info\",\n    WARN: \"warn\",\n    ERROR: \"error\",\n    NONE: \"none\"\n  },\n      z = [K.NONE, K.ERROR, K.WARN, K.INFO, K.DEBUG, K.VERBOSE],\n      Y = K.WARN,\n      Q = z.indexOf(Y),\n      W = [new B()],\n      J = function () {\n    function e() {\n      c(this, e);\n    }\n\n    return h(e, null, [{\n      key: \"Mode\",\n      get: function get() {\n        return V;\n      }\n    }, {\n      key: \"mode\",\n      get: function get() {\n        return q;\n      },\n      set: function set(t) {\n        Object.keys(e.Mode).map(function (t) {\n          return e.Mode[t];\n        }).indexOf(t) > -1 && (q = t);\n      }\n    }, {\n      key: \"supportedLogLevels\",\n      get: function get() {\n        return K;\n      }\n    }, {\n      key: \"logLevel\",\n      get: function get() {\n        return z[Q];\n      },\n      set: function set(e) {\n        z.includes(e) || (e = Y), Q = z.indexOf(e);\n      }\n    }, {\n      key: \"defaultLogLevel\",\n      get: function get() {\n        return Y;\n      }\n    }, {\n      key: \"isDisplayableLogLevel\",\n      value: function value(e) {\n        var t = z.indexOf(e);\n        return 0 <= t && t <= Q;\n      }\n    }, {\n      key: \"log\",\n      value: function value(t) {\n        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) {\n          r[i - 1] = arguments[i];\n        }\n\n        e.isDisplayableLogLevel(t) && W.forEach(function (e) {\n          return e.log.apply(e, [t].concat(r));\n        });\n      }\n    }, {\n      key: \"verbose\",\n      value: function value() {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) {\n          n[r] = arguments[r];\n        }\n\n        e.log.apply(e, [K.VERBOSE].concat(n));\n      }\n    }, {\n      key: \"debug\",\n      value: function value() {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) {\n          n[r] = arguments[r];\n        }\n\n        e.log.apply(e, [K.DEBUG].concat(n));\n      }\n    }, {\n      key: \"info\",\n      value: function value() {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) {\n          n[r] = arguments[r];\n        }\n\n        e.log.apply(e, [K.INFO].concat(n));\n      }\n    }, {\n      key: \"warn\",\n      value: function value() {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) {\n          n[r] = arguments[r];\n        }\n\n        e.log.apply(e, [K.WARN].concat(n));\n      }\n    }, {\n      key: \"error\",\n      value: function value() {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) {\n          n[r] = arguments[r];\n        }\n\n        e.log.apply(e, [K.ERROR].concat(n));\n      }\n    }, {\n      key: \"group\",\n      value: function value() {\n        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) {\n          n[r] = arguments[r];\n        }\n\n        var i = [];\n        Array.isArray(n[n.length - 1]) && (i = n.pop()), i.some(function (t) {\n          return e.isDisplayableLogLevel(t.level);\n        }) && W.filter(function (e) {\n          return e instanceof B;\n        }).forEach(function (e) {\n          e.groupStart.apply(e, n), i.forEach(function (t) {\n            return e.log.apply(e, [t.level].concat(A(t.messages)));\n          }), e.groupEnd();\n        });\n      }\n    }]), e;\n  }(),\n      X = function () {\n    function e() {\n      c(this, e), this._queue = [], this.locked = !1;\n    }\n\n    return h(e, [{\n      key: \"lock\",\n      value: function value(e) {\n        var t = this;\n        this.locked ? this._queue.push(e) : (this.locked = !0, e(function () {\n          return t.unlock();\n        }));\n      }\n    }, {\n      key: \"unlock\",\n      value: function value() {\n        if (this.locked = !1, this._queue.length > 0) {\n          var e = this._queue.shift();\n\n          this.lock(e);\n        }\n      }\n    }]), e;\n  }(),\n      Z = function () {\n    function e(t) {\n      c(this, e), this.sb = t, this.mutex = new X(), this.pingTimer = null, this.pingTimeoutTimer = null;\n    }\n\n    return h(e, [{\n      key: \"ping\",\n      value: function value() {\n        var e = this,\n            t = x.get(this.sb._iid).Command.bPing(),\n            n = U.get(this.sb._iid).container,\n            r = n.wsAdapter,\n            i = n.pongTimeout;\n        r.client.send(t), J.debug(\"`PING`\"), this.pingTimeoutTimer = setTimeout(function () {\n          J.debug(\"`PING` timeout.\"), e.stop(), r.client.handler && r.client.handler.onError();\n        }, i);\n      }\n    }, {\n      key: \"pong\",\n      value: function value() {\n        this.pingTimeoutTimer && (clearTimeout(this.pingTimeoutTimer), this.pingTimeoutTimer = null);\n      }\n    }, {\n      key: \"refreshTimer\",\n      value: function value() {\n        var e = this,\n            t = U.get(this.sb._iid).container.pingInterval;\n        this.mutex.lock(function (n) {\n          e.stop(), e.pingTimer = setInterval(function () {\n            e.ping();\n          }, t), n();\n        });\n      }\n    }, {\n      key: \"start\",\n      value: function value() {\n        this.refreshTimer(), this.ping();\n      }\n    }, {\n      key: \"stop\",\n      value: function value() {\n        this.pingTimer && (clearInterval(this.pingTimer), this.pingTimer = null), this.pingTimeoutTimer && (clearTimeout(this.pingTimeoutTimer), this.pingTimeoutTimer = null);\n      }\n    }]), e;\n  }(),\n      $ = function $() {\n    return \"undefined\" == typeof document && \"undefined\" != typeof navigator && \"ReactNative\" == navigator.product;\n  },\n      ee = function ee() {\n    return \"undefined\" == typeof window && \"undefined\" != typeof process && (\"node\" === process.title || void 0 !== process.versions && process.versions.node || \"[object process]\" === String(process));\n  };\n\n  !function (e) {\n    e.FILE = \"file\", e.BLOB = \"blob\", e.BLOB_LIKE_OBJECT = \"blobLikeObject\", e.URL = \"url\";\n  }(D || (D = {}));\n\n  var te = function () {\n    function e() {}\n\n    var t;\n    return e.isFileLikeObject = function (e) {\n      return \"object\" == typeof e && null !== e && e.hasOwnProperty(\"name\") && \"string\" == typeof e.name && e.hasOwnProperty(\"uri\") && \"string\" == typeof e.uri && e.hasOwnProperty(\"type\") && \"string\" == typeof e.type;\n    }, t = e, e.convertFileToDataUrl = function (e) {\n      return new Promise(function (t, n) {\n        var r = new FileReader();\n        r.onload = function (e) {\n          return t(r.result);\n        }, r.onerror = function (e) {\n          return n(r.error);\n        }, r.readAsDataURL(e);\n      });\n    }, e.convertFileToArrayBuffer = function (e) {\n      return new Promise(function (t, n) {\n        var r = new FileReader();\n        r.onload = function (e) {\n          return t(r.result);\n        }, r.onerror = function (e) {\n          return n(r.error);\n        }, r.readAsArrayBuffer(e);\n      });\n    }, e.convertDataUrlToByteArray = function (e) {\n      for (var t = e.split(\",\"), n = t[0].match(/:(.*?);/)[1], r = atob(t[1]), i = r.length, s = new Uint8Array(i); i--;) {\n        s[i] = r.charCodeAt(i);\n      }\n\n      return [s, n];\n    }, e.convertDataURLtoFile = function (e, n) {\n      var r = t.convertDataUrlToByteArray(e),\n          i = r[0],\n          s = r[1];\n      return new File([i], n, {\n        type: s\n      });\n    }, e.convertDataURLtoBlob = function (e) {\n      var n = t.convertDataUrlToByteArray(e),\n          r = n[0],\n          i = n[1];\n      return new Blob([r], {\n        type: i\n      });\n    }, e.convertArrayBufferToFile = function (e, t) {\n      return new File([e], t);\n    }, e.isFile = function (e) {\n      return \"undefined\" != typeof window && \"File\" in window && \"undefined\" != typeof File && e instanceof File;\n    }, e.isBlob = function (e) {\n      return \"undefined\" != typeof window && \"Blob\" in window && \"undefined\" != typeof Blob && e instanceof Blob;\n    }, e.isFileTypeBlob = function (e) {\n      return e === D.BLOB || e === D.FILE;\n    }, e.convertBlobToBuffer = function (n) {\n      return L(void 0, void 0, void 0, function () {\n        var r;\n        return P(t, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, e.convertFileToArrayBuffer(n)];\n\n            case 1:\n              return r = t.sent(), [2, Buffer.from(r)];\n          }\n        });\n      });\n    }, e;\n  }(),\n      ne = [H.CONNECTION_REQUIRED, H.NETWORK_ERROR, H.ACK_TIMEOUT, H.WEBSOCKET_CONNECTION_CLOSED, H.WEBSOCKET_CONNECTION_FAILED, H.FILE_UPLOAD_CANCEL_FAILED, H.REQUEST_CANCELED, 500901, 500910, 900200],\n      re = [H.SESSION_TOKEN_EXPIRED, H.SESSION_TOKEN_REVOKED, H.USER_DEACTIVATED, H.NON_EXISTING_USER],\n      ie = [H.WEBSOCKET_CONNECTION_CLOSED, H.WEBSOCKET_CONNECTION_FAILED],\n      se = function () {\n    function e() {}\n\n    return e.deepEqual = function (e, t) {\n      if (e !== t) {\n        var n = _R({}, e),\n            r = _R({}, t);\n\n        return (!n.hasOwnProperty(\"messageId\") || !r.hasOwnProperty(\"messageId\") || n.messageId === r.messageId) && (!n.hasOwnProperty(\"reqId\") || !r.hasOwnProperty(\"reqId\") || n.reqId === r.reqId) && (n.hasOwnProperty(\"messageId\") && delete n.messageId, n.hasOwnProperty(\"reqId\") && delete n.reqId, r.hasOwnProperty(\"messageId\") && delete r.messageId, r.hasOwnProperty(\"reqId\") && delete r.reqId, JSON.stringify(n) === JSON.stringify(r));\n      }\n\n      return !0;\n    }, e.isResendableError = function (e) {\n      return e > 0 && ne.indexOf(e) >= 0;\n    }, e.isAutoResendableError = function (e) {\n      return e > 0 && ie.indexOf(e) >= 0;\n    }, e.isNonAutoReconnectableError = function (e) {\n      return e > 0 && re.indexOf(e) >= 0;\n    }, e.isFile = function (e) {\n      var t = te.isFileLikeObject(e);\n      return t || (ee() ? \"undefined\" != typeof Buffer && e instanceof Buffer : \"undefined\" != typeof Blob ? e instanceof Blob : \"undefined\" != typeof File && e instanceof File);\n    }, e;\n  }(),\n      ae = function () {\n    function e(e) {\n      var t = this;\n      this.fields = {}, e && Object.keys(e).forEach(function (n) {\n        t.fields[n] = {\n          value: e[n]\n        }, se.isFile(e[n]) && (t.fields[n].filename = e[n].name);\n      }), this.options = {}, this.internal = !1, this.upload = {\n        reqId: null,\n        deleteRequest: null,\n        progressHandler: null\n      };\n    }\n\n    return e.prototype.add = function (e, t, n) {\n      void 0 === n && (n = null), this.fields[e] = {\n        value: t,\n        filename: n\n      };\n    }, e.prototype.remove = function (e) {\n      this.fields.hasOwnProperty(e) && delete this.fields[e];\n    }, e.prototype.yield = function () {\n      return L(this, void 0, void 0, function () {\n        var e,\n            t,\n            n,\n            r,\n            i,\n            a,\n            o,\n            l,\n            u,\n            c,\n            d,\n            h,\n            p = this;\n        return P(this, function (f) {\n          switch (f.label) {\n            case 0:\n              for (e = !1, t = Object.keys(this.fields), n = 0, r = t; n < r.length; n++) {\n                if (l = r[n], se.isFile(this.fields[l].value)) {\n                  e = !0;\n                  break;\n                }\n              }\n\n              if (!e) return [3, 10];\n              i = new s.default(), a = 0, o = t, f.label = 1;\n\n            case 1:\n              return a < o.length ? (l = o[a], u = this.fields[l], se.isFile(u.value) ? (c = u.value).filename || c.name ? (i.append(l, u.value, c.filename || c.name), [3, 6]) : [3, 2] : [3, 7]) : [3, 9];\n\n            case 2:\n              return c.data ? (i.append(l, u.value, c.data.name), [3, 6]) : [3, 3];\n\n            case 3:\n              return d = u.value, \"undefined\" != typeof window && \"undefined\" != typeof process && process.title.endsWith(\"node\") && process.versions && process.versions.node && \"undefined\" != typeof Blob && d instanceof Blob || \"undefined\" != typeof File && d instanceof File ? [4, te.convertBlobToBuffer(d)] : [3, 5];\n\n            case 4:\n              d = f.sent(), f.label = 5;\n\n            case 5:\n              i.append(l, d, \"unnamed\"), f.label = 6;\n\n            case 6:\n              return [3, 8];\n\n            case 7:\n              $() && Array.isArray(u.value) ? i.append(l, String(u.value)) : i.append(l, u.value), f.label = 8;\n\n            case 8:\n              return a++, [3, 1];\n\n            case 9:\n              return [2, i];\n\n            case 10:\n              return h = {}, Object.keys(this.fields).forEach(function (e) {\n                h[e] = p.fields[e].value;\n              }), [2, h];\n          }\n        });\n      });\n    }, e;\n  }(),\n      oe = function oe(e, t, n) {\n    return void 0 === n && (n = null), new Promise(function (r, i) {\n      var s = function s(t, _s) {\n        (void 0 === _s && (_s = null), n) && (U.get(e).get(\"isErrorFirstInCallback\") ? n(t, _s) : n(_s, t));\n        t ? i(t) : r(_s);\n      };\n\n      s.isPromisifyCallback = !0, t(s);\n    });\n  },\n      le = 888e3,\n      ue = function () {\n    function e(t) {\n      c(this, e), this.sb = t, this.cls = x.get(this.sb._iid);\n    }\n\n    return h(e, [{\n      key: \"checkRouting\",\n      value: function value(e) {\n        if (this.sb.customApiHost && this.sb.customWsHost) \"function\" == typeof e && e(null, {\n          apiHost: this.sb.customApiHost,\n          wsHost: this.sb.customWsHost\n        });else {\n          var t = this.sb.getApplicationId();\n          e(null, {\n            apiHost: \"https://api-\".concat(t, \".sendbird.com\"),\n            wsHost: \"wss://ws-\".concat(t, \".sendbird.com\")\n          });\n        }\n      }\n    }, {\n      key: \"_buildUrl\",\n      value: function value(e) {\n        var t = e.apiHost,\n            n = e.url,\n            r = e.params;\n        return n ? r && r.internal ? \"\".concat(t, \"/v\").concat(T.SDK_MAJOR_VERSION, \"/sdk\").concat(n) : \"\".concat(t, \"/v\").concat(T.SDK_MAJOR_VERSION).concat(n) : t;\n      }\n    }, {\n      key: \"_createHeader\",\n      value: function value() {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n            n = t.noSessionKey,\n            r = void 0 !== n && n,\n            i = t.accessToken,\n            a = void 0 === i ? null : i,\n            o = e instanceof s.default && \"function\" == typeof e.getHeaders ? e.getHeaders() : {},\n            l = U.get(this.sb._iid),\n            u = l.container,\n            c = u.appId,\n            d = u.auth,\n            h = u.extensions,\n            p = u.getUserAgentWithExtensions,\n            f = ji.getAppVersion(),\n            _ = \"JS,\".concat(T.OS_VERSION, \",\").concat(T.SDK_VERSION, \",\").concat(c);\n\n        return f && (_ += \",\".concat(f)), o.SendBird = _, o[\"SB-User-Agent\"] = encodeURIComponent(p(h)), !r && d.sessionKey && (o[\"Session-Key\"] = d.sessionKey), a && (o[\"App-Id\"] = c, o[\"Access-Token\"] = a), o[\"Request-Sent-Timestamp\"] = new Date().getTime().toString(), e instanceof s.default && $() && (o[\"Content-Type\"] = \"multipart/form-data\"), o;\n      }\n    }, {\n      key: \"_createQuery\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n\n        try {\n          var n = [];\n          return Object.keys(t).forEach(function (e) {\n            var r = t[e];\n\n            if (null != r) {\n              var i = \"\";\n              i = \"object\" === u(r) ? Array.isArray(r) ? r.map(function (e) {\n                return encodeURIComponent(\"string\" == typeof e ? e.trim() : e);\n              }).join(\",\") : encodeURIComponent(JSON.stringify(r)) : encodeURIComponent(r), n.push(\"\".concat(e, \"=\").concat(i));\n            }\n          }), n.length > 0 ? \"\".concat(e, \"?\").concat(n.join(\"&\")) : e;\n        } catch (t) {\n          return J.debug(\"createWithEncodedGetParams is failed. - \", t), e;\n        }\n      }\n    }, {\n      key: \"_request\",\n      value: function value(e, t, n, r) {\n        var a = this;\n        this.checkRouting(function (o, l) {\n          if (o) r(new H(\"Request failed.\", H.REQUEST_FAILED), null);else {\n            var u = a._buildUrl({\n              apiHost: l.apiHost,\n              url: t,\n              params: n\n            });\n\n            (n ? n.yield() : Promise.resolve({})).then(function (o) {\n              var l = a._createHeader(o, n ? n.options : {}),\n                  c = [{\n                level: J.supportedLogLevels.DEBUG,\n                messages: [\"url:\", t]\n              }, {\n                level: J.supportedLogLevels.DEBUG,\n                messages: [\"data:\", o]\n              }],\n                  d = null;\n\n              switch (e) {\n                case \"GET\":\n                case \"DELETE\":\n                  d = a._createQuery(u, o);\n                  break;\n\n                case \"POST\":\n                case \"PUT\":\n                  d = u;\n              }\n\n              var h = null;\n              if (\"undefined\" == typeof ServiceWorker || \"undefined\" == typeof ServiceWorkerRegistration || \"undefined\" != typeof ServiceWorkerContainer || ee() || \"function\" != typeof fetch) switch (e) {\n                case \"GET\":\n                  h = i.default.get(d, {\n                    headers: l,\n                    validateStatus: a._validateStatus\n                  });\n                  break;\n\n                case \"POST\":\n                  var p = {\n                    headers: l,\n                    validateStatus: a._validateStatus,\n                    onUploadProgress: function onUploadProgress(e) {\n                      n.upload.progressHandler && n.upload.progressHandler(e, n.upload.reqId);\n                    }\n                  };\n\n                  if (o instanceof s.default) {\n                    var f = null;\n                    \"function\" == typeof AbortController ? (f = new AbortController(), p.signal = f.signal) : (f = i.default.CancelToken.source(), p.cancelToken = f.token);\n                    var _ = a.cls.FileMessageQueue,\n                        g = n.upload.reqId;\n                    g && (c.push({\n                      level: J.supportedLogLevels.DEBUG,\n                      messages: [\"request id:\", g]\n                    }), _.uploadRequest[g] = f);\n                  }\n\n                  h = i.default.post(d, \"function\" == typeof o.getBuffer ? o.getBuffer() : o, p);\n                  break;\n\n                case \"PUT\":\n                  h = i.default.put(d, o, {\n                    headers: l,\n                    validateStatus: a._validateStatus\n                  });\n                  break;\n\n                case \"DELETE\":\n                  h = i.default.delete(d, {\n                    headers: l,\n                    validateStatus: a._validateStatus\n                  });\n              } else {\n                var y = {\n                  method: e,\n                  headers: l\n                };\n\n                switch (e) {\n                  case \"GET\":\n                    break;\n\n                  case \"POST\":\n                    if (o instanceof s.default) {\n                      if (\"function\" == typeof AbortController) {\n                        var m = new AbortController(),\n                            E = m.signal;\n                        y.signal = E;\n                        var v = a.cls.FileMessageQueue,\n                            b = n.upload.reqId;\n                        b && (c.push({\n                          level: J.supportedLogLevels.DEBUG,\n                          messages: [\"request id:\", b]\n                        }), v.uploadRequest[b] = m);\n                      }\n\n                      y.body = \"function\" == typeof o.getBuffer ? o.getBuffer() : o;\n                    } else l[\"Content-Type\"] = \"application/json; charset=utf-8\", y.body = JSON.stringify(o);\n\n                    break;\n\n                  case \"PUT\":\n                    o instanceof s.default ? y.body = \"function\" == typeof o.getBuffer ? o.getBuffer() : o : (l[\"Content-Type\"] = \"application/json; charset=utf-8\", y.body = JSON.stringify(o));\n                }\n\n                h = fetch(d, y).then(function (e) {\n                  return e.json().then(function (t) {\n                    if (!a._validateStatus(e.status)) throw {\n                      request: {\n                        isAbort: !1\n                      },\n                      response: {\n                        data: t\n                      }\n                    };\n                    return Promise.resolve({\n                      data: t\n                    });\n                  });\n                });\n              }\n              J.group(\"\".concat(e, \" request\"), c), c = [], h.then(function (t) {\n                try {\n                  var i = t.data;\n                  \"POST\" === e && \"function\" == typeof n.upload.deleteRequest && n.upload.deleteRequest(), c.push({\n                    level: J.supportedLogLevels.DEBUG,\n                    messages: [\"data:\", i]\n                  }), r(null, i);\n                } catch (e) {\n                  throw {\n                    code: le,\n                    rawError: e\n                  };\n                }\n              }).catch(function (i) {\n                if (i.code === le) throw i.rawError;\n                \"POST\" === e && \"function\" == typeof n.upload.deleteRequest && n.upload.deleteRequest();\n\n                var s = a._handleError(i);\n\n                if (c.push({\n                  level: J.supportedLogLevels.DEBUG,\n                  messages: [\"error:\", s]\n                }), t && n) {\n                  if (n.options && n.options.isSessionRefresh) r(s, null);else {\n                    var o = U.get(a.sb._iid).container.sessionManager;\n                    o.isSessionError(s) ? o.refreshSessionIfExpiredError(s).then(function () {\n                      return r(new H(\"Session is refreshed successfully.\", H.SESSION_REFRESH_SUCCESS), null);\n                    }).catch(function (e) {\n                      return r(new H(\"Session refresh failed.\", H.SESSION_REFRESH_FAILED), null);\n                    }) : r(s, null);\n                  }\n                } else r(s, null);\n              }).finally(function () {\n                return J.group(\"\".concat(e, \" response\"), c);\n              });\n            });\n          }\n        });\n      }\n    }, {\n      key: \"_validateStatus\",\n      value: function value(e) {\n        return e >= 200 && e < 400;\n      }\n    }, {\n      key: \"_handleError\",\n      value: function value(e) {\n        var t = e.request,\n            n = e.response;\n\n        if (t) {\n          if (t.isAbort || t.aborted) return new H(\"Request has been canceled.\", H.REQUEST_CANCELED);\n\n          if (n) {\n            var r = n.data,\n                i = r ? r.message : \"Request failed.\",\n                s = r ? r.code : H.REQUEST_FAILED;\n            return new H(i, s);\n          }\n\n          return new H(\"Request failed.\", H.REQUEST_FAILED);\n        }\n\n        return new H(\"There was a network error.\", H.NETWORK_ERROR);\n      }\n    }, {\n      key: \"get\",\n      value: function value(e, t, n) {\n        this._request(\"GET\", e, t, n);\n      }\n    }, {\n      key: \"dummyCall\",\n      value: function value(e) {\n        this._request(\"GET\", null, null, e);\n      }\n    }, {\n      key: \"post\",\n      value: function value(e, t, n) {\n        this._request(\"POST\", e, t, n);\n      }\n    }, {\n      key: \"put\",\n      value: function value(e, t, n) {\n        this._request(\"PUT\", e, t, n);\n      }\n    }, {\n      key: \"delete\",\n      value: function value(e, t, n) {\n        this._request(\"DELETE\", e, t, n);\n      }\n    }, {\n      key: \"refreshSessionKey\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.accessToken;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_SESSION_KEY.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae();\n            o.add(\"expiring_session\", !0), o.options.isSessionRefresh = !0, o.options.noSessionKey = !0, o.options.accessToken = i, r.post(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"updateCurrentUserInfo\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.nickname,\n            s = t.profileUrl,\n            a = t.profileImage,\n            o = t.preferredLanguages;\n        this.sb.ConnectionManager.ready(function (t, l) {\n          if (t) n(t, null);else {\n            var u = e.Path.USERS_USERID.replace(\"%s\", encodeURIComponent(l.userId)),\n                c = new ae();\n            i && c.add(\"nickname\", i), s && c.add(\"profile_url\", s), a && c.add(\"profile_file\", a, a.name), o && c.add(\"preferred_languages\", o), r.put(u, c, n);\n          }\n        });\n      }\n    }, {\n      key: \"getMyGroupChannelChangeLogs\",\n      value: function value(t, n) {\n        var r = this;\n        return oe(this.sb._iid, function (n) {\n          var i = t.ts,\n              s = t.token,\n              a = t.customTypes,\n              o = t.includeEmpty,\n              l = t.includeFrozen;\n          r.sb.ConnectionManager.ready(function (t, u) {\n            if (t) n(t, null);else {\n              var c = e.Path.USERS_USERID_MY_GROUP_CHANNEL_CHANGELOGS.replace(\"%s\", encodeURIComponent(u.userId)),\n                  d = new ae({\n                show_read_receipt: !0,\n                show_delivery_receipt: !0,\n                show_member: !0\n              });\n              s && d.add(\"token\", s), i && d.add(\"change_ts\", i), a && a.length > 0 && d.add(\"custom_types\", a), \"boolean\" == typeof o && d.add(\"show_empty\", o), \"boolean\" == typeof l && d.add(\"show_frozen\", l), r.get(c, d, n);\n            }\n          });\n        }, n);\n      }\n    }, {\n      key: \"getChannelInvitationPreference\",\n      value: function value(t, n) {\n        var r = this;\n        this.sb.ConnectionManager.ready(function (t, i) {\n          if (t) n(t, null);else {\n            var s = e.Path.USERS_USERID_GROUP_CHANNEL_INVITATION_PREFERENCE.replace(\"%s\", encodeURIComponent(i.userId));\n            r.get(s, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"getGroupChannelCount\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.memberStateFilter;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = r.cls.GroupChannel,\n                o = e.Path.USERS_USERID_GROUP_CHANNEL_COUNT.replace(\"%s\", encodeURIComponent(s.userId)),\n                l = \"\";\n\n            switch (i) {\n              case a.MemberStateFilter.JOINED:\n                l = \"joined\";\n                break;\n\n              case a.MemberStateFilter.INVITED:\n                l = \"invited\";\n                break;\n\n              case a.MemberStateFilter.INVITED_BY_FRIEND:\n                l = \"invited_by_friend\";\n                break;\n\n              case a.MemberStateFilter.INVITED_BY_NON_FRIEND:\n                l = \"invited_by_non_friend\";\n                break;\n\n              case a.MemberStateFilter.LEFT:\n                l = \"left\";\n\n              default:\n                l = \"all\";\n            }\n\n            var u = new ae({\n              state: l\n            });\n            r.get(o, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"getUnreadItemCount\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.keys;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_UNREAD_ITEM_COUNT.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              item_keys: i\n            });\n            r.get(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"getTotalUnreadMessageCount\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.customTypesFilter,\n            s = t.superChannelFilter;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.USERS_USERID_UNREAD_MESSAGE_COUNT.replace(\"%s\", encodeURIComponent(a.userId)),\n                l = new ae({\n              super_mode: s\n            });\n            null !== i && i.length > 0 && l.add(\"custom_types\", i), r.get(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"getTotalUnreadChannelCount\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.customTypesFilter,\n            s = t.superChannelFilter;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.USERS_USERID_UNREAD_CHANNEL_COUNT.replace(\"%s\", encodeURIComponent(a.userId)),\n                l = new ae({\n              super_mode: s\n            });\n            null !== i && i.length > 0 && l.add(\"custom_types\", i), r.get(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"searchMessages\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.keyword,\n            s = t.limit,\n            a = t.reverse,\n            o = t.exactMatch,\n            l = t.channelUrl,\n            u = t.channelCustomType,\n            c = t.messageTimestampFrom,\n            d = t.messageTimestampTo,\n            h = t.order,\n            p = t.nextToken,\n            f = t.advancedQuery,\n            _ = t.targetFields;\n        this.sb.ConnectionManager.ready(function (t, g) {\n          if (t) n(t, null);else {\n            var y = e.Path.SEARCH_MESSAGE,\n                m = new ae({\n              limit: s,\n              reverse: a,\n              query: i,\n              custom_type: u\n            });\n            c && m.add(\"message_ts_from\", c), d && m.add(\"message_ts_to\", d), l && m.add(\"channel_url\", l), h && m.add(\"sort_field\", h), \"boolean\" == typeof o && m.add(\"exact_match\", o), null !== p && p.length > 0 && m.add(\"after\", p), \"boolean\" == typeof f && m.add(\"advanced_query\", f), _ && Array.isArray(_) && m.add(\"target_fields\", _), r.get(y, m, n);\n          }\n        });\n      }\n    }, {\n      key: \"markAsReadAll\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrls;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_MARKASREADALL.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae();\n            i && o.add(\"channel_urls\", i), r.put(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"markAsDelivered\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.userId;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES_MARKASDELIVERED.replace(\"%s\", encodeURIComponent(i)),\n                l = new ae();\n            s && l.add(\"user_id\", s), r.put(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"setChannelInvitationPreference\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.isAutoAccept;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_GROUP_CHANNEL_INVITATION_PREFERENCE.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              auto_accept: i\n            });\n            r.put(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"blockUser\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.blockedUserId;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_BLOCK.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              target_id: i\n            });\n            r.post(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"unblockUser\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.unblockedUserId;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_BLOCK_TARGETID.replace(\"%s\", encodeURIComponent(s.userId)).replace(\"%s\", encodeURIComponent(i));\n            r.delete(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"getPushTriggerOption\",\n      value: function value(t, n) {\n        var r = this;\n        this.sb.ConnectionManager.ready(function (t, i) {\n          if (t) n(t, null);else {\n            var s = e.Path.USERS_USERID_PUSHPREFERENCE.replace(\"%s\", encodeURIComponent(i.userId));\n            r.get(s, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"setPushTriggerOption\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.pushTriggerOption;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_PUSHPREFERENCE.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              push_trigger_option: i\n            });\n            r.put(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"getPushTokens\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.ts,\n            s = t.token,\n            a = t.type;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.USERS_USERID_PUSH_DEVICE_TOKENS.replace(\"%s\", encodeURIComponent(o.userId)).replace(\"%s\", encodeURIComponent(a)),\n                u = new ae();\n            s && u.add(\"token\", s), i && u.add(\"created_ts\", i), r.get(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"getPushTemplate\",\n      value: function value(t, n) {\n        var r = this;\n        this.sb.ConnectionManager.ready(function (t, i) {\n          if (t) n(t, null);else {\n            var s = e.Path.USERS_USERID_PUSH_TEMPLATE.replace(\"%s\", encodeURIComponent(i.userId));\n            r.get(s, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"setPushTemplate\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.templateName;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_PUSH_TEMPLATE.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              name: i\n            });\n            r.put(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"getDoNotDisturb\",\n      value: function value(t, n) {\n        var r = this;\n        this.sb.ConnectionManager.ready(function (t, i) {\n          if (t) n(t, null);else {\n            var s = e.Path.USERS_USERID_PUSHPREFERENCE.replace(\"%s\", encodeURIComponent(i.userId));\n            r.get(s, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"setDoNotDisturb\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.doNotDisturbOn,\n            s = t.startHour,\n            a = t.startMin,\n            o = t.endHour,\n            l = t.endMin,\n            u = t.timezone;\n        this.sb.ConnectionManager.ready(function (t, c) {\n          if (t) n(t, null);else {\n            var d = e.Path.USERS_USERID_PUSHPREFERENCE.replace(\"%s\", encodeURIComponent(c.userId)),\n                h = new ae({\n              do_not_disturb: i,\n              start_hour: s,\n              start_min: a,\n              end_hour: o,\n              end_min: l,\n              timezone: u\n            });\n            r.put(d, h, n);\n          }\n        });\n      }\n    }, {\n      key: \"getSnoozePeriod\",\n      value: function value(t, n) {\n        var r = this;\n        this.sb.ConnectionManager.ready(function (t, i) {\n          if (t) n(t, null);else {\n            var s = e.Path.USERS_USERID_PUSHPREFERENCE.replace(\"%s\", encodeURIComponent(i.userId));\n            r.get(s, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"setSnoozePeriod\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.snoozeOn,\n            s = t.startTs,\n            a = t.endTs;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.USERS_USERID_PUSHPREFERENCE.replace(\"%s\", encodeURIComponent(o.userId)),\n                u = new ae({\n              snooze_enabled: i,\n              snooze_start_ts: s,\n              snooze_end_ts: a\n            });\n            r.put(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"registerGCMPushToken\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_PUSH_GCM.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              gcm_reg_token: i,\n              always_push: !0\n            });\n            r.post(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"unregisterGCMPushToken\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_PUSH_GCM_TOKEN.replace(\"%s\", encodeURIComponent(s.userId)).replace(\"%s\", encodeURIComponent(i));\n            r.delete(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"unregisterAllGCMPushTokens\",\n      value: function value(t, n) {\n        var r = this;\n        this.sb.ConnectionManager.ready(function (t, i) {\n          if (t) n(t, null);else {\n            var s = e.Path.USERS_USERID_PUSH_GCM.replace(\"%s\", encodeURIComponent(i.userId));\n            r.delete(s, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"registerAPNSPushToken\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_PUSH_APNS.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              apns_device_token: i,\n              always_push: !0\n            });\n            r.post(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"unregisterAPNSPushToken\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_PUSH_APNS_TOKEN.replace(\"%s\", encodeURIComponent(s.userId)).replace(\"%s\", encodeURIComponent(i));\n            r.delete(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"unregisterAllAPNSPushTokens\",\n      value: function value(t, n) {\n        var r = this;\n        this.sb.ConnectionManager.ready(function (t, i) {\n          if (t) n(t, null);else {\n            var s = e.Path.USERS_USERID_PUSH_APNS.replace(\"%s\", encodeURIComponent(i.userId));\n            r.delete(s, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"unregisterAllPushTokens\",\n      value: function value(t, n) {\n        var r = this;\n        this.sb.ConnectionManager.ready(function (t, i) {\n          if (t) n(t, null);else {\n            var s = e.Path.USERS_USERID_PUSH.replace(\"%s\", encodeURIComponent(i.userId));\n            r.delete(s, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"loadFriendList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token,\n            s = t.limit;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.FRIENDS.replace(\"%s\", encodeURIComponent(a.userId)),\n                l = new ae({\n              limit: s,\n              token: i\n            });\n            r.get(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"getFriendChangeLogsByToken\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.FRIENDS_CHANGE_LOGS.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae();\n            i && o.add(\"token\", i), r.get(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"addFriends\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.userIds;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.FRIENDS.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              user_ids: i\n            });\n            r.post(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteFriends\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.userIds;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.FRIENDS.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              user_ids: i\n            });\n            r.delete(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"uploadFriendDiscoveries\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.discoveries;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.FRIENDS_DISCOVERIES.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = [];\n            i.forEach(function (e) {\n              o.push({\n                friend_discovery_key: e.friendDiscoveryKey,\n                friend_name: \"string\" == typeof e.friendName || e.friendName ? e.friendName : null\n              });\n            });\n            var l = new ae({\n              friend_discoveries: o\n            });\n            r.put(a, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteFriendDiscoveries\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.discoveryKeys;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.FRIENDS_DISCOVERIES.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              friend_discovery_keys: i\n            });\n            r.delete(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"loadUserList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token,\n            s = t.limit,\n            a = t.userIdsFilter,\n            o = t.metaDataKeyFilter,\n            l = t.metaDataValuesFilter,\n            u = t.nicknameStartsWithFilter;\n        this.sb.ConnectionManager.ready(function (t, c) {\n          if (t) n(t, null);else {\n            var d = e.Path.USERS,\n                h = new ae({\n              token: i,\n              limit: s\n            });\n            a && a.length > 0 && h.add(\"user_ids\", a), o && l && l.length > 0 && (h.add(\"metadatakey\", o), h.add(\"metadatavalues_in\", l)), u && h.add(\"nickname_startswith\", u), r.get(d, h, n);\n          }\n        });\n      }\n    }, {\n      key: \"loadBlockedUserList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token,\n            s = t.limit,\n            a = t.userIdsFilter;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.USERS_USERID_BLOCK.replace(\"%s\", encodeURIComponent(o.userId)),\n                u = new ae({\n              token: i,\n              limit: s\n            });\n            a && a.length > 0 && u.add(\"user_ids\", a), r.get(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"createUserMetaData\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.metaData;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_METADATA.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae({\n              metadata: i\n            });\n            r.post(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"updateUserMetaData\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.metaData,\n            s = t.upsert;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.USERS_USERID_METADATA.replace(\"%s\", encodeURIComponent(a.userId)),\n                l = new ae({\n              metadata: i,\n              upsert: s\n            });\n            r.put(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteUserMetaData\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.metaDataKey;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_METADATA_KEY.replace(\"%s\", encodeURIComponent(s.userId)).replace(\"%s\", encodeURIComponent(i));\n            r.delete(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteAllUserMetaData\",\n      value: function value(t, n) {\n        var r = this;\n        this.sb.ConnectionManager.ready(function (t, i) {\n          if (t) n(t, null);else {\n            var s = e.Path.USERS_USERID_METADATA.replace(\"%s\", encodeURIComponent(i.userId));\n            r.delete(s, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"getMessageChangeLogs\",\n      value: function value(t, n) {\n        var r = this;\n        return oe(this.sb._iid, function (n) {\n          var i = t.channelUrl,\n              s = t.ts,\n              a = t.timestamp,\n              o = t.token,\n              l = t.isOpenChannel,\n              u = t.includeMetaArray,\n              c = t.includeReaction,\n              d = t.includeReactions,\n              h = t.includeReplies,\n              p = t.includeParentMessageText,\n              f = t.includeThreadInfo,\n              _ = t.replyType,\n              g = t.includeParentMessageInfo,\n              y = t.includePollDetails;\n          r.sb.ConnectionManager.ready(function (t, m) {\n            if (t) n(t, null);else {\n              var E = l ? e.Path.OPENCHANNELS_CHANNELURL_MESSAGES_CHANGELOGS.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES_CHANGELOGS.replace(\"%s\", encodeURIComponent(i)),\n                  v = new ae();\n              o && v.add(\"token\", o), s && v.add(\"change_ts\", s), a && v.add(\"change_ts\", a), \"boolean\" == typeof u && v.add(\"with_sorted_meta_array\", u), \"boolean\" == typeof d ? v.add(\"include_reactions\", d) : v.add(\"include_reactions\", \"boolean\" == typeof c && c), \"boolean\" == typeof f && v.add(\"include_thread_info\", f), \"string\" == typeof _ ? v.add(\"include_reply_type\", _) : v.add(\"include_reply_type\", \"boolean\" == typeof h && h ? r.cls.BaseMessage.ReplyType.ALL : r.cls.BaseMessage.ReplyType.NONE), \"boolean\" == typeof g ? v.add(\"include_parent_message_info\", g) : v.add(\"include_parent_message_info\", \"boolean\" == typeof p && p), \"boolean\" == typeof y && v.add(\"include_poll_details\", y), r.get(E, v, n);\n            }\n          });\n        }, n);\n      }\n    }, {\n      key: \"getMyMutedInfo\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.userId,\n            a = t.isGroupChannel;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = a ? e.Path.GROUPCHANNELS_CHANNELURL_MUTE_USERID.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", encodeURIComponent(s)) : e.Path.OPENCHANNELS_CHANNELURL_MUTE_USERID.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", encodeURIComponent(s));\n            r.get(l, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"loadBannedUserList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token,\n            s = t.limit,\n            a = t.channelUrl,\n            o = t.isOpenChannel;\n        this.sb.ConnectionManager.ready(function (t, l) {\n          if (t) n(t, null);else {\n            var u = o ? e.Path.OPENCHANNELS_CHANNELURL_BAN.replace(\"%s\", encodeURIComponent(a)) : e.Path.GROUPCHANNELS_CHANNELURL_BAN.replace(\"%s\", encodeURIComponent(a)),\n                c = new ae({\n              token: i,\n              limit: s\n            });\n            r.get(u, c, n);\n          }\n        });\n      }\n    }, {\n      key: \"loadMutedUserList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token,\n            s = t.limit,\n            a = t.channelUrl,\n            o = t.isOpenChannel;\n        this.sb.ConnectionManager.ready(function (t, l) {\n          if (t) n(t, null);else {\n            var u = o ? e.Path.OPENCHANNELS_CHANNELURL_MUTE.replace(\"%s\", encodeURIComponent(a)) : e.Path.GROUPCHANNELS_CHANNELURL_MUTE.replace(\"%s\", encodeURIComponent(a)),\n                c = new ae({\n              token: i,\n              limit: s\n            });\n            r.get(u, c, n);\n          }\n        });\n      }\n    }, {\n      key: \"getMessageList\",\n      value: function value(t, n) {\n        var r = this;\n        return oe(this.sb._iid, function (n) {\n          var i = t.channel,\n              s = t.token,\n              a = t.tokenType,\n              o = t.isInclusive,\n              l = t.prevResultSize,\n              u = void 0 === l ? 0 : l,\n              c = t.nextResultSize,\n              d = void 0 === c ? 0 : c,\n              h = t.shouldReverse,\n              p = t.messageType,\n              f = t.customType,\n              _ = t.customTypes,\n              g = t.senderUserIds,\n              y = t.includeMetaArray,\n              m = t.includeReaction,\n              E = t.includeReactions,\n              v = t.includeReplies,\n              b = t.includeParentMessageText,\n              C = t.includeThreadInfo,\n              A = t.replyType,\n              N = t.includeParentMessageInfo,\n              S = t.showSubchannelMessagesOnly,\n              I = t.includePollDetails,\n              T = t.rootMessageId,\n              O = t.parentMessageId;\n          r.sb.ConnectionManager.ready(function (t, l) {\n            if (t) n(t, null);else {\n              var c = i.isOpenChannel() ? e.Path.OPENCHANNELS_CHANNELURL_MESSAGES.replace(\"%s\", i.url) : e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES.replace(\"%s\", i.url),\n                  U = new ae({\n                is_sdk: String(!0),\n                prev_limit: String(u),\n                next_limit: String(d),\n                include: String(o),\n                reverse: String(h)\n              });\n              \"timestamp\" === a ? U.add(\"message_ts\", s) : \"messageId\" === a && U.add(\"message_id\", String(s)), p && U.add(\"message_type\", String(p)), Array.isArray(_) && (0 === _.length && (\"string\" == typeof f ? _.push(f) : _.push(\"*\")), U.add(\"custom_types\", _)), Array.isArray(g) && g.length > 0 && U.add(\"sender_ids\", g), \"boolean\" == typeof y && U.add(\"with_sorted_meta_array\", y), \"boolean\" == typeof E ? U.add(\"include_reactions\", E) : U.add(\"include_reactions\", \"boolean\" == typeof m && m), \"boolean\" == typeof C && U.add(\"include_thread_info\", C), \"string\" == typeof A ? U.add(\"include_reply_type\", A) : U.add(\"include_reply_type\", \"boolean\" == typeof v && v ? r.cls.BaseMessage.ReplyType.ALL : r.cls.BaseMessage.ReplyType.NONE), \"boolean\" == typeof N ? U.add(\"include_parent_message_info\", N) : U.add(\"include_parent_message_info\", \"boolean\" == typeof b && b), \"boolean\" == typeof S && i.isOpenChannel() && U.add(\"show_subchannel_messages_only\", S), \"boolean\" == typeof I && U.add(\"include_poll_details\", I), T && U.add(\"root_message_id\", T), O && U.add(\"parent_message_id\", O), r.get(c, U, n);\n            }\n          });\n        }, n);\n      }\n    }, {\n      key: \"checkMessageHugeGap\",\n      value: function value(t, n) {\n        var r = this;\n        return oe(this.sb._iid, function (n) {\n          var i = t.channelUrl;\n          t.channelType;\n          var s = t.messageType,\n              a = void 0 === s ? \"\" : s,\n              o = t.customTypes,\n              l = void 0 === o ? [\"*\"] : o,\n              u = t.senderUserIds,\n              c = void 0 === u ? [] : u,\n              d = t.includeReactions,\n              h = void 0 === d || d,\n              p = t.includeMetaArray,\n              f = void 0 !== p && p,\n              _ = t.showSubchannelMessagesOnly,\n              g = void 0 !== _ && _,\n              y = t.threshold,\n              m = t.previous,\n              E = t.next,\n              v = \"\".concat(e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES_GAP.replace(\"%s\", encodeURIComponent(i))),\n              b = new ae({\n            huge_gap_threshold: y,\n            prev_start_ts: m.from,\n            prev_end_ts: m.to,\n            prev_cache_count: m.cachedCount,\n            next_start_ts: E.from,\n            next_end_ts: E.to,\n            next_cache_count: E.cachedCount,\n            reverse: !0,\n            custom_types: l,\n            message_type: a,\n            include_reactions: h,\n            with_sorted_meta_array: f,\n            show_subchannel_messages_only: g\n          });\n          Array.isArray(c) && c.length > 0 && b.add(\"sender_ids\", c), r.get(v, b, n);\n        }, n);\n      }\n    }, {\n      key: \"translateUserMessage\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.messageId,\n            o = t.translationTargetLanguages;\n        this.sb.ConnectionManager.ready(function (t, l) {\n          if (t) n(t, null);else {\n            var u = s ? e.Path.OPENCHANNELS_CHANNELURL_MESSAGES_MESSAGEID_TRANSLATION.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", a) : e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES_MESSAGEID_TRANSLATION.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", a),\n                c = new ae({\n              target_langs: o\n            });\n            r.post(u, c, n);\n          }\n        });\n      }\n    }, {\n      key: \"getMessage\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channel,\n            s = t.messageId,\n            a = t.includeMetaArray,\n            o = t.includeReactions,\n            l = t.includeParentMessageText,\n            u = t.includeThreadInfo,\n            c = t.includeParentMessageInfo,\n            d = t.includePollDetails;\n        this.sb.ConnectionManager.ready(function (t, h) {\n          if (t) n(t, null);else {\n            var p = i.isOpenChannel() ? e.Path.OPENCHANNELS_CHANNELURL_MESSAGES_MESSAGEID.replace(\"%s\", encodeURIComponent(i.url)).replace(\"%s\", encodeURIComponent(s)) : e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES_MESSAGEID.replace(\"%s\", encodeURIComponent(i.url)).replace(\"%s\", encodeURIComponent(s)),\n                f = new ae({\n              is_sdk: String(!0)\n            });\n            \"boolean\" == typeof a && f.add(\"with_sorted_meta_array\", a), \"boolean\" == typeof o && f.add(\"include_reactions\", o), \"boolean\" == typeof u && f.add(\"include_thread_info\", u), \"boolean\" == typeof c ? f.add(\"include_parent_message_info\", c) : f.add(\"include_parent_message_info\", \"boolean\" == typeof l && l), \"boolean\" == typeof d && f.add(\"include_poll_details\", d), r.get(p, f, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteMessage\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.messageId;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = s ? e.Path.OPENCHANNELS_CHANNELURL_MESSAGES_MESSAGEID.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", encodeURIComponent(a)) : e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES_MESSAGEID.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", encodeURIComponent(a));\n            r.delete(l, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"muteUser\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.userId,\n            a = t.description,\n            o = t.seconds,\n            l = t.isGroupChannel;\n        this.sb.ConnectionManager.ready(function (t, u) {\n          if (t) n(t, null);else {\n            var c = l ? e.Path.GROUPCHANNELS_CHANNELURL_MUTE.replace(\"%s\", encodeURIComponent(i)) : e.Path.OPENCHANNELS_CHANNELURL_MUTE.replace(\"%s\", encodeURIComponent(i)),\n                d = new ae({\n              user_id: s\n            });\n            o && (o > 0 || -1 !== o) && d.add(\"seconds\", o), a && d.add(\"description\", a), r.post(c, d, n);\n          }\n        });\n      }\n    }, {\n      key: \"unmuteUser\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.userId,\n            a = t.isGroupChannel;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = a ? e.Path.GROUPCHANNELS_CHANNELURL_MUTE_USERID.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", encodeURIComponent(s)) : e.Path.OPENCHANNELS_CHANNELURL_MUTE_USERID.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", encodeURIComponent(s));\n            r.delete(l, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"banUser\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.userId,\n            a = t.description,\n            o = t.seconds,\n            l = t.isGroupChannel;\n        this.sb.ConnectionManager.ready(function (t, u) {\n          if (t) n(t, null);else {\n            var c = l ? e.Path.GROUPCHANNELS_CHANNELURL_BAN.replace(\"%s\", encodeURIComponent(i)) : e.Path.OPENCHANNELS_CHANNELURL_BAN.replace(\"%s\", encodeURIComponent(i)),\n                d = new ae({\n              user_id: s\n            });\n            a && d.add(\"description\", a), d.add(\"seconds\", String(o)), r.post(c, d, n);\n          }\n        });\n      }\n    }, {\n      key: \"unbanUser\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.userId,\n            a = t.isGroupChannel;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = a ? e.Path.GROUPCHANNELS_CHANNELURL_BAN_USERID.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", encodeURIComponent(s)) : e.Path.OPENCHANNELS_CHANNELURL_BAN_USERID.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", encodeURIComponent(s));\n            r.delete(l, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"getMetaCounters\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.keys;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = s ? e.Path.OPENCHANNELS_CHANNELURL_METACOUNTER.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_CHANNELURL_METACOUNTER.replace(\"%s\", encodeURIComponent(i)),\n                u = new ae({\n              keys: a\n            });\n            r.get(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"createMetaCounters\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.metaCounter;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = s ? e.Path.OPENCHANNELS_CHANNELURL_METACOUNTER.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_CHANNELURL_METACOUNTER.replace(\"%s\", encodeURIComponent(i)),\n                u = new ae({\n              metacounter: a\n            });\n            r.post(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"updateMetaCounters\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.metaCounter,\n            o = t.upsert,\n            l = t.mode;\n        this.sb.ConnectionManager.ready(function (t, u) {\n          if (t) n(t, null);else {\n            var c = s ? e.Path.OPENCHANNELS_CHANNELURL_METACOUNTER.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_CHANNELURL_METACOUNTER.replace(\"%s\", encodeURIComponent(i)),\n                d = new ae({\n              metacounter: a,\n              upsert: o,\n              mode: l\n            });\n            r.put(c, d, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteMetaCounter\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.key;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = s ? e.Path.OPENCHANNELS_CHANNELURL_METACOUNTER_KEY.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", a) : e.Path.GROUPCHANNELS_CHANNELURL_METACOUNTER_KEY.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", a);\n            r.delete(l, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteAllMetaCounters\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = s ? e.Path.OPENCHANNELS_CHANNELURL_METACOUNTER.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_CHANNELURL_METACOUNTER.replace(\"%s\", encodeURIComponent(i));\n            r.delete(o, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"getMetaData\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.keys;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = s ? e.Path.OPENCHANNELS_CHANNELURL_METADATA.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_CHANNELURL_METADATA.replace(\"%s\", encodeURIComponent(i)),\n                u = new ae({\n              keys: a,\n              include_ts: !0\n            });\n            r.get(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"createMetaData\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.metaData;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = s ? e.Path.OPENCHANNELS_CHANNELURL_METADATA.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_CHANNELURL_METADATA.replace(\"%s\", encodeURIComponent(i)),\n                u = new ae({\n              metadata: a,\n              include_ts: !0\n            });\n            r.post(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"updateMetaData\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.metaData,\n            o = t.upsert;\n        this.sb.ConnectionManager.ready(function (t, l) {\n          if (t) n(t, null);else {\n            var u = s ? e.Path.OPENCHANNELS_CHANNELURL_METADATA.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_CHANNELURL_METADATA.replace(\"%s\", encodeURIComponent(i)),\n                c = new ae({\n              metadata: a,\n              upsert: o,\n              include_ts: !0\n            });\n            r.put(u, c, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteMetaData\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.key;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = s ? e.Path.OPENCHANNELS_CHANNELURL_METADATA_KEY.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", a) : e.Path.GROUPCHANNELS_CHANNELURL_METADATA_KEY.replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", a),\n                u = new ae({\n              include_ts: !0\n            });\n            r.delete(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteAllMetaData\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = s ? e.Path.OPENCHANNELS_CHANNELURL_METADATA.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_CHANNELURL_METADATA.replace(\"%s\", encodeURIComponent(i)),\n                l = new ae({\n              include_ts: !0\n            });\n            r.delete(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"loadOperatorList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.token,\n            o = t.limit;\n        this.sb.ConnectionManager.ready(function (t, l) {\n          if (t) n(t, null);else {\n            var u = s ? e.Path.OPENCHANNELS_OPERATORS.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_OPERATORS.replace(\"%s\", encodeURIComponent(i)),\n                c = new ae({\n              token: a,\n              limit: o\n            });\n            r.get(u, c, n);\n          }\n        });\n      }\n    }, {\n      key: \"getOpenChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.internalCall;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.OPENCHANNELS_CHANNELURL.replace(\"%s\", encodeURIComponent(i)),\n                l = new ae({});\n            l.internal = s === T.INTERNAL_CALL, r.get(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"loadOpenChannelList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token,\n            s = t.limit,\n            a = t.nameKeyword,\n            o = t.urlKeyword,\n            l = t.customTypes,\n            u = t.includeFrozen,\n            c = t.includeMetaData;\n        this.sb.ConnectionManager.ready(function (t, d) {\n          if (t) n(t, null);else {\n            var h = e.Path.OPENCHANNELS,\n                p = new ae({\n              token: i,\n              limit: s\n            });\n            a && p.add(\"name_contains\", a), o && p.add(\"url_contains\", o), l && l.length > 0 && p.add(\"custom_types\", l), \"boolean\" == typeof u && p.add(\"show_frozen\", u), \"boolean\" == typeof c && p.add(\"show_metadata\", c), r.get(h, p, n);\n          }\n        });\n      }\n    }, {\n      key: \"loadParticipantList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token,\n            s = t.limit,\n            a = t.channelUrl;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.OPENCHANNELS_CHANNELURL_PARTICIPANTS.replace(\"%s\", encodeURIComponent(a)),\n                u = new ae({\n              token: i,\n              limit: s\n            });\n            r.get(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"createOpenChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.name,\n            s = t.coverUrlOrImage,\n            a = t.data,\n            o = t.operatorUserIds,\n            l = t.customType,\n            u = t.channelUrl;\n        this.sb.ConnectionManager.ready(function (t, c) {\n          if (t) n(t, null);else {\n            var d = e.Path.OPENCHANNELS,\n                h = new ae();\n            \"string\" == typeof s && h.add(\"cover_url\", s), se.isFile(s) && h.add(\"cover_file\", s), null !== u && \"string\" == typeof u && h.add(\"channel_url\", u), null !== i && \"string\" == typeof i && h.add(\"name\", i), a && h.add(\"data\", a), o && (Array.isArray(o) ? h.add(\"operators\", o) : h.add(\"operators\", [o])), l && h.add(\"custom_type\", l), r.post(d, h, n);\n          }\n        });\n      }\n    }, {\n      key: \"updateOpenChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.name,\n            a = t.coverUrlOrImage,\n            o = t.data,\n            l = t.operatorUserIds,\n            u = t.customType;\n        this.sb.ConnectionManager.ready(function (t, c) {\n          if (t) n(t, null);else {\n            var d = e.Path.OPENCHANNELS_CHANNELURL.replace(\"%s\", encodeURIComponent(i)),\n                h = new ae();\n            \"string\" == typeof a && h.add(\"cover_url\", a), se.isFile(a) && h.add(\"cover_file\", a, a.name), null !== s && \"string\" == typeof s && h.add(\"name\", s), null !== o && \"string\" == typeof o && h.add(\"data\", o), null !== l && (Array.isArray(l) ? h.add(\"operator_ids\", l) : h.add(\"operator_ids\", [l])), null !== u && \"string\" == typeof u && h.add(\"custom_type\", u), r.put(d, h, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteOpenChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.OPENCHANNELS_CHANNELURL.replace(\"%s\", encodeURIComponent(i));\n            r.delete(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"getGroupChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.showMember,\n            a = t.internalCall;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.GROUPCHANNELS_CHANNELURL.replace(\"%s\", encodeURIComponent(i)),\n                u = new ae({\n              show_member: s,\n              show_read_receipt: !0,\n              show_delivery_receipt: !0\n            });\n            u.internal = a === T.INTERNAL_CALL, r.get(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"loadGroupChannelList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token,\n            s = t.limit,\n            a = t.includeEmpty,\n            o = t.order,\n            l = t.userIdsFilter,\n            u = t.nicknameContainsFilter,\n            c = t.nicknameStartsWithFilter,\n            d = t.nicknameExactMatchFilter,\n            h = t.channelNameContainsFilter,\n            p = t.channelUrlsFilter,\n            f = t.customTypesFilter,\n            _ = t.customTypeStartsWithFilter,\n            g = t.memberStateFilter,\n            y = t.superChannelFilter,\n            m = t.publicChannelFilter,\n            E = t.unreadChannelFilter,\n            v = t.metadataOrderKeyFilter,\n            b = t.metadataKey,\n            C = t.metadataValues,\n            A = t.metadataValueStartsWith,\n            N = t.hiddenChannelFilter,\n            S = t.searchFilter,\n            I = t.includeFrozen,\n            T = t.includeMetaData;\n        return oe(this.sb._iid, function (t) {\n          r.sb.ConnectionManager.ready(function (n, O) {\n            if (n) t(n, null);else {\n              var U = e.Path.MYGROUPCHANNELS.replace(\"%s\", encodeURIComponent(O.userId)),\n                  M = new ae({\n                token: i,\n                limit: s,\n                order: o,\n                show_member: !0,\n                show_read_receipt: !0,\n                show_delivery_receipt: !0,\n                show_empty: String(a),\n                member_state_filter: g\n              });\n              f && f.length > 0 && M.add(\"custom_types\", f), u && M.add(\"members_nickname_contains\", u), c && M.add(\"members_nickname_startswith\", c), d && M.add(\"members_nickname\", d), h && M.add(\"name_contains\", h), S && S.hasOwnProperty(\"search_query\") && S.hasOwnProperty(\"search_fields\") && (M.add(\"search_query\", S.search_query), M.add(\"search_fields\", S.search_fields)), l && l.userIds && l.userIds.length > 0 && (l.includeMode ? (M.add(\"members_include_in\", l.userIds), M.add(\"query_type\", l.queryType.toUpperCase())) : M.add(\"members_exactly_in\", l.userIds)), p && p.length > 0 && M.add(\"channel_urls\", p), M.add(\"super_mode\", y), M.add(\"public_mode\", m), M.add(\"unread_filter\", E), v && M.add(\"metadata_order_key\", v), b && M.add(\"metadata_key\", b), C && C.length > 0 && M.add(\"metadata_values\", C), A && M.add(\"metadata_value_startswith\", A), _ && M.add(\"custom_type_startswith\", _), N && M.add(\"hidden_mode\", N), \"boolean\" == typeof I && M.add(\"show_frozen\", I), \"boolean\" == typeof T && M.add(\"show_metadata\", T), r.get(U, M, t);\n            }\n          });\n        }, n);\n      }\n    }, {\n      key: \"loadPublicGroupChannelList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.token,\n            s = t.limit,\n            a = t.includeEmpty,\n            o = t.order,\n            l = t.channelNameContainsFilter,\n            u = t.channelUrlsFilter,\n            c = t.customTypesFilter,\n            d = t.customTypeStartsWithFilter,\n            h = t.superChannelFilter,\n            p = t.membershipFilter,\n            f = t.metadataOrderKeyFilter,\n            _ = t.metadataKey,\n            g = t.metadataValues,\n            y = t.metadataValueStartsWith,\n            m = t.includeFrozen,\n            E = t.includeMetaData;\n        this.sb.ConnectionManager.ready(function (t, v) {\n          if (t) n(t, null);else {\n            var b = r.cls.GroupChannel,\n                C = e.Path.GROUPCHANNELS,\n                A = new ae({\n              token: i,\n              limit: s,\n              order: o,\n              show_member: !0,\n              show_read_receipt: !0,\n              show_delivery_receipt: !0,\n              show_empty: String(a),\n              public_mode: b.PublicChannelFilter.PUBLIC,\n              public_membership_mode: p\n            });\n            c && c.length > 0 && A.add(\"custom_types\", c), l && A.add(\"name_contains\", l), u && u.length > 0 && A.add(\"channel_urls\", u), A.add(\"super_mode\", h), f && A.add(\"metadata_order_key\", f), _ && A.add(\"metadata_key\", _), g && g.length > 0 && A.add(\"metadata_values\", g), y && A.add(\"metadata_value_startswith\", y), d && A.add(\"custom_type_startswith\", d), \"boolean\" == typeof m && A.add(\"show_frozen\", m), \"boolean\" == typeof E && A.add(\"show_metadata\", E), r.get(C, A, n);\n          }\n        });\n      }\n    }, {\n      key: \"createGroupChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.isDistinct,\n            s = t.isSuper,\n            a = t.isBroadcast,\n            o = t.isPublic,\n            l = t.channelUrl,\n            u = t.isDiscoverable,\n            c = t.isStrict,\n            d = t.name,\n            h = t.data,\n            p = t.customType,\n            f = t.coverUrl,\n            _ = t.coverImage,\n            g = t.accessCode,\n            y = t.isEphemeral,\n            m = t._invitedUserIds,\n            E = void 0 === m ? [] : m,\n            v = t.operatorUserIds,\n            b = t.messageSurvivalSeconds;\n        this.sb.ConnectionManager.ready(function (t, m) {\n          if (t) n(t, null);else {\n            var C = e.Path.GROUPCHANNELS,\n                N = new ae({\n              user_ids: [m.userId].concat(A(E)).filter(function (e, t, n) {\n                return t === n.indexOf(e);\n              })\n            });\n            null !== f && \"string\" == typeof f && N.add(\"cover_url\", f), se.isFile(_) && N.add(\"cover_file\", _, _.name), null !== l && N.add(\"channel_url\", l), null !== i && N.add(\"is_distinct\", i), null !== s && N.add(\"is_super\", s), null !== a && N.add(\"is_broadcast\", a), null !== o && N.add(\"is_public\", o), null !== u && N.add(\"is_discoverable\", u), null !== c && N.add(\"strict\", c), null !== y && N.add(\"is_ephemeral\", y), g && N.add(\"access_code\", g), null !== d && \"string\" == typeof d && N.add(\"name\", d), h && N.add(\"data\", h), p && N.add(\"custom_type\", p), Array.isArray(v) && v.length > 0 && N.add(\"operator_ids\", v), null !== b && b > -1 && N.add(\"message_survival_seconds\", b), r.post(C, N, n);\n          }\n        });\n      }\n    }, {\n      key: \"updateGroupChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.isDistinct,\n            s = t.isPublic,\n            a = t.channelUrl,\n            o = t.isDiscoverable,\n            l = t.name,\n            u = t.data,\n            c = t.customType,\n            d = t.coverUrl,\n            h = t.coverImage,\n            p = t.accessCode,\n            f = t.operatorUserIds,\n            _ = t.messageSurvivalSeconds;\n        this.sb.ConnectionManager.ready(function (t, g) {\n          if (t) n(t, null);else {\n            var y = e.Path.GROUPCHANNELS_CHANNELURL.replace(\"%s\", encodeURIComponent(a)),\n                m = new ae();\n            null !== i && m.add(\"is_distinct\", i), null !== s && m.add(\"is_public\", s), null !== o && m.add(\"is_discoverable\", o), null !== p && m.add(\"access_code\", p), null !== d && \"string\" == typeof d && m.add(\"cover_url\", d), se.isFile(h) && m.add(\"cover_file\", h, h.name), null !== l && \"string\" == typeof l && m.add(\"name\", l), null !== u && \"string\" == typeof u && m.add(\"data\", u), null !== c && \"string\" == typeof c && m.add(\"custom_type\", c), null !== f && (Array.isArray(f) ? m.add(\"operator_ids\", f) : f && m.add(\"operator_ids\", [f])), null !== _ && _ > -1 && m.add(\"message_survival_seconds\", _), r.put(y, m, n);\n          }\n        });\n      }\n    }, {\n      key: \"addOperators\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = void 0 !== s && s,\n            o = t.operatorUserIds;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (!t) {\n            var l = (a ? e.Path.OPENCHANNELS_CHANNELURL_OPERATORS : e.Path.GROUPCHANNELS_CHANNELURL_OPERATORS).replace(\"%s\", encodeURIComponent(i)),\n                u = new ae({\n              operator_ids: o\n            });\n            r.post(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"removeOperators\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = void 0 !== s && s,\n            o = t.operatorUserIds;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (!t) {\n            var l = (a ? e.Path.OPENCHANNELS_CHANNELURL_OPERATORS : e.Path.GROUPCHANNELS_CHANNELURL_OPERATORS).replace(\"%s\", encodeURIComponent(i)),\n                u = new ae({\n              operator_ids: o\n            });\n            r.delete(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"inviteToGroupChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.userIds;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.GROUPCHANNELS_CHANNELURL_INVITE.replace(\"%s\", encodeURIComponent(i)),\n                l = new ae({\n              user_ids: s\n            });\n            r.post(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"acceptInvitation\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.accessCode;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.GROUPCHANNELS_CHANNELURL_ACCEPT_INVITATION.replace(\"%s\", encodeURIComponent(i)),\n                l = new ae({\n              user_id: a.userId\n            });\n            s && l.add(\"access_code\", s), r.put(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"declineInvitation\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.GROUPCHANNELS_CHANNELURL_DECLINE_INVITATION.replace(\"%s\", encodeURIComponent(i)),\n                o = new ae({\n              user_id: s.userId\n            });\n            r.put(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"joinGroupChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.accessCode;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.GROUPCHANNELS_CHANNELURL_JOIN.replace(\"%s\", encodeURIComponent(i)),\n                l = new ae({\n              user_id: a.userId\n            });\n            s && l.add(\"access_code\", s), r.put(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"leaveGroupChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.GROUPCHANNELS_CHANNELURL_LEAVE.replace(\"%s\", encodeURIComponent(i)),\n                o = new ae({\n              user_id: s.userId\n            });\n            r.put(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"hideGroupChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.hidePreviousMessages,\n            a = t.allowAutoUnhide;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.GROUPCHANNELS_CHANNELURL_HIDE.replace(\"%s\", encodeURIComponent(i)),\n                u = new ae({\n              user_id: o.userId,\n              hide_previous_messages: s,\n              allow_auto_unhide: a\n            });\n            r.put(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"unhideGroupChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.GROUPCHANNELS_CHANNELURL_HIDE.replace(\"%s\", encodeURIComponent(i));\n            r.delete(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"freeze\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isGroupChannel,\n            a = t.freezing;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = s ? e.Path.GROUPCHANNELS_CHANNELURL_FREEZE.replace(\"%s\", encodeURIComponent(i)) : e.Path.OPENCHANNELS_CHANNELURL_FREEZE.replace(\"%s\", encodeURIComponent(i)),\n                u = new ae({\n              freeze: a\n            });\n            r.put(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteGroupChannel\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.GROUPCHANNELS_CHANNELURL.replace(\"%s\", encodeURIComponent(i));\n            r.delete(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"loadMemberList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.token,\n            a = t.limit,\n            o = t.mutedMemberFilter,\n            l = t.order,\n            u = t.memberStateFilter,\n            c = t.nicknameStartsWithFilter;\n        this.sb.ConnectionManager.ready(function (t, d) {\n          if (t) n(t, null);else {\n            var h = e.Path.GROUPCHANNELS_MEMBERS.replace(\"%s\", encodeURIComponent(i)),\n                p = new ae({\n              token: s,\n              limit: a,\n              order: l.toLowerCase(),\n              muted_member_filter: o.toLowerCase(),\n              member_state_filter: u,\n              show_member_is_muted: !0,\n              show_read_receipt: !0,\n              show_delivery_receipt: !0\n            });\n            c && p.add(\"nickname_startswith\", c), r.get(h, p, n);\n          }\n        });\n      }\n    }, {\n      key: \"report\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.reportCategory,\n            o = t.reportingUserId,\n            l = t.reportDescription;\n        this.sb.ConnectionManager.ready(function (t, u) {\n          if (t) n(t, null);else {\n            var c = e.Path.REPORT_CHANNELS.replace(\"%s\", encodeURIComponent(s ? \"open_channels\" : \"group_channels\")).replace(\"%s\", encodeURIComponent(i)),\n                d = new ae({\n              report_category: a\n            });\n            null != o && d.add(\"reporting_user_id\", o), null != l && d.add(\"report_description\", l), r.post(c, d, n);\n          }\n        });\n      }\n    }, {\n      key: \"reportUser\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.offendingUserId,\n            s = t.channelUrl,\n            a = t.isOpenChannel,\n            o = t.reportCategory,\n            l = t.reportingUserId,\n            u = t.reportDescription;\n        this.sb.ConnectionManager.ready(function (t, c) {\n          if (t) n(t, null);else {\n            var d = e.Path.REPORT_USERS.replace(\"%s\", encodeURIComponent(i)),\n                h = new ae({\n              channel_url: s,\n              channel_type: a ? \"open_channels\" : \"group_channels\",\n              report_category: o\n            });\n            null != l && h.add(\"reporting_user_id\", l), null != u && h.add(\"report_description\", u), r.post(d, h, n);\n          }\n        });\n      }\n    }, {\n      key: \"reportMessage\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.messageId,\n            o = t.reportCategory,\n            l = t.reportingUserId,\n            u = t.reportDescription,\n            c = t.offendingUserId;\n        this.sb.ConnectionManager.ready(function (t, d) {\n          if (t) n(t, null);else {\n            var h = e.Path.REPORT_MESSAGES.replace(\"%s\", encodeURIComponent(s ? \"open_channels\" : \"group_channels\")).replace(\"%s\", encodeURIComponent(i)).replace(\"%s\", encodeURIComponent(a)),\n                p = new ae({\n              report_category: o,\n              offending_user_id: c\n            });\n            null != l && p.add(\"reporting_user_id\", l), null != u && p.add(\"report_description\", u), r.post(h, p, n);\n          }\n        });\n      }\n    }, {\n      key: \"sendUserMessage\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.isOpenChannel,\n            a = t.message,\n            o = t.data,\n            l = t.customType,\n            u = t.translationTargetLanguages,\n            c = t.metaArrays,\n            d = t.mentionType,\n            h = t.mentionedUserIds,\n            p = t.mentionedMessageTemplate,\n            f = t.pushNotificationDeliveryOption,\n            _ = t.rootMessageId,\n            g = t.parentMessageId,\n            y = t.appleCriticalAlertOptions,\n            m = t.pollId,\n            E = t.isReplyToChannel;\n        this.sb.ConnectionManager.ready(function (t, v) {\n          if (t) n(t, null);else {\n            var b = r.cls.FileMessageParams,\n                C = s ? e.Path.OPENCHANNELS_CHANNELURL_MESSAGES.replace(\"%s\", encodeURIComponent(i)) : e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES.replace(\"%s\", encodeURIComponent(i)),\n                A = new ae({\n              message_type: \"MESG\",\n              user_id: v.userId,\n              message: a,\n              mention_type: d,\n              mentioned_user_ids: []\n            });\n            null != o && A.add(\"data\", o), null != l && A.add(\"custom_type\", l), u && A.add(\"translation_target_langs\", u), c && c.length > 0 && A.add(\"sorted_metaarray\", c.map(function (e) {\n              return e.encode();\n            })), d === r.cls.BaseMessageParams.MentionType.CHANNEL ? A.add(\"mentioned_user_ids\", []) : Array.isArray(h) && h.length > 0 && A.add(\"mentioned_user_ids\", h), p && A.add(\"mentioned_message_template\", p), f && f !== b.PushNotificationDeliveryOption.DEFAULT && A.add(\"push_option\", f), _ && A.add(\"root_message_id\", _), g && A.add(\"parent_message_id\", g), y && A.add(\"apple_critical_alert_options\", y.serialize()), \"number\" == typeof m ? A.add(\"poll_id\", m) : null === m && A.add(\"poll_id\", -1), E && A.add(\"reply_to_channel\", E), r.post(C, A, n);\n          }\n        });\n      }\n    }, {\n      key: \"sendFileMessage\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.reqId,\n            s = t.channelUrl,\n            a = t.isOpenChannel,\n            o = t.fileUrl,\n            l = t.fileName,\n            u = t.fileSize,\n            c = t.fileType,\n            d = t.data,\n            h = t.customType,\n            p = t.thumbnailSizes,\n            f = t.requireAuth,\n            _ = t.metaArrays,\n            g = t.mentionType,\n            y = t.mentionedUserIds,\n            m = t.pushNotificationDeliveryOption,\n            E = t.rootMessageId,\n            v = t.parentMessageId,\n            b = t.appleCriticalAlertOptions,\n            C = t.isReplyToChannel;\n        this.sb.ConnectionManager.ready(function (t, A) {\n          if (t) n(t, null);else {\n            var N = r.cls.FileMessageParams,\n                S = a ? e.Path.OPENCHANNELS_CHANNELURL_MESSAGES.replace(\"%s\", encodeURIComponent(s)) : e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES.replace(\"%s\", encodeURIComponent(s)),\n                I = new ae({\n              message_type: \"FILE\",\n              user_id: A.userId,\n              url: o,\n              mention_type: g,\n              mentioned_user_ids: [],\n              req_id: i\n            });\n            null != l && I.add(\"file_name\", l), null != u && I.add(\"file_size\", u), null != c && I.add(\"file_type\", c), null != d && I.add(\"custom_field\", d), null != h && I.add(\"custom_type\", h), p && I.add(\"thumbnails\", p), f && I.add(\"require_auth\", f), _ && _.length > 0 && I.add(\"sorted_metaarray\", _.map(function (e) {\n              return e.encode();\n            })), g === r.cls.BaseMessageParams.MentionType.CHANNEL ? I.add(\"mentioned_user_ids\", []) : Array.isArray(y) && y.length > 0 && I.add(\"mentioned_user_ids\", y), m && m !== N.PushNotificationDeliveryOption.DEFAULT && I.add(\"push_option\", m), E && I.add(\"root_message_id\", E), v && I.add(\"parent_message_id\", v), b && I.add(\"apple_critical_alert_options\", b.serialize()), C && I.add(\"reply_to_channel\", C), r.post(S, I, n);\n          }\n        });\n      }\n    }, {\n      key: \"uploadFile\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.file,\n            s = t.thumbnailSizes,\n            a = t.channelUrl,\n            o = t.progressHandler,\n            l = t.reqId;\n        this.sb.ConnectionManager.ready(function (t, u) {\n          if (t) n(t, null);else {\n            var c = U.get(r.sb._iid).container.appInfo;\n            if (c) {\n              if (\"number\" == typeof i.size || i.size || (i.size = 0), \"number\" == typeof i.size) {\n                if (i.size <= c.uploadSizeLimit) {\n                  var d = e.Path.STORAGE_FILE,\n                      h = new ae();\n                  if (h.add(\"file\", i, i.name), a && \"string\" == typeof a && h.add(\"channel_url\", a), s) for (var p = 0; p < s.length; p++) {\n                    h.add(\"thumbnail\" + (p + 1), s[p].maxWidth + \",\" + s[p].maxHeight);\n                  }\n                  h.upload.reqId = l, h.upload.deleteRequest = function () {\n                    var e = r.cls.FileMessageQueue;\n                    e.uploadRequest[l] && delete e.uploadRequest[l];\n                  }, h.upload.progressHandler = function (e) {\n                    o && \"function\" == typeof o && o(e, l);\n                  }, r.post(d, h, n);\n                } else n(new H(\"The file size exceeded the upload limit: \".concat(c.uploadSizeLimit), H.FILE_SIZE_LIMIT_EXCEEDED), null);\n              } else n(new H(\"Invalid file size: \".concat(i.size), H.INVALID_PARAMETER), null);\n            } else n(new H(\"Connection should be made first.\", H.CONNECTION_REQUIRED), null);\n          }\n        });\n      }\n    }, {\n      key: \"registerScheduledUserMessage\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.groupChannelParams,\n            s = t.channelUrl,\n            a = t.isOpenChannel;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = a ? e.Path.OPENCHANNELS_CHANNELURL_SCHEDULED_MESSAGES.replace(\"%s\", encodeURIComponent(s)) : e.Path.GROUPCHANNELS_CHANNELURL_SCHEDULED_MESSAGES.replace(\"%s\", encodeURIComponent(s)),\n                u = new ae({\n              scheduled_dt: i._getScheduleString(),\n              user_id: o.userId,\n              message: i.message,\n              data: i.data\n            });\n            i.customType && u.add(\"custom_type\", i.customType), i.metaArrayKeys && Object.keys(i.metaArrayKeys).length > 0 && u.add(\"metaarray\", i.metaArrayKeys), i.mentionType && u.add(\"mention_type\", i._mentionType), i._mentionType === r.cls.BaseMessageParams.MentionType.CHANNEL ? u.add(\"mentioned_user_ids\", []) : Array.isArray(i._mentionedUserIds) && i._mentionedUserIds.length > 0 && u.add(\"mentioned_user_ids\", i._mentionedUserIds), i.translationTargetLanguages && i.translationTargetLanguages.length > 0 && u.add(\"translation_target_langs\", i.translationTargetLanguages), i.pushNotificationDeliveryOption && i.pushNotificationDeliveryOption !== r.cls.BaseMessageParams.PushNotificationDeliveryOption.DEFAULT && u.add(\"push_option\", i.pushNotificationDeliveryOption), i.appleCriticalAlertOptions && u.add(\"apple_critical_alert_options\", i.appleCriticalAlertOptions.serialize()), r.post(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"getMyPushTriggerOption\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_PUSHPREFERENCE_CHANNELURL.replace(\"%s\", encodeURIComponent(s.userId)).replace(\"%s\", encodeURIComponent(i));\n            r.get(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"setMyPushTriggerOption\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.pushTriggerOption,\n            a = t.enable;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.USERS_USERID_PUSHPREFERENCE_CHANNELURL.replace(\"%s\", encodeURIComponent(o.userId)).replace(\"%s\", encodeURIComponent(i)),\n                u = new ae();\n            s && u.add(\"push_trigger_option\", s), \"boolean\" == typeof a && u.add(\"enable\", a), r.put(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"setMyCountPreference\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.countPreference;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.USERS_COUNT_PREFERENCE.replace(\"%s\", encodeURIComponent(a.userId)).replace(\"%s\", encodeURIComponent(i)),\n                l = new ae({\n              count_preference: s\n            });\n            r.put(o, l, n);\n          }\n        });\n      }\n    }, {\n      key: \"resetMyHistory\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.GROUPCHANNELS_RESET_USER_HISTORY.replace(\"%s\", encodeURIComponent(i));\n            r.put(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"addReaction\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.isGroupChannel,\n            s = t.channelUrl,\n            a = t.messageId,\n            o = t.key;\n        this.sb.ConnectionManager.ready(function (t, l) {\n          if (t) n(t, null);else {\n            var u = i ? e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES_MESSAGEID_REACTION.replace(\"%s\", encodeURIComponent(s)).replace(\"%s\", encodeURIComponent(a)) : e.Path.OPENCHANNELS_CHANNELURL_MESSAGES_MESSAGEID_REACTION.replace(\"%s\", encodeURIComponent(s)).replace(\"%s\", encodeURIComponent(a)),\n                c = new ae({\n              reaction: o\n            });\n            r.post(u, c, n);\n          }\n        });\n      }\n    }, {\n      key: \"deleteReaction\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.isGroupChannel,\n            s = t.channelUrl,\n            a = t.messageId,\n            o = t.key;\n        this.sb.ConnectionManager.ready(function (t, l) {\n          if (t) n(t, null);else {\n            var u = i ? e.Path.GROUPCHANNELS_CHANNELURL_MESSAGES_MESSAGEID_REACTION.replace(\"%s\", encodeURIComponent(s)).replace(\"%s\", encodeURIComponent(a)) : e.Path.OPENCHANNELS_CHANNELURL_MESSAGES_MESSAGEID_REACTION.replace(\"%s\", encodeURIComponent(s)).replace(\"%s\", encodeURIComponent(a)),\n                c = new ae({\n              reaction: o\n            });\n            r.delete(u, c, n);\n          }\n        });\n      }\n    }, {\n      key: \"getAllEmoji\",\n      value: function value(t) {\n        var n = this;\n        this.sb.ConnectionManager.ready(function (r, i) {\n          r ? t(r, null) : n.get(e.Path.EMOJI_CATEGORIES, null, t);\n        });\n      }\n    }, {\n      key: \"getEmojiCategory\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.categoryId;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.EMOJI_CATEGORIES_CATEGORYID.replace(\"%s\", i);\n            r.get(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"getEmoji\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.emojiKey;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.EMOJIS_EMOJIKEY.replace(\"%s\", i);\n            r.get(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"getAllowFriendDiscovery\",\n      value: function value(t) {\n        var n = this;\n        this.sb.ConnectionManager.ready(function (r, i) {\n          if (r) t(r, null);else {\n            var s = e.Path.USERS_USERID_ALLOW_FRIEND_DISCOVERY.replace(\"%s\", encodeURIComponent(i.userId));\n            n.get(s, null, t);\n          }\n        });\n      }\n    }, {\n      key: \"setAllowFriendDiscovery\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.allowFriendDiscovery;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.USERS_USERID_ALLOW_FRIEND_DISCOVERY.replace(\"%s\", encodeURIComponent(s.userId)),\n                o = new ae();\n            \"boolean\" == typeof i && o.add(\"allow_friend_discovery\", i), r.put(a, o, n);\n          }\n        });\n      }\n    }, {\n      key: \"getPollList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.token,\n            a = t.limit;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.POLLS,\n                u = new ae({\n              channel_url: i\n            });\n            s && u.add(\"token\", s), a && u.add(\"limit\", a), r.get(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"getPoll\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.pollId,\n            a = t.showPartialVoters;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.POLLS_POLLID.replace(\"%s\", s),\n                u = new ae({\n              channel_url: i\n            });\n            \"boolean\" == typeof a && u.add(\"show_partial_voter_list\", a), r.get(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"createPoll\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.title,\n            s = t.options,\n            a = t.data,\n            o = t.isAnonymous,\n            l = t.allowUserSuggestion,\n            c = t.allowMultipleVotes,\n            d = t.closeAt;\n        this.sb.ConnectionManager.ready(function (t, h) {\n          if (t) n(t, null);else {\n            var p = e.Path.POLLS,\n                f = new ae({\n              title: i,\n              options: s\n            });\n            \"object\" === u(a) && f.add(\"data\", a), \"boolean\" == typeof o && f.add(\"is_anonymous\", o), \"boolean\" == typeof l && f.add(\"allow_user_suggestion\", l), \"boolean\" == typeof c && f.add(\"allow_multiple_votes\", c), \"number\" == typeof d && f.add(\"close_at\", d), r.post(p, f, n);\n          }\n        });\n      }\n    }, {\n      key: \"updatePoll\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.pollId,\n            s = t.title,\n            a = t.options,\n            o = t.data,\n            l = t.isAnonymous,\n            c = t.allowUserSuggestion,\n            d = t.allowMultipleVotes,\n            h = t.closeAt;\n        this.sb.ConnectionManager.ready(function (t, p) {\n          if (t) n(t, null);else {\n            var f = e.Path.POLLS_POLLID.replace(\"%s\", i),\n                _ = new ae();\n\n            \"string\" == typeof s && _.add(\"title\", s), Array.isArray(a) && _.add(\"options\", a), \"object\" === u(o) && _.add(\"data\", o), \"boolean\" == typeof l && _.add(\"is_anonymous\", l), \"boolean\" == typeof c && _.add(\"allow_user_suggestion\", c), \"boolean\" == typeof d && _.add(\"allow_multiple_votes\", d), \"number\" == typeof h && _.add(\"close_at\", h), r.put(f, _, n);\n          }\n        });\n      }\n    }, {\n      key: \"deletePoll\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.pollId;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.POLLS_POLLID.replace(\"%s\", i);\n            r.delete(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"votePoll\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.pollId,\n            a = t.optionIds;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.POLLS_POLLID_VOTE.replace(\"%s\", s),\n                u = new ae({\n              channel_url: i\n            });\n            Array.isArray(a) && u.add(\"option_ids\", a), r.put(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"closePoll\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.pollId;\n        this.sb.ConnectionManager.ready(function (t, s) {\n          if (t) n(t, null);else {\n            var a = e.Path.POLLS_POLLID_CLOSE.replace(\"%s\", i);\n            r.put(a, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"getPollOption\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.pollId,\n            a = t.optionId;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.POLLS_POLLID_OPTIONS_OPTIONID.replace(\"%s\", s).replace(\"%s\", a),\n                u = new ae({\n              channel_url: i\n            });\n            r.get(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"addPollOption\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.pollId,\n            a = t.text;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.POLLS_POLLID_OPTIONS.replace(\"%s\", s),\n                u = new ae({\n              channel_url: i,\n              text: a\n            });\n            r.post(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"updatePollOption\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.pollId,\n            s = t.optionId,\n            a = t.text;\n        this.sb.ConnectionManager.ready(function (t, o) {\n          if (t) n(t, null);else {\n            var l = e.Path.POLLS_POLLID_OPTIONS_OPTIONID.replace(\"%s\", i).replace(\"%s\", s),\n                u = new ae({\n              text: a\n            });\n            r.put(l, u, n);\n          }\n        });\n      }\n    }, {\n      key: \"deletePollOption\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.pollId,\n            s = t.optionId;\n        this.sb.ConnectionManager.ready(function (t, a) {\n          if (t) n(t, null);else {\n            var o = e.Path.POLLS_POLLID_OPTIONS_OPTIONID.replace(\"%s\", i).replace(\"%s\", s);\n            r.delete(o, null, n);\n          }\n        });\n      }\n    }, {\n      key: \"getPollOptionVoterList\",\n      value: function value(t, n) {\n        var r = this,\n            i = t.channelUrl,\n            s = t.pollId,\n            a = t.optionId,\n            o = t.token,\n            l = t.limit;\n        this.sb.ConnectionManager.ready(function (t, u) {\n          if (t) n(t, null);else {\n            var c = e.Path.POLLS_POLLID_OPTIONS_OPTIONID_VOTERS.replace(\"%s\", s).replace(\"%s\", a),\n                d = new ae({\n              channel_url: i\n            });\n            o && d.add(\"token\", o), l && d.add(\"limit\", l), r.get(c, d, n);\n          }\n        });\n      }\n    }], [{\n      key: \"Path\",\n      get: function get() {\n        return {\n          USERS: \"/users\",\n          USERS_USERID: \"/users/%s\",\n          USERS_USERID_LOGIN: \"/users/%s/login\",\n          USERS_USERID_SESSION_KEY: \"/users/%s/session_key\",\n          USERS_USERID_METADATA: \"/users/%s/metadata\",\n          USERS_USERID_METADATA_KEY: \"/users/%s/metadata/%s\",\n          USERS_USERID_MARKASREADALL: \"/users/%s/mark_as_read_all\",\n          USERS_USERID_MY_GROUP_CHANNEL_CHANGELOGS: \"/users/%s/my_group_channels/changelogs\",\n          USERS_USERID_UNREAD_ITEM_COUNT: \"/users/%s/unread_item_count\",\n          USERS_USERID_UNREAD_MESSAGE_COUNT: \"/users/%s/unread_message_count\",\n          USERS_USERID_UNREAD_CHANNEL_COUNT: \"/users/%s/unread_channel_count\",\n          USERS_USERID_PUSH_GCM_TOKEN: \"/users/%s/push/gcm/%s\",\n          USERS_USERID_PUSH_GCM: \"/users/%s/push/gcm\",\n          USERS_USERID_PUSH_DEVICE_TOKENS: \"/users/%s/push/%s/device_tokens\",\n          USERS_USERID_PUSHPREFERENCE_CHANNELURL: \"/users/%s/push_preference/%s\",\n          USERS_USERID_PUSHPREFERENCE: \"/users/%s/push_preference/\",\n          USERS_USERID_PUSH_TEMPLATE: \"/users/%s/push/template\",\n          USERS_USERID_BLOCK: \"/users/%s/block\",\n          USERS_USERID_BLOCK_TARGETID: \"/users/%s/block/%s\",\n          USERS_USERID_PUSH_APNS_TOKEN: \"/users/%s/push/apns/%s\",\n          USERS_USERID_PUSH_APNS: \"/users/%s/push/apns\",\n          USERS_USERID_PUSH: \"/users/%s/push\",\n          USERS_USERID_GROUP_CHANNEL_INVITATION_PREFERENCE: \"/users/%s/channel_invitation_preference\",\n          USERS_USERID_GROUP_CHANNEL_COUNT: \"/users/%s/group_channel_count\",\n          USERS_COUNT_PREFERENCE: \"/users/%s/count_preference/%s\",\n          USERS_USERID_ALLOW_FRIEND_DISCOVERY: \"/users/%s/allow_friend_discovery\",\n          OPENCHANNELS: \"/open_channels\",\n          OPENCHANNELS_CHANNELURL: \"/open_channels/%s\",\n          OPENCHANNELS_CHANNELURL_MESSAGES: \"/open_channels/%s/messages\",\n          OPENCHANNELS_CHANNELURL_MESSAGES_MESSAGEID: \"/open_channels/%s/messages/%s\",\n          OPENCHANNELS_CHANNELURL_MESSAGES_MESSAGEID_TRANSLATION: \"/open_channels/%s/messages/%s/translation\",\n          OPENCHANNELS_CHANNELURL_MESSAGES_CHANGELOGS: \"/open_channels/%s/messages/changelogs\",\n          OPENCHANNELS_CHANNELURL_SCHEDULED_MESSAGES: \"/open_channels/%s/scheduled_messages\",\n          OPENCHANNELS_CHANNELURL_PARTICIPANTS: \"/open_channels/%s/participants\",\n          OPENCHANNELS_CHANNELURL_OPERATORS: \"/open_channels/%s/operators\",\n          OPENCHANNELS_CHANNELURL_METADATA: \"/open_channels/%s/metadata\",\n          OPENCHANNELS_CHANNELURL_METADATA_KEY: \"/open_channels/%s/metadata/%s\",\n          OPENCHANNELS_CHANNELURL_METACOUNTER: \"/open_channels/%s/metacounter\",\n          OPENCHANNELS_CHANNELURL_METACOUNTER_KEY: \"/open_channels/%s/metacounter/%s\",\n          OPENCHANNELS_CHANNELURL_BAN: \"/open_channels/%s/ban\",\n          OPENCHANNELS_CHANNELURL_BAN_USERID: \"/open_channels/%s/ban/%s\",\n          OPENCHANNELS_CHANNELURL_MUTE: \"/open_channels/%s/mute\",\n          OPENCHANNELS_CHANNELURL_MUTE_USERID: \"/open_channels/%s/mute/%s\",\n          OPENCHANNELS_CHANNELURL_FREEZE: \"/open_channels/%s/freeze\",\n          OPENCHANNELS_OPERATORS: \"/open_channels/%s/operators\",\n          OPENCHANNELS_CHANNELURL_MESSAGES_MESSAGEID_REACTION: \"/open_channels/%s/messages/%s/reactions\",\n          GROUPCHANNELS: \"/group_channels\",\n          MYGROUPCHANNELS: \"/users/%s/my_group_channels\",\n          GROUPCHANNELS_CHANNELURL: \"/group_channels/%s\",\n          GROUPCHANNELS_CHANNELURL_INVITE: \"/group_channels/%s/invite\",\n          GROUPCHANNELS_CHANNELURL_ACCEPT_INVITATION: \"/group_channels/%s/accept\",\n          GROUPCHANNELS_CHANNELURL_DECLINE_INVITATION: \"/group_channels/%s/decline\",\n          GROUPCHANNELS_CHANNELURL_HIDE: \"/group_channels/%s/hide\",\n          GROUPCHANNELS_CHANNELURL_LEAVE: \"/group_channels/%s/leave\",\n          GROUPCHANNELS_CHANNELURL_JOIN: \"/group_channels/%s/join\",\n          GROUPCHANNELS_CHANNELURL_OPERATORS: \"/group_channels/%s/operators\",\n          GROUPCHANNELS_CHANNELURL_MESSAGES: \"/group_channels/%s/messages\",\n          GROUPCHANNELS_CHANNELURL_MESSAGES_MARKASREAD: \"/group_channels/%s/messages/mark_as_read\",\n          GROUPCHANNELS_CHANNELURL_MESSAGES_MARKASDELIVERED: \"/group_channels/%s/messages/mark_as_delivered\",\n          GROUPCHANNELS_CHANNELURL_MESSAGES_TOTALCOUNT: \"/group_channels/%s/messages/total_count\",\n          GROUPCHANNELS_CHANNELURL_MESSAGES_UNREADCOUNT: \"/group_channels/%s/messages/unread_count\",\n          GROUPCHANNELS_CHANNELURL_MESSAGES_MESSAGEID: \"/group_channels/%s/messages/%s\",\n          GROUPCHANNELS_CHANNELURL_MESSAGES_MESSAGEID_TRANSLATION: \"/group_channels/%s/messages/%s/translation\",\n          GROUPCHANNELS_CHANNELURL_MESSAGES_CHANGELOGS: \"/group_channels/%s/messages/changelogs\",\n          GROUPCHANNELS_CHANNELURL_MESSAGES_GAP: \"/group_channels/%s/messages_gap\",\n          GROUPCHANNELS_CHANNELURL_SCHEDULED_MESSAGES: \"/group_channels/%s/scheduled_messages\",\n          GROUPCHANNELS_CHANNELURL_MEMBERS: \"/group_channels/%s/members\",\n          GROUPCHANNELS_CHANNELURL_METADATA: \"/group_channels/%s/metadata\",\n          GROUPCHANNELS_CHANNELURL_METADATA_KEY: \"/group_channels/%s/metadata/%s\",\n          GROUPCHANNELS_CHANNELURL_METACOUNTER: \"/group_channels/%s/metacounter\",\n          GROUPCHANNELS_CHANNELURL_METACOUNTER_KEY: \"/group_channels/%s/metacounter/%s\",\n          GROUPCHANNELS_RESET_USER_HISTORY: \"/group_channels/%s/reset_user_history\",\n          GROUPCHANNELS_OPERATORS: \"/group_channels/%s/operators\",\n          GROUPCHANNELS_MEMBERS: \"/group_channels/%s/members\",\n          GROUPCHANNELS_CHANNELURL_BAN: \"/group_channels/%s/ban\",\n          GROUPCHANNELS_CHANNELURL_BAN_USERID: \"/group_channels/%s/ban/%s\",\n          GROUPCHANNELS_CHANNELURL_MUTE: \"/group_channels/%s/mute\",\n          GROUPCHANNELS_CHANNELURL_MUTE_USERID: \"/group_channels/%s/mute/%s\",\n          GROUPCHANNELS_CHANNELURL_FREEZE: \"/group_channels/%s/freeze\",\n          GROUPCHANNELS_CHANNELURL_MESSAGES_MESSAGEID_REACTION: \"/group_channels/%s/messages/%s/reactions\",\n          STORAGE_FILE: \"/storage/file\",\n          STORAGE_PROFILE: \"/storage/profile_image\",\n          FRIENDS: \"/users/%s/friends\",\n          FRIENDS_CHANGE_LOGS: \"/users/%s/friends/changelogs\",\n          FRIENDS_DISCOVERIES: \"/users/%s/friend_discoveries\",\n          SEARCH_MESSAGE: \"/search/messages\",\n          REPORT_USERS: \"/report/users/%s\",\n          REPORT_CHANNELS: \"/report/%s/%s\",\n          REPORT_MESSAGES: \"/report/%s/%s/messages/%s\",\n          EMOJIS_EMOJIKEY: \"/emojis/%s\",\n          EMOJI_CATEGORIES: \"/emoji_categories\",\n          EMOJI_CATEGORIES_CATEGORYID: \"/emoji_categories/%s\",\n          POLLS: \"/polls\",\n          POLLS_POLLID: \"/polls/%s\",\n          POLLS_POLLID_VOTE: \"/polls/%s/vote\",\n          POLLS_POLLID_CLOSE: \"/polls/%s/close\",\n          POLLS_POLLID_OPTIONS: \"/polls/%s/options\",\n          POLLS_POLLID_OPTIONS_OPTIONID: \"/polls/%s/options/%s\",\n          POLLS_POLLID_OPTIONS_OPTIONID_VOTERS: \"/polls/%s/options/%s/voters\"\n        };\n      }\n    }]), e;\n  }(),\n      ce = function () {\n    function e(t, n) {\n      c(this, e), this.sb = t, this.ws = null, this.wsHost = null, this.WebSocket = null, this.handler = n || new e.ConnectionHandler(), this.explicitDisconnect = !1, this.lastActiveMillis = 0;\n\n      try {\n        this.WebSocket = \"undefined\" == typeof WebSocket ? a.default : WebSocket;\n      } catch (e) {\n        this.WebSocket = WebSocket;\n      }\n    }\n\n    return h(e, [{\n      key: \"connect\",\n      value: function value(e, t, n) {\n        var r = this;\n        J.debug(\"`WebSocketClient.connect` called.\");\n        var i = U.get(this.sb._iid).container,\n            s = i.pinger,\n            a = i.auth,\n            o = i.extensions,\n            l = i.getUserAgentWithExtensions,\n            u = i.sessionManager,\n            c = ji.getAppVersion();\n        this.wsHost = n;\n\n        try {\n          var d = \"/?p=JS\" + \"&pv=\".concat(encodeURIComponent(T.OS_VERSION)) + \"&sv=\".concat(encodeURIComponent(T.SDK_VERSION)) + \"&ai=\".concat(encodeURIComponent(this.sb.getApplicationId()));\n          if (c && (d += \"&av=\".concat(encodeURIComponent(c))), a.sessionKey ? d += \"&key=\".concat(encodeURIComponent(a.sessionKey)) : d += \"&user_id=\".concat(encodeURIComponent(e), \"&access_token=\").concat(encodeURIComponent(t)), d += \"&active=1\", d += \"&SB-User-Agent=\".concat(encodeURIComponent(l(o))), d += \"&Request-Sent-Timestamp=\".concat(new Date().getTime().toString()), d += \"&include_extra_data=\".concat(encodeURIComponent([\"premium_feature_list\", \"file_upload_size_limit\", \"application_attributes\", \"emoji_hash\"].join(\",\"))), u.handler && (d += \"&expiring_session=1\"), this.sb.Options.includePollDetails && (d += \"&include_poll_details=1\"), d += \"&use_local_cache=1\", this.ws = new this.WebSocket(this.wsHost + d), !this.ws) return this.sb.isReconnectingOnError = !0, void this.handler.onError({\n            message: \"ws does not exist.\"\n          });\n        } catch (e) {\n          return this.sb.isReconnectingOnError = !0, void this.handler.onError(e);\n        }\n\n        try {\n          this.sb.getDebugMode() && \"undefined\" != typeof window && (window.ws = this.ws);\n        } catch (e) {\n          J.debug(\"`window` object does not exist.\");\n        }\n\n        var h = !1;\n        this.ws.onopen = function (e) {\n          J.debug(\"`WebSocket.onopen` called.\"), r.handler.onOpen(e);\n        }, this.ws.onmessage = function (e) {\n          r.active();\n\n          for (var t = e.data.split(\"\\n\"), n = 0; n < t.length; n++) {\n            var i = t[n];\n\n            if (i && \"string\" == typeof i) {\n              try {\n                if (\"PONG\" === i.substring(0, 4)) {\n                  s.pong();\n                  continue;\n                }\n              } catch (e) {\n                J.debug(\"`WebSocket.onmessage` command check error:\", e);\n              }\n\n              r.handler.onMessage(i);\n            }\n          }\n        }, this.ws.onerror = function (e) {\n          J.debug(\"`WebSocket.onerror` called:\", e), s && s.stop(), h = !0, r.sb.isReconnectingOnError = !0, r.handler.onError(e);\n        }, this.ws.onclose = function (e) {\n          J.group(\"`WebSocket.onclose` called.\", [{\n            level: J.supportedLogLevels.DEBUG,\n            messages: [\"e\", e]\n          }, {\n            level: J.supportedLogLevels.DEBUG,\n            messages: [\"explicitDisconnect\", r.explicitDisconnect]\n          }]), s && s.stop(), r.explicitDisconnect ? r.handler.onClose(e) : h || r.handler.onError(e), r.explicitDisconnect = !1;\n        };\n      }\n    }, {\n      key: \"disconnect\",\n      value: function value(e, t) {\n        J.group(\"`WebSocketClient.onclose` called.\", [{\n          level: J.supportedLogLevels.DEBUG,\n          messages: [\"explicit\", e]\n        }]);\n        var n = U.get(this.sb._iid).container.pinger;\n        n && n.stop(), this.explicitDisconnect = !0 === e, this.ws && (this.ws.onopen = function () {}, this.ws.onmessage = function () {}, this.ws.onclose = function () {\n          t && t();\n        }, this.ws.onerror = function () {}, this.ws.close(), this.ws = null), this.explicitDisconnect ? this.handler.onClose() : this.handler.onError(), this.explicitDisconnect = !1;\n      }\n    }, {\n      key: \"send\",\n      value: function value(e, t) {\n        if (1 !== this.ws.readyState) t && t(new H(\"Connection is not valid. Please reconnect.\", H.WEBSOCKET_CONNECTION_CLOSED), null);else {\n          var n = U.get(this.sb._iid).container.pinger;\n          this.ws.send(e.encode()), \"PING\" !== e.command && n.refreshTimer(), t && t(null, null);\n        }\n      }\n    }, {\n      key: \"active\",\n      value: function value() {\n        this.lastActiveMillis = new Date().getTime();\n      }\n    }, {\n      key: \"getConnectionState\",\n      value: function value() {\n        try {\n          return 1 === this.ws.readyState ? this.sb.ConnectionState.OPEN : 0 === this.ws.readyState ? this.sb.ConnectionState.CONNECTING : this.sb.ConnectionState.CLOSED;\n        } catch (e) {\n          return this.sb.ConnectionState.CLOSED;\n        }\n      }\n    }]), e;\n  }();\n\n  ce.ConnectionHandler = function () {\n    return h(function e() {\n      c(this, e), this.onReady = function () {}, this.onOpen = function () {}, this.onClose = function () {}, this.onMessage = function () {}, this.onError = function () {};\n    });\n  }();\n\n  var de,\n      he = {},\n      pe = function () {\n    function e() {\n      this._observers = [];\n    }\n\n    return e.of = function (t) {\n      return he[t] || (he[t] = new e()), he[t];\n    }, e.prototype.invokeConnect = function () {\n      for (var e = 0, t = this._observers; e < t.length; e++) {\n        var n = t[e];\n        n.onConnect && n.onConnect();\n      }\n    }, e.prototype.invokeDisconnect = function () {\n      for (var e = 0, t = this._observers; e < t.length; e++) {\n        var n = t[e];\n        n.onDisconnect && n.onDisconnect();\n      }\n    }, e.prototype.addObserver = function (e) {\n      this._observers.push(e);\n    }, e.prototype.removeObserver = function (e) {\n      var t = this._observers.indexOf(e);\n\n      t > -1 && this._observers.splice(t, 1);\n    }, e;\n  }();\n\n  !function (e) {\n    e[e.EVENT_CHANNEL_CHANGED = 0] = \"EVENT_CHANNEL_CHANGED\", e[e.EVENT_USER_RECEIVED_INVITATION = 1] = \"EVENT_USER_RECEIVED_INVITATION\", e[e.EVENT_USER_DECLINED_INVITATION = 2] = \"EVENT_USER_DECLINED_INVITATION\", e[e.EVENT_USER_JOINED = 3] = \"EVENT_USER_JOINED\", e[e.EVENT_USER_LEFT = 4] = \"EVENT_USER_LEFT\", e[e.EVENT_CHANNEL_ENTER = 5] = \"EVENT_CHANNEL_ENTER\", e[e.EVENT_CHANNEL_EXIT = 6] = \"EVENT_CHANNEL_EXIT\", e[e.EVENT_CHANNEL_FROZEN = 7] = \"EVENT_CHANNEL_FROZEN\", e[e.EVENT_CHANNEL_UNFROZEN = 8] = \"EVENT_CHANNEL_UNFROZEN\", e[e.EVENT_CHANNEL_HIDDEN = 9] = \"EVENT_CHANNEL_HIDDEN\", e[e.EVENT_CHANNEL_UNHIDDEN = 10] = \"EVENT_CHANNEL_UNHIDDEN\", e[e.EVENT_TYPING_STATUS_UPDATED = 11] = \"EVENT_TYPING_STATUS_UPDATED\", e[e.EVENT_OPERATOR_UPDATED = 12] = \"EVENT_OPERATOR_UPDATED\", e[e.EVENT_CHANNEL_METADATA_UPDATED = 13] = \"EVENT_CHANNEL_METADATA_UPDATED\", e[e.EVENT_CHANNEL_METADATA_DELETED = 14] = \"EVENT_CHANNEL_METADATA_DELETED\", e[e.EVENT_CHANNEL_METACOUNTER_UPDATED = 15] = \"EVENT_CHANNEL_METACOUNTER_UPDATED\", e[e.EVENT_CHANNEL_METACOUNTER_DELETED = 16] = \"EVENT_CHANNEL_METACOUNTER_DELETED\", e[e.EVENT_CHANNEL_DELETED = 17] = \"EVENT_CHANNEL_DELETED\", e[e.EVENT_USER_MUTED = 18] = \"EVENT_USER_MUTED\", e[e.EVENT_USER_UNMUTED = 19] = \"EVENT_USER_UNMUTED\", e[e.EVENT_USER_BANNED = 20] = \"EVENT_USER_BANNED\", e[e.EVENT_USER_UNBANNED = 21] = \"EVENT_USER_UNBANNED\", e[e.EVENT_MESSAGE_RECEIVED = 22] = \"EVENT_MESSAGE_RECEIVED\", e[e.EVENT_MESSAGE_SENT = 23] = \"EVENT_MESSAGE_SENT\", e[e.EVENT_MESSAGE_UPDATED = 24] = \"EVENT_MESSAGE_UPDATED\", e[e.EVENT_MESSAGE_DELETED = 25] = \"EVENT_MESSAGE_DELETED\", e[e.EVENT_READ_RECEIPT_UPDATED = 26] = \"EVENT_READ_RECEIPT_UPDATED\", e[e.EVENT_DELIVERY_RECEIPT_UPDATED = 27] = \"EVENT_DELIVERY_RECEIPT_UPDATED\", e[e.EVENT_MENTION = 28] = \"EVENT_MENTION\", e[e.EVENT_REACTION_UPDATED = 29] = \"EVENT_REACTION_UPDATED\", e[e.EVENT_THREAD_INFO_UPDATED = 30] = \"EVENT_THREAD_INFO_UPDATED\", e[e.CHANNEL_BACKGROUND = 1e3] = \"CHANNEL_BACKGROUND\", e[e.CHANNEL_CHANGELOG = 1001] = \"CHANNEL_CHANGELOG\", e[e.MESSAGE_BACKGROUND = 1002] = \"MESSAGE_BACKGROUND\", e[e.MESSAGE_FILL = 1003] = \"MESSAGE_FILL\", e[e.MESSAGE_CHANGELOG = 1004] = \"MESSAGE_CHANGELOG\", e[e.LOCAL_MESSAGE_PENDING_CREATED = 2e3] = \"LOCAL_MESSAGE_PENDING_CREATED\", e[e.LOCAL_MESSAGE_FAILED = 2001] = \"LOCAL_MESSAGE_FAILED\", e[e.LOCAL_MESSAGE_CANCELED = 2002] = \"LOCAL_MESSAGE_CANCELED\", e[e.LOCAL_MESSAGE_RESEND_STARTED = 2003] = \"LOCAL_MESSAGE_RESEND_STARTED\", e[e.MESSAGE_COLLECTION_FILTER_MISMATCH = 2004] = \"MESSAGE_COLLECTION_FILTER_MISMATCH\";\n  }(de || (de = {}));\n\n  var fe,\n      _e = {},\n      ge = function () {\n    function e() {\n      this._observers = [];\n    }\n\n    return e.of = function (t) {\n      return _e[t] || (_e[t] = new e()), _e[t];\n    }, e.prototype.addObserver = function (e) {\n      this._observers.push(e);\n    }, e.prototype.removeObserver = function (e) {\n      var t = this._observers.indexOf(e);\n\n      t >= 0 && this._observers.splice(t, 1);\n    }, e.prototype.send = function (e) {\n      for (var t = 0, n = this._observers; t < n.length; t++) {\n        n[t].onevent(e);\n      }\n    }, e;\n  }(),\n      ye = function () {\n    function e(t) {\n      c(this, e), this.sb = t, this.cls = x.get(this.sb._iid), this.client = new ce(this.sb), this.connectParams = {\n        retryCount: 1\n      }, this.reconnectParams = {\n        interval: 3,\n        retryCount: 3,\n        multiplier: 2,\n        maxInterval: 24\n      }, this.connectCount = 0, this.reconnectCount = 0, this.reconnectDelay = 0;\n    }\n\n    return h(e, [{\n      key: \"isConnected\",\n      get: function get() {\n        return this.client && this.client.getConnectionState() === this.sb.ConnectionState.OPEN;\n      }\n    }, {\n      key: \"connect\",\n      value: function value(e, t) {\n        var n = this,\n            r = U.get(this.sb._iid).container,\n            i = r.auth,\n            s = r.apiClient,\n            a = r.commandHandler;\n        i.sessionToken = t || null;\n        var o = this.cls.GroupChannel,\n            l = null,\n            u = new ce.ConnectionHandler();\n        this.client = new ce(this.sb, u), u.onMessage = function (e) {\n          a.onRawCommandReceived(e);\n        }, this.sb.loginHandler = function (e, t) {\n          if (n.sb.connecting = !1, n.sb.reconnecting = !1, e) n.disconnect({\n            clearSession: !0,\n            err: e\n          }, null);else {\n            clearInterval(n.sb.globalTimer);\n\n            var r = ge.of(n.sb._iid),\n                i = function i() {\n              o.cachedChannels && Object.keys(o.cachedChannels).forEach(function (e) {\n                var t = o.cachedChannels[e];\n                t.invalidateTypingStatus() && (Object.keys(n.sb.channelHandlers).forEach(function (e) {\n                  n.sb.channelHandlers[e].onTypingStatusUpdated(t);\n                }), r.send({\n                  source: de.EVENT_TYPING_STATUS_UPDATED,\n                  payload: {\n                    channel: t\n                  }\n                }));\n              });\n            };\n\n            i(), n.sb.globalTimer = setInterval(function () {\n              return i();\n            }, 1e3), n.flushConnectionCallbacks(null, t), n.sb.ConnectionManager.processAllReadyHandler(null);\n          }\n        }, u.onOpen = function () {\n          n.connectCount = 0, n.sb.loginTimer = setTimeout(function () {\n            n.sb.loginTimer = null, n.sb.onLoginTimerCancel = null, n.flushConnectionCallbacks(new H(\"Connection timeout.\", H.LOGIN_TIMEOUT), null), n.sb.disconnect(null);\n          }, n.sb.Options.websocketResponseTimeout), n.sb.onLoginTimerCancel = function () {\n            n.connectCount = 0, n.flushConnectionCallbacks(new H(\"Connection has been canceled.\", H.REQUEST_FAILED), null);\n          }, n.sb.connecting = !1;\n        }, u.onError = function (r) {\n          if (J.debug(\"Connect: `WebSocketClient.ConnectionHandler.onError` called.\", r), i.sessionKey) n.sb.isReconnectingOnError = !0, n.sb.ConnectionManager.errorAllReadyHandler(), n.reconnect(e, !0), n.sb.connecting = !1;else if (n.connectCount < n.connectParams.retryCount) n.connectCount++, n.client.connect(e, t, l);else {\n            var s = r ? r.message : \"Unknown error occurred.\";\n            n.connectCount = 0, n.flushConnectionCallbacks(new H(\"Websocket connection failed. \".concat(s), H.WEBSOCKET_CONNECTION_FAILED), null), n.sb.connecting = !1;\n          }\n        }, u.onClose = function () {\n          J.debug(\"Connect: `WebSocketClient.ConnectionHandler.onClose` called.\"), n.connectCount = 0, n.sb.connecting = !1;\n        }, s.checkRouting(function (r, i) {\n          if (r) return n.sb.connecting = !1, void n.flushConnectionCallbacks(new H(\"Connection routing failed.\", H.REQUEST_FAILED), null);\n          l = i.wsHost, s.dummyCall(function (e) {\n            e && J.error(\"API dummy call failed:\", e);\n          }), n.client.connect(e, t, l);\n        });\n      }\n    }, {\n      key: \"reconnect\",\n      value: function value(e) {\n        var t = this,\n            n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],\n            r = U.get(this.sb._iid),\n            i = r.container,\n            s = i.auth,\n            a = i.apiClient,\n            o = i.commandHandler,\n            l = i.ackStateMap,\n            u = i.sessionManager,\n            c = this.cls.OpenChannel;\n        if (this.sb.connecting = !1, this.sb.reconnecting = !0, this.sb.reconnectTimer) J.debug(\"Reconnect: still reconnecting.\");else {\n          if (this.reconnectCount += 1, this.reconnectCount <= 1) {\n            if (n) {\n              Object.keys(l).forEach(function (e) {\n                var t = l[e];\n                t && (clearTimeout(t.timer), (0, t.handler)(new H(\"Command received no ack.\", H.ACK_TIMEOUT), null));\n                delete l[e];\n              });\n              var d = pe.of(this.sb._iid);\n              d.invokeDisconnect(), Object.keys(this.sb.connectionHandlers).forEach(function (e) {\n                t.sb.connectionHandlers[e].onReconnectStarted();\n              });\n            }\n\n            this.reconnectDelay = 0;\n          } else this.reconnectDelay = Math.min(1e3 * this.reconnectParams.interval * Math.pow(this.reconnectParams.multiplier, this.reconnectCount - 2), this.reconnectParams.maxInterval > 0 ? 1e3 * this.reconnectParams.maxInterval : Number.MAX_SAFE_INTEGER);\n\n          if (!e || !s.sessionKey || this.reconnectParams.retryCount > 0 && this.reconnectCount > this.reconnectParams.retryCount) return this.disconnect({\n            clearSession: !1,\n            err: new H(\"Websocket connection failed with a number of retries.\", H.WEBSOCKET_CONNECTION_FAILED)\n          }, null), this.reconnectCount = 0, Object.keys(this.sb.connectionHandlers).forEach(function (e) {\n            t.sb.connectionHandlers[e].onReconnectFailed();\n          }), this.sb.connecting = !1, this.sb.reconnecting = !1, this.sb.isReconnectingOnError = !1, void this.sb.ConnectionManager.errorAllReadyHandler();\n          this.sb.onReconnectTimerCancel = function () {\n            t.reconnectCount = 0;\n          }, this.sb.reconnectTimer = setTimeout(function () {\n            t.sb.reconnectTimer = null, t.sb.onReconnectTimerCancel = null, t.client && t.client.disconnect(!0);\n            var n = new ce.ConnectionHandler();\n            t.client = new ce(t.sb, n), t.sb.loginHandler = function (n, r) {\n              n ? u.isSessionError(n) ? u.refreshSessionIfExpiredError(n).then(function () {\n                clearTimeout(t.sb.reconnectTimer), t.sb.reconnectTimer = null, t.reconnectCount = 0, t.reconnect(e, !1);\n              }).catch(function () {}) : (clearTimeout(t.sb.reconnectTimer), t.sb.reconnectTimer = null, t.reconnect(e, !1)) : (t.reconnectCount = 0, t.sb.connecting = !1, t.sb.reconnecting = !1, t.sb.isReconnectingOnError = !1, pe.of(t.sb._iid).invokeConnect(), Object.keys(t.sb.connectionHandlers).forEach(function (e) {\n                t.sb.connectionHandlers[e].onReconnectSucceeded();\n              }), t.sb.ConnectionManager.processAllReadyHandler(null), t.sb.isReconnectingOnError && Object.keys(t.sb.ConnectionManager.networkHandlers).forEach(function (e) {\n                t.sb.ConnectionManager.networkHandlers[e].onReconnected();\n              }), Object.keys(c.enteredChannels).forEach(function (e) {\n                c.enteredChannels[e].enter(function (n, r) {\n                  if (n) {\n                    var i = t.cls.FileMessageQueue;\n                    delete c.enteredChannels[e], i.delete(e);\n                  }\n                });\n              }));\n            }, n.onOpen = function () {\n              J.debug(\"Reconnect: `WebSocketClient.ConnectionHandler.onOpen` called.\"), t.sb.loginTimer = setTimeout(function () {\n                J.debug(\"Reconnect: `loginTimer` timeout.\"), t.sb.loginTimer = null, t.reconnect(e, !0);\n              }, t.sb.Options.websocketResponseTimeout), t.sb.onLoginTimerCancel = null;\n            }, n.onMessage = function (e) {\n              o.onRawCommandReceived(e);\n            }, n.onError = function (n) {\n              J.debug(\"Reconnect: `WebSocketClient.ConnectionHandler.onError` called.\", n), t.sb.isReconnectingOnError = !0, t.sb.ConnectionManager.errorAllReadyHandler(), t.reconnect(e, !0);\n            }, n.onClose = function () {\n              J.debug(\"Reconnect: `WebSocketClient.ConnectionHandler.onClose` called.\"), t.sb.reconnecting = !1;\n            }, a.checkRouting(function (n, r) {\n              n ? t.reconnect(e, !0) : (t.sb.getCurrentApiHost() !== r.apiHost && a.get(\"/\", null, function () {}), t.client.connect(e, null, r.wsHost));\n            });\n          }, this.reconnectDelay);\n        }\n      }\n    }, {\n      key: \"disconnect\",\n      value: function value(e, t) {\n        var n = U.get(this.sb._iid),\n            r = n.container.ackStateMap,\n            i = this.cls,\n            s = i.GroupChannel,\n            a = i.OpenChannel,\n            o = e.clearSession,\n            l = e.err;\n        this.sb.loginTimer && (clearTimeout(this.sb.loginTimer), this.sb.onLoginTimerCancel && (this.sb.onLoginTimerCancel(), this.sb.onLoginTimerCancel = null), this.sb.loginTimer = null), this.sb.reconnectTimer && (clearTimeout(this.sb.reconnectTimer), this.sb.onReconnectTimerCancel && (this.sb.onReconnectTimerCancel(), this.sb.onReconnectTimerCancel = null), this.sb.reconnectTimer = null), this.client && (this.reconnectCount = 0, this.client.disconnect(!0), this.client = null), o && (a.clearEnteredChannels(), a.clearCache(), s.clearCache(), this.sb.globalTimer && (clearInterval(this.sb.globalTimer), this.sb.globalTimer = null), Object.keys(r).forEach(function (e) {\n          clearTimeout(r[e].timer);\n        }), this.sb.currentUser = null, n.set(\"ackStateMap\", {}), n.set(\"subscribedUnreadMessageCount\", {\n          all: 0,\n          custom_types: {},\n          ts: 0\n        }), n.set(\"auth\", new F())), l && (this.flushConnectionCallbacks(l, null), this.sb.connecting = !1, this.sb.reconnecting = !1, this.sb.isReconnectingOnError = !1), t && t(null, null);\n      }\n    }, {\n      key: \"flushConnectionCallbacks\",\n      value: function value(e, t) {\n        var n = this,\n            r = U.get(this.sb._iid).container,\n            i = r.store,\n            s = r.localCacheEnabled,\n            a = this.sb.connectionCallbacks;\n        if (this.sb.connectionCallbacks = [], e) {\n          if (s) {\n            var o = this.sb._getCurrentUserDataKey();\n\n            se.isNonAutoReconnectableError(e.code) ? i.remove(o).catch(function (e) {\n              return J.debug(\"Sendbird connect store remove error: \", e);\n            }).finally(function () {\n              return a.forEach(function (t) {\n                return t(e, null);\n              });\n            }) : i.get(o).then(function (e) {\n              n.sb._populateVaultFromCurrentUserData(e);\n            }).catch(function (e) {\n              J.debug(\"Sendbird connect store fetch error: \", e);\n            }).finally(function () {\n              n.sb.currentUser ? a.forEach(function (t) {\n                return t(e, n.sb.currentUser);\n              }) : a.forEach(function (t) {\n                return t(e, null);\n              });\n            });\n          } else a.forEach(function (t) {\n            return t(e, null);\n          });\n        } else pe.of(this.sb._iid).invokeConnect(), s ? i.set({\n          key: this.sb._getCurrentUserDataKey(),\n          value: this._createCurrentUserData(t),\n          generation: 1\n        }).catch(function (e) {\n          return J.debug(\"Sendbird connect store write error: \", e);\n        }).finally(function () {\n          return a.forEach(function (e) {\n            return e(null, n.sb.currentUser);\n          });\n        }) : a.forEach(function (e) {\n          return e(null, t);\n        });\n      }\n    }, {\n      key: \"_createCurrentUserData\",\n      value: function value(e) {\n        var t = U.get(this.sb._iid).container,\n            n = t.auth,\n            r = t.maxUnreadCountOfSuperGroupChannel,\n            i = t.profileImageEncryption,\n            s = t.appInfo,\n            a = t.connectedAt,\n            o = t.firstConnectedAt,\n            l = t.concurrentCallLimit,\n            u = t.backOffDelay,\n            c = {\n          currentUser: (e || this.sb.currentUser).serialize(),\n          maxUnreadCountOfSuperGroupChannel: T.DEFAULT_MAX_UNREAD_COUNT_OF_SUPER_GROUP_CHANNEL,\n          profileImageEncryption: !1\n        };\n        return n.sessionKey && (c.sessionKey = n.sessionKey), n.eKey && (c.eKey = n.eKey), r && (c.maxUnreadCountOfSuperGroupChannel = r), i && (c.profileImageEncryption = i), s && (c.appInfo = s._objectify()), a && o && (c.connectedAt = a, c.firstConnectedAt = o), l && u && (c.concurrentCallLimit = l, c.backOffDelay = u), c;\n      }\n    }]), e;\n  }(),\n      me = function () {\n    function e(t) {\n      var n = t.type,\n          r = t.nullable,\n          i = void 0 !== r && r,\n          s = t.optional,\n          a = void 0 !== s && s,\n          o = t.optionalIf,\n          l = void 0 === o ? null : o,\n          u = t.ignoreIf,\n          d = void 0 === u ? null : u,\n          h = t.defaultValue,\n          p = void 0 === h ? null : h,\n          f = t.constraint,\n          _ = void 0 === f ? null : f;\n\n      c(this, e), this.type = n, this.nullable = i, this.optional = a, this.optionalIf = l, this.ignoreIf = d, this.defaultValue = p, this.constraint = _;\n    }\n\n    return h(e, [{\n      key: \"isMatchingType\",\n      value: function value(e) {\n        var t = function t(_t2, n) {\n          return \"string\" == typeof n ? u(_t2) === n || \"array\" === n && Array.isArray(_t2) || \"file\" === n && se.isFile(_t2) || \"null\" === n && null === _t2 || \"date\" === n && _t2 instanceof Date : \"function\" == typeof n ? _t2 instanceof n : \"object\" === u(n) && Object.keys(n).map(function (e) {\n            return n[e];\n          }).indexOf(e) > -1;\n        };\n\n        return t(e, this.type) || Array.isArray(this.type) && this.type.some(function (n) {\n          return t(e, n);\n        }) || this.nullable && null === e;\n      }\n    }], [{\n      key: \"parse\",\n      value: function value(t, n) {\n        for (t = e.toArray(t); t.length > 0 && void 0 === t[t.length - 1];) {\n          t.pop();\n        }\n\n        var r = !1,\n            i = null;\n        \"callback\" === n[n.length - 1].type && (\"function\" == typeof t[t.length - 1] && (i = t.pop()), n.pop(), r = !0);\n        var s = [],\n            a = null,\n            o = 0;\n        return n.forEach(function (n) {\n          \"function\" == typeof n.ignoreIf && n.ignoreIf(t) ? s.push(n.hasOwnProperty(\"defaultValue\") ? n.defaultValue : null) : n.isMatchingType(t[o]) ? (n.nullable && null === t[o] || !n.constraint || n.constraint(t[o]) || (a = e.error), s.push(t[o]), o++) : n.optional || \"function\" == typeof n.optionalIf && n.optionalIf(t) ? s.push(n.hasOwnProperty(\"defaultValue\") ? n.defaultValue : null) : (a = e.error, s.push(t[o]), o++);\n        }), r && i && s.push(i), t.length !== o && (a = e.error), [a].concat(s);\n      }\n    }, {\n      key: \"error\",\n      get: function get() {\n        return new H(\"Invalid parameter.\", H.INVALID_PARAMETER);\n      }\n    }, {\n      key: \"toArray\",\n      value: function value(e) {\n        for (var t = [], n = 0; n < e.length; n++) {\n          t.push(e[n]);\n        }\n\n        return t;\n      }\n    }]), e;\n  }(),\n      Ee = function () {\n    function e(t) {\n      c(this, e), this.sb = t, this.authCount = 0, this.readyHandlers = [], this.networkHandlers = {}, this.authenticateTimer = 1e4, this.authInfoRequester = null;\n    }\n\n    return h(e, [{\n      key: \"addReadyHandler\",\n      value: function value(e) {\n        e && \"function\" == typeof e && this.readyHandlers.push(e);\n      }\n    }, {\n      key: \"ready\",\n      value: function value(e) {\n        var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],\n            n = U.get(this.sb._iid),\n            r = n.container,\n            i = r.auth,\n            s = r.isInBackground;\n        t && i.hasSession() ? e && (this.sb.currentUser ? e(null, this.sb.currentUser) : (this.addReadyHandler(e), this.errorAllReadyHandler()), this.sb.getConnectionState() !== this.sb.ConnectionState.CLOSED || s || this.sb.reconnect()) : (this.addReadyHandler(e), this.sb.isReconnectingOnError ? this.errorAllReadyHandler() : this.sb.getConnectionState() === this.sb.ConnectionState.OPEN ? this.processAllReadyHandler(null) : this.sb.getConnectionState() === this.sb.ConnectionState.CONNECTING || this.errorAllReadyHandler());\n      }\n    }, {\n      key: \"processAllReadyHandler\",\n      value: function value(e) {\n        if (this.readyHandlers.length > 0) {\n          var t = this.sb.currentUser,\n              n = this.readyHandlers;\n          this.readyHandlers = [], n.forEach(function (n) {\n            n && \"function\" == typeof n && n(e, t);\n          });\n        }\n      }\n    }, {\n      key: \"errorAllReadyHandler\",\n      value: function value() {\n        var e = U.get(this.sb._iid).container.auth;\n        this.processAllReadyHandler(e && e.hasSession() ? new H(\"WebSocket connection must be made first.\", H.WEBSOCKET_CONNECTION_CLOSED) : new H(\"Connection should be made first.\", H.CONNECTION_REQUIRED));\n      }\n    }, {\n      key: \"NetworkHandler\",\n      value: function value() {\n        this.onReconnected = function () {};\n      }\n    }, {\n      key: \"addNetworkHandler\",\n      value: function value(e, t) {\n        J.warn(\"`ConnectionManager` will be deprecated.\"), this.networkHandlers[e] = t;\n      }\n    }, {\n      key: \"removeNetworkHandler\",\n      value: function value(e) {\n        J.warn(\"`ConnectionManager` will be deprecated.\"), delete this.networkHandlers[e];\n      }\n    }, {\n      key: \"removeAllNetworkHandler\",\n      value: function value() {\n        J.warn(\"`ConnectionManager` will be deprecated.\"), this.networkHandlers = {};\n      }\n    }, {\n      key: \"authenticate\",\n      value: function value(e) {\n        var t = this;\n        if (J.warn(\"`ConnectionManager` will be deprecated.\"), this.sb.getConnectionState() === this.sb.ConnectionState.OPEN || this.sb.reconnecting) this.sb.connecting = !1, e(null, this.sb.currentUser);else if (this.authInfoRequester && \"function\" == typeof this.authInfoRequester) {\n          this.sb.connecting = !0, this.authCount++;\n          var n = setTimeout(function () {\n            n = null, t.authCount--, 0 === t.authCount && 0 === t.sb.connectionCallbacks.length && (t.sb.connecting = !1), t.errorAllReadyHandler(), e(new H(\"Connection should be made first.\", H.CONNECTION_REQUIRED), null);\n          }, this.authenticateTimer);\n          this.authInfoRequester(function (r) {\n            if (n) {\n              clearTimeout(n), n = null, t.authCount--;\n\n              var i = function i(n, r) {\n                t.sb.connecting = !1, e(n, null);\n              };\n\n              r && r.hasOwnProperty(\"userId\") ? r.accessToken ? r.apiHost && r.wsHost ? t.sb.connect(r.userId, r.accessToken, r.apiHost, r.wsHost, i) : t.sb.connect(r.userId, r.accessToken, i) : r.apiHost && r.wsHost ? t.sb.connect(r.userId, r.apiHost, r.wsHost, i) : t.sb.connect(r.userId, i) : e(me.error, null);\n            }\n          });\n        } else e(me.error, null);\n      }\n    }]), e;\n  }(),\n      ve = function ve() {\n    this.onSessionExpired = function () {}, this.onSessionTokenRequired = function (e, t) {\n      return e(null);\n    }, this.onSessionError = function (e) {}, this.onSessionRefreshed = function () {}, this.onSessionClosed = function () {};\n  },\n      be = function () {\n    function e() {\n      c(this, e), this.handler = null, this.resolvers = [];\n    }\n\n    return h(e, [{\n      key: \"_refreshSessionToken\",\n      value: function value() {\n        var t = this;\n        return new Promise(function (n, r) {\n          var i = null,\n              s = function s() {\n            i && (clearTimeout(i), i = null);\n          },\n              a = function a() {\n            i && (s(), r(e.sessionTokenRequestFailedError));\n          };\n\n          i = setTimeout(function () {\n            return a();\n          }, 3e4), t.handler.onSessionTokenRequired(function (e) {\n            i && (s(), n(e));\n          }, a);\n        });\n      }\n    }, {\n      key: \"_refreshSessionKey\",\n      value: function value() {\n        var t = this;\n        return new Promise(function (n, r) {\n          var i = U.get(t._iid).container,\n              s = i.auth,\n              a = i.wsAdapter;\n          s.sessionToken ? a.isConnected ? t._refreshSessionKeyByCommand().then(function () {\n            return n();\n          }).catch(function (e) {\n            e.isSessionTokenExpiredError ? r(e) : t._refreshSessionKeyByApi().then(function () {\n              return n();\n            }).catch(function (e) {\n              return r(e);\n            });\n          }) : t._refreshSessionKeyByApi().then(function () {\n            return n();\n          }).catch(function (e) {\n            return r(e);\n          }) : r(e.sessionTokenNotFoundError);\n        });\n      }\n    }, {\n      key: \"_refreshSessionKeyByCommand\",\n      value: function value() {\n        var t = this;\n        return new Promise(function (n, r) {\n          var i = ji.getInstance(t._iid),\n              s = U.get(t._iid).container.auth,\n              a = x.get(t._iid).Command,\n              o = a.bSessionRefresh({\n            token: s.sessionToken,\n            requestId: a.generateRequestId()\n          });\n          i.sendCommand(o, function (t, a) {\n            if (!i.getErrorFirstCallback()) {\n              var o = [t, a];\n              a = o[0], t = o[1];\n            }\n\n            t ? r(t) : a ? a.hasOwnProperty(\"error\") ? r(e.sessionKeyRefreshFailedError) : (a.hasOwnProperty(\"new_key\") && (s.sessionKey = a.new_key), n()) : r(e.sessionKeyRefreshFailedError);\n          });\n        });\n      }\n    }, {\n      key: \"_refreshSessionKeyByApi\",\n      value: function value() {\n        var t = this;\n        return new Promise(function (n, r) {\n          !function i(s) {\n            if (s < 3) {\n              var a = U.get(t._iid).container,\n                  o = a.auth,\n                  l = a.apiClient,\n                  u = {};\n              o.sessionToken && (u.accessToken = o.sessionToken), l.refreshSessionKey(u, function (e, t) {\n                if (e) e.isSessionTokenExpiredError || e.isSessionTokenRevokedError ? r(e) : i(s + 1);else {\n                  var a = t.key;\n                  o.sessionKey = a, n();\n                }\n              });\n            } else r(e.sessionKeyRefreshFailedError);\n          }(0);\n        });\n      }\n    }, {\n      key: \"_handleSessionToken\",\n      value: function value(t) {\n        var n = this;\n        t ? (U.get(this._iid).container.auth.sessionToken = t, this._refreshSessionKey().then(function () {\n          return n._handleSessionRefreshSuccess();\n        }).catch(function () {\n          return n._handleSessionRefreshError(e.sessionTokenRequestFailedError);\n        })) : this._handleSessionClosed(e.sessionTokenRequestFailedError);\n      }\n    }, {\n      key: \"_handleSessionRefreshSuccess\",\n      value: function value() {\n        this.handler.onSessionRefreshed(), this._flushResolvers(null);\n      }\n    }, {\n      key: \"_handleSessionRefreshError\",\n      value: function value(e) {\n        this._cancelConnection(), this.handler.onSessionError(e), this._flushResolvers(e);\n      }\n    }, {\n      key: \"_handleSessionClosed\",\n      value: function value(e) {\n        this._cancelConnection(), this.handler.onSessionClosed(), this._flushResolvers(e);\n      }\n    }, {\n      key: \"_cancelConnection\",\n      value: function value() {\n        var e = ji.getInstance(this._iid);\n        e.reconnecting && (Object.keys(e.connectionHandlers).forEach(function (t) {\n          e.connectionHandlers[t].onReconnectFailed();\n        }), e.reconnecting = !1), e.disconnect();\n      }\n    }, {\n      key: \"_flushResolvers\",\n      value: function value(e) {\n        for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = 0; n < this.resolvers.length; n++) {\n          e ? this.resolvers[n].reject(e) : this.resolvers[n].resolve(t);\n        }\n\n        this.resolvers = [];\n      }\n    }, {\n      key: \"setHandler\",\n      value: function value(e) {\n        e instanceof ve && (this.handler = e);\n      }\n    }, {\n      key: \"isSessionError\",\n      value: function value(e) {\n        return e.isSessionTokenExpiredError || e.isSessionTokenRevokedError || e.isSessionKeyExpiredError;\n      }\n    }, {\n      key: \"refreshSessionToken\",\n      value: function value() {\n        var t = this;\n        return new Promise(function (n, r) {\n          t.handler ? (t.resolvers.push({\n            resolve: n,\n            reject: r\n          }), 1 === t.resolvers.length && t._refreshSessionToken().then(function (e) {\n            return t._handleSessionToken(e);\n          }).catch(function () {\n            return t._handleSessionRefreshError(e.sessionTokenRequestFailedError);\n          })) : n();\n        });\n      }\n    }, {\n      key: \"refreshSessionKey\",\n      value: function value() {\n        var e = this;\n        return new Promise(function (t, n) {\n          e.handler ? (e.resolvers.push({\n            resolve: t,\n            reject: n\n          }), 1 === e.resolvers.length && e._refreshSessionKey().then(function () {\n            return e._handleSessionRefreshSuccess();\n          }).catch(function (t) {\n            t.isSessionTokenExpiredError ? e._refreshSessionToken().then(function (t) {\n              return e._handleSessionToken(t);\n            }).catch(function (t) {\n              return e._handleSessionRefreshError(t);\n            }) : t.isSessionTokenRevokedError ? e._handleSessionClosed(t) : e._handleSessionRefreshError(t);\n          })) : t();\n        });\n      }\n    }, {\n      key: \"refreshSessionIfExpiredError\",\n      value: function value(e) {\n        var t = this;\n        return e.isSessionTokenExpiredError ? this.refreshSessionToken() : e.isSessionKeyExpiredError ? this.refreshSessionKey() : e.isSessionTokenRevokedError ? new Promise(function (e, n) {\n          return n(t.closeSession());\n        }) : Promise.reject(e);\n      }\n    }, {\n      key: \"closeSession\",\n      value: function value() {\n        var t = e.sessionTokenRequestFailedError;\n        return this._handleSessionClosed(t), t;\n      }\n    }], [{\n      key: \"sessionTokenNotFoundError\",\n      get: function get() {\n        return new H(\"Session token is not found.\", H.SESSION_TOKEN_EXPIRED);\n      }\n    }, {\n      key: \"sessionTokenExpiredError\",\n      get: function get() {\n        return new H(\"Session token is expired.\", H.SESSION_TOKEN_EXPIRED);\n      }\n    }, {\n      key: \"sessionKeyRefreshFailedError\",\n      get: function get() {\n        return new H(\"Failed to refresh the session key.\", H.SESSION_KEY_REFRESH_FAILED);\n      }\n    }, {\n      key: \"sessionTokenRequestFailedError\",\n      get: function get() {\n        return new H(\"Failed to get the session token.\", H.SESSION_TOKEN_REQUEST_FAILED);\n      }\n    }]), e;\n  }(),\n      Ce = function () {\n    function e(e) {\n      var t = this;\n      this.sb = e, this.unsubscribes = [], this.isOnline = !1, this.onlineWorker = function () {\n        t.isOnline = !0;\n        var e = U.get(t.sb._iid).container.auth;\n        t.sb.reconnecting || t.sb.connecting || !e.sessionKey || t.sb.getConnectionState() === t.sb.ConnectionState.OPEN || t.sb.reconnect();\n      }, this.offlineWorker = function () {\n        t.isOnline = !1, t.sb.setIsProcessingAutoResend(!1);\n        var e = U.get(t.sb._iid).container,\n            n = e.auth,\n            r = e.pinger;\n        t.sb.reconnecting || t.sb.connecting || !n.sessionKey || (r && r.stop(), t.sb.reconnect());\n      }, this.onlineListener = function (e) {\n        try {\n          if (\"undefined\" != typeof window && window.addEventListener && \"ononline\" in window && \"onoffline\" in window && \"undefined\" != typeof navigator && \"boolean\" == typeof navigator.onLine) return window.addEventListener(\"online\", e), function () {\n            return window.removeEventListener(\"online\", e, !1);\n          };\n        } catch (e) {\n          J.debug(\"There is no `window.addEventListener.ononline` or `navigator.onLine`\");\n        }\n\n        return function () {};\n      }, this.offlineListener = function (e) {\n        try {\n          if (\"undefined\" != typeof window && window.addEventListener && \"ononline\" in window && \"onoffline\" in window && \"undefined\" != typeof navigator && \"boolean\" == typeof navigator.onLine) return window.addEventListener(\"offline\", e), function () {\n            return window.removeEventListener(\"offline\", e, !1);\n          };\n        } catch (e) {\n          J.debug(\"There is no `window.addEventListener.ononline` or `navigator.onLine`\");\n        }\n\n        return function () {};\n      }, this.setOnlineListener = function (e) {\n        Boolean(e) && \"function\" == typeof e && (t.onlineListener = e);\n      }, this.setOfflineListener = function (e) {\n        Boolean(e) && \"function\" == typeof e && (t.offlineListener = e);\n      }, this.sb = e, \"undefined\" != typeof window && \"undefined\" != typeof navigator && \"boolean\" == typeof navigator.onLine && (this.isOnline = window.navigator.onLine);\n    }\n\n    return e.prototype.start = function () {\n      this.unsubscribes = [this.onlineListener(this.onlineWorker), this.offlineListener(this.offlineWorker)];\n    }, e.prototype.stop = function () {\n      this.unsubscribes.forEach(function (e) {\n        try {\n          null == e || e();\n        } catch (e) {}\n      });\n    }, e;\n  }(),\n      Ae = new Date().getTime(),\n      Ne = function () {\n    function e(t, n) {\n      var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;\n\n      switch (c(this, e), this.command = t, this.requestId = r, arguments.length) {\n        case 1:\n          if (!t || t.length <= 4) this.command = \"NOOP\", this.payload = \"{}\";else if (this.decode(t), this.isRequestIdCommand) {\n            var i = this.getJsonElement();\n            i && (this.requestId = i.req_id || \"\");\n          }\n          break;\n\n        case 2:\n        case 3:\n          !this.requestId && this.isRequestIdCommand && (this.requestId = e.generateRequestId()), n.req_id = this.requestId || \"\", this.payload = JSON.stringify(n);\n      }\n    }\n\n    return h(e, [{\n      key: \"isRequestIdCommand\",\n      get: function get() {\n        return this.isAckRequired || \"EROR\" === this.command;\n      }\n    }, {\n      key: \"isAckRequired\",\n      get: function get() {\n        return \"LOGI\" === this.command || \"MESG\" === this.command || \"FILE\" === this.command || \"ENTR\" === this.command || \"EXIT\" === this.command || \"READ\" === this.command || \"MEDI\" === this.command || \"FEDI\" === this.command;\n      }\n    }, {\n      key: \"encode\",\n      value: function value() {\n        return this.command + this.payload + \"\\n\";\n      }\n    }, {\n      key: \"decode\",\n      value: function value(e) {\n        e = e.trim(), this.command = e.substring(0, 4), this.payload = e.substring(4);\n      }\n    }, {\n      key: \"getJsonElement\",\n      value: function value() {\n        return JSON.parse(this.payload);\n      }\n    }], [{\n      key: \"bSessionRefresh\",\n      value: function value(e) {\n        return new this(\"LOGI\", {\n          token: e.token,\n          expiring_session: 1\n        }, e.requestId);\n      }\n    }, {\n      key: \"bPing\",\n      value: function value() {\n        return new this(\"PING\", {\n          id: new Date().getTime(),\n          active: 1\n        });\n      }\n    }, {\n      key: \"bMessage\",\n      value: function value(e) {\n        var t = e.channelUrl,\n            n = e.message,\n            r = e.data,\n            i = e.customType,\n            s = e.metaArrays,\n            a = e.mentionType,\n            o = e.mentionedUserIds,\n            l = e.mentionedMessageTemplate,\n            u = e.translationTargetLanguages,\n            c = e.pushNotificationDeliveryOption,\n            d = e.appleCriticalAlertOptions,\n            h = e.requestId,\n            p = void 0 === h ? null : h,\n            f = e.silent,\n            _ = void 0 !== f && f,\n            g = e.rootMessageId,\n            y = void 0 === g ? null : g,\n            m = e.parentMessageId,\n            E = void 0 === m ? null : m,\n            v = e.pollId,\n            b = e.isReplyToChannel,\n            C = void 0 !== b && b,\n            A = x.get(this._iid),\n            N = A.UserMessageParams,\n            S = A.BaseMessageParams,\n            I = {};\n\n        return I.channel_url = t, I.message = n, I.data = r, s && s.length > 0 && (I.metaarray = s.map(function (e) {\n          return e.encode();\n        })), a && (I.mention_type = a), I.mentioned_user_ids = [], a === S.MentionType.CHANNEL ? I.mentioned_user_ids = [] : Array.isArray(o) && o.length > 0 && (I.mentioned_user_ids = o), l && (I.mentioned_message_template = l), i && (I.custom_type = i), u && u.length > 0 && (I.target_langs = u), c && c !== N.PushNotificationDeliveryOption.DEFAULT && (I.push_option = c), d && (I.apple_critical_alert_options = d.serialize()), _ && (I.silent = _), y && (I.root_message_id = y), E && (I.parent_message_id = E), \"number\" == typeof v ? I.poll_id = v : null === v && (I.poll_id = -1), C && (I.reply_to_channel = C), new this(\"MESG\", I, p);\n      }\n    }, {\n      key: \"bFile\",\n      value: function value(e) {\n        var t = e.channelUrl,\n            n = e.url,\n            r = e.name,\n            i = e.type,\n            s = e.size,\n            a = e.data,\n            o = e.customType,\n            l = e.thumbnailSizes,\n            u = e.requireAuth,\n            c = e.metaArrays,\n            d = e.mentionType,\n            h = e.mentionedUserIds,\n            p = e.pushNotificationDeliveryOption,\n            f = e.appleCriticalAlertOptions,\n            _ = e.requestId,\n            g = void 0 === _ ? null : _,\n            y = e.silent,\n            m = void 0 !== y && y,\n            E = e.rootMessageId,\n            v = void 0 === E ? null : E,\n            b = e.parentMessageId,\n            C = void 0 === b ? null : b,\n            A = e.isReplyToChannel,\n            N = void 0 !== A && A,\n            S = x.get(this._iid),\n            I = S.BaseMessageParams,\n            T = S.FileMessageParams,\n            O = {};\n        return O.channel_url = t, O.url = n, O.name = r || \"\", O.type = i || \"\", O.size = s || 0, O.custom = a, o && (O.custom_type = o), l && (O.thumbnails = l), u && (O.require_auth = u), c && c.length > 0 && (O.metaarray = c.map(function (e) {\n          return e.encode();\n        })), d && (O.mention_type = d), O.mentioned_user_ids = [], d === I.MentionType.CHANNEL ? O.mentioned_user_ids = [] : Array.isArray(h) && h.length > 0 && (O.mentioned_user_ids = h), p && p !== T.PushNotificationDeliveryOption.DEFAULT && (O.push_option = p), f && (O.apple_critical_alert_options = f.serialize()), m && (O.silent = m), v && (O.root_message_id = v), C && (O.parent_message_id = C), N && (O.reply_to_channel = N), new this(\"FILE\", O, g);\n      }\n    }, {\n      key: \"bUpdateUserMessage\",\n      value: function value(e) {\n        var t = e.channelUrl,\n            n = e.messageId,\n            r = e.appleCriticalAlertOptions,\n            i = e.message,\n            s = void 0 === i ? null : i,\n            a = e.data,\n            o = void 0 === a ? null : a,\n            l = e.customType,\n            u = void 0 === l ? null : l,\n            c = e.mentionType,\n            d = void 0 === c ? null : c,\n            h = e.mentionedUserIds,\n            p = void 0 === h ? null : h,\n            f = e.mentionedMessageTemplate,\n            _ = void 0 === f ? null : f,\n            g = e.metaArrayParams,\n            y = void 0 === g ? null : g,\n            m = e.pollId,\n            E = x.get(this._iid).BaseMessageParams,\n            v = {};\n\n        return v.channel_url = t, v.msg_id = n, null != s && void 0 !== s && (v.message = s), null != o && void 0 !== o && (v.data = o), null != u && void 0 !== u && (v.custom_type = u), d && (v.mention_type = d), d === E.MentionType.CHANNEL ? v.mentioned_user_ids = [] : Array.isArray(p) && p.length >= 0 && (v.mentioned_user_ids = p), _ && (v.mentioned_message_template = _), y && (v.metaarray = y), r && (v.apple_critical_alert_options = r.serialize()), \"number\" == typeof m ? v.poll_id = m : null === m && (v.poll_id = -1), new this(\"MEDI\", v);\n      }\n    }, {\n      key: \"bUpdateFileMessage\",\n      value: function value(e) {\n        var t = e.channelUrl,\n            n = e.messageId,\n            r = e.appleCriticalAlertOptions,\n            i = e.data,\n            s = void 0 === i ? null : i,\n            a = e.customType,\n            o = void 0 === a ? null : a,\n            l = e.mentionType,\n            u = void 0 === l ? null : l,\n            c = e.mentionedUserIds,\n            d = void 0 === c ? null : c,\n            h = e.metaArrayParams,\n            p = void 0 === h ? null : h,\n            f = x.get(this._iid).BaseMessageParams,\n            _ = {};\n        return _.channel_url = t, _.msg_id = n, null != s && void 0 !== s && (_.data = s), null != o && void 0 !== o && (_.custom_type = o), u && (_.mention_type = u), u === f.MentionType.CHANNEL ? _.mentioned_user_ids = [] : Array.isArray(d) && d.length >= 0 && (_.mentioned_user_ids = d), p && (_.metaarray = p), r && (_.apple_critical_alert_options = r.serialize()), new this(\"FEDI\", _);\n      }\n    }, {\n      key: \"bRead\",\n      value: function value(e) {\n        var t = e.channelUrl,\n            n = {};\n        return n.channel_url = t, new this(\"READ\", n);\n      }\n    }, {\n      key: \"bMessageAck\",\n      value: function value(e) {\n        var t = e.channelUrl,\n            n = e.messageId,\n            r = {};\n        return r.channel_url = t, r.msg_id = n, new this(\"MACK\", r);\n      }\n    }, {\n      key: \"bTypeStart\",\n      value: function value(e) {\n        var t = e.channelUrl,\n            n = e.time,\n            r = {};\n        return r.channel_url = t, r.time = n, new this(\"TPST\", r);\n      }\n    }, {\n      key: \"bTypeEnd\",\n      value: function value(e) {\n        var t = e.channelUrl,\n            n = e.time,\n            r = {};\n        return r.channel_url = t, r.time = n, new this(\"TPEN\", r);\n      }\n    }, {\n      key: \"bEnter\",\n      value: function value(e) {\n        var t = e.channelUrl,\n            n = {};\n        return n.channel_url = t, new this(\"ENTR\", n);\n      }\n    }, {\n      key: \"bExit\",\n      value: function value(e) {\n        var t = e.channelUrl,\n            n = {};\n        return n.channel_url = t, new this(\"EXIT\", n);\n      }\n    }, {\n      key: \"generateRequestId\",\n      value: function value() {\n        return Ae++, String(Ae);\n      }\n    }]), e;\n  }(),\n      Se = 1048576,\n      Ie = function () {\n    function e(e) {\n      void 0 === e && (e = {}), this._emojiHash = e.emoji_hash || \"\", this._uploadSizeLimit = e.file_upload_size_limit ? e.file_upload_size_limit * Se : Number.MAX_VALUE, this._useReaction = !!e.use_reaction, this._applicationAttributes = e.application_attributes || [], this._premiumFeatureList = e.premium_feature_list || [], this._disableSupergroupMack = e.disable_supergroup_mack || !1;\n    }\n\n    return Object.defineProperty(e.prototype, \"emojiHash\", {\n      get: function get() {\n        return this._emojiHash;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"uploadSizeLimit\", {\n      get: function get() {\n        return this._uploadSizeLimit;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isUsingReaction\", {\n      get: function get() {\n        return this._useReaction;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"applicationAttributes\", {\n      get: function get() {\n        return this._applicationAttributes;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"premiumFeatureList\", {\n      get: function get() {\n        return this._premiumFeatureList;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isSupergroupMackDisabled\", {\n      get: function get() {\n        return this._disableSupergroupMack;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"enabledChannelMemberShipHistory\", {\n      get: function get() {\n        return this._applicationAttributes.includes(\"channel_membership_history\");\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype._objectify = function () {\n      var e = {};\n      return e.emoji_hash = this._emojiHash, this._uploadSizeLimit !== Number.MAX_VALUE && (e.file_upload_size_limit = this._uploadSizeLimit / Se), e.use_reaction = this._useReaction, e.application_attributes = this._applicationAttributes, e.premium_feature_list = this._premiumFeatureList, e.disable_supergroup_mack = this._disableSupergroupMack, e;\n    }, e;\n  }(),\n      Te = function () {\n    function e(e) {\n      this._source = e;\n    }\n\n    return Object.defineProperty(e.prototype, \"source\", {\n      get: function get() {\n        return this._source;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isFromEvent\", {\n      get: function get() {\n        return this._source >= 2e3;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e;\n  }(),\n      Oe = function Oe() {},\n      Ue = {\n    NAME_ALPHABETICAL: [\"name\", \"-pk\"],\n    CHRONOLOGICAL: [\"-createdAt\", \"-pk\"],\n    LATEST_LAST_MESSAGE: [\"-lastMessageCreatedAt\", \"-createdAt\", \"-pk\"]\n  },\n      Me = {\n    LATEST: [\"channelUrl\", \"-createdAt\", \"-messageId\"],\n    LATEST_UNSENT: [\"channelUrl\", \"sendingStatus\", \"createdAt\"],\n    CHILD_MESSAGE_FIRST: [\"channelUrl\", \"-parentMessageId\", \"-createdAt\"]\n  },\n      ke = function () {\n    function e(e, t) {\n      this._source = e, this._sendingStatus = t;\n    }\n\n    return Object.defineProperty(e.prototype, \"source\", {\n      get: function get() {\n        return this._source;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isFromEvent\", {\n      get: function get() {\n        return this._source >= 2e3;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"sendingStatus\", {\n      get: function get() {\n        return this._sendingStatus;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e;\n  }(),\n      Re = function () {\n    function e() {\n      this.messageType = \"\", this.customTypes = [\"*\"], this.senderUserIds = [], this.sendingStatus = null;\n    }\n\n    return e.prototype.clone = function () {\n      var t = new e(),\n          n = JSON.parse(JSON.stringify(this));\n      return Object.keys(n).forEach(function (e) {\n        t[e] = n[e];\n      }), t;\n    }, e.prototype.match = function (e) {\n      if (this.messageType && this.messageType !== e.messageType) return !1;\n      if (!this.customTypes.includes(\"*\") && !this.customTypes.includes(e.customType)) return !1;\n\n      if (this.senderUserIds.length > 0) {\n        if (!e.isUserMessage() && !e.isFileMessage()) return !1;\n        if (!this.senderUserIds.includes(e.sender.userId)) return !1;\n      }\n\n      return !this.sendingStatus || this.sendingStatus === e.sendingStatus;\n    }, e;\n  }(),\n      Le = function Le(e, t) {\n    if (e.length > 0) {\n      for (var n = 0, r = e.length - 1, i = Math.floor((n + r) / 2); n < r;) {\n        var s = e[i].createdAt - t.createdAt;\n        if (s > 0) r = i, i = Math.floor((n + r) / 2);else {\n          if (!(s < 0)) return i;\n          n = i + 1, i = Math.floor((n + r) / 2);\n        }\n      }\n\n      return e[i].createdAt > t.createdAt ? i : i + 1;\n    }\n\n    return e.length;\n  },\n      Pe = function Pe(e) {\n    var t = e.channel,\n        n = e.ts,\n        r = e.prevLimit,\n        i = void 0 === r ? 0 : r,\n        s = e.nextLimit,\n        a = void 0 === s ? 0 : s,\n        o = e.filter,\n        l = {\n      channel: t,\n      token: n,\n      tokenType: \"timestamp\",\n      isInclusive: !0,\n      prevResultSize: i,\n      nextResultSize: a,\n      shouldReverse: !1,\n      includeMetaArray: !0,\n      includeReactions: !0,\n      includeThreadInfo: !0,\n      includeReplies: !0,\n      includeParentMessageText: !0,\n      showSubchannelMessagesOnly: !0\n    };\n\n    if (o) {\n      var u = o.messageType,\n          c = o.customTypes,\n          d = o.senderUserIds;\n      u && (l.messageType = u), c.length > 0 && (l.customTypes = c), d.length > 0 && (l.senderUserIds = d);\n    }\n\n    return l;\n  },\n      we = function we(e, t, n) {\n    if (n.length > 0) {\n      var r = n.map(function (e) {\n        return e.createdAt;\n      });\n      t.includes(\"prev\") && (e.top = Math.min.apply(Math, w([e.top], r, !1))), t.includes(\"next\") && (e.bottom = Math.max.apply(Math, w([e.bottom], r, !1)));\n    }\n  },\n      De = function De(e) {\n    return new Promise(function (t, n) {\n      setTimeout(function () {\n        return t();\n      }, e);\n    });\n  },\n      He = {};\n\n  !function (e) {\n    e.SUCCEEDED = \"succeeded\", e.UNSENT = \"unsent\";\n  }(fe || (fe = {}));\n\n  var Fe,\n      Ge = function () {\n    function e(e) {\n      var t = e.iid,\n          n = e.collections;\n      this._iid = t, this._collections = n, He[t] = this;\n    }\n\n    return e.of = function (e) {\n      return He[e];\n    }, e.prototype._serialize = function (e) {\n      return e.serialize();\n    }, e.prototype._deserialize = function (e) {\n      if (e) {\n        var t = _R(_R({}, e), {\n          messageId: parseInt(e.messageId)\n        }),\n            n = x.get(this._iid),\n            r = n.UserMessage,\n            i = n.FileMessage,\n            s = n.AdminMessage;\n\n        if (\"user\" === t.messageType) return r.buildFromSerializedData(t);\n        if (\"file\" === t.messageType) return i.buildFromSerializedData(t);\n        if (\"admin\" === t.messageType) return s.buildFromSerializedData(t);\n      }\n\n      return null;\n    }, e.deserialize = function (e, t) {\n      if (t) {\n        var n = _R(_R({}, t), {\n          messageId: parseInt(t.messageId)\n        }),\n            r = x.get(e),\n            i = r.UserMessage,\n            s = r.FileMessage,\n            a = r.AdminMessage;\n\n        if (\"user\" === n.messageType) return i.buildFromSerializedData(n);\n        if (\"file\" === n.messageType) return s.buildFromSerializedData(n);\n        if (\"admin\" === n.messageType) return a.buildFromSerializedData(n);\n      }\n\n      return null;\n    }, Object.defineProperty(e.prototype, \"_localCacheEnabled\", {\n      get: function get() {\n        return U.get(this._iid).get(\"localCacheEnabled\");\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype._getMessageCollectionByType = function (e) {\n      return e ? this._collections[e] : this._collections.succeeded;\n    }, e.prototype._getIndexByCollection = function (e) {\n      return \"UnsentMessage\" === e.name ? Me.LATEST_UNSENT : Me.LATEST;\n    }, e.prototype._fetch = function (e, t, n) {\n      return L(this, void 0, void 0, function () {\n        var r,\n            i,\n            s = this;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return this._localCacheEnabled ? (r = {\n                where: function where(r) {\n                  if (!r) return !1;\n                  if (e && r.channelUrl !== e) return !1;\n                  if (n.parentMessageId && r.parentMessageId !== n.parentMessageId) return !1;\n\n                  if (n.backward) {\n                    if (r.createdAt <= n.token) return !1;\n                  } else if (r.createdAt >= n.token) return !1;\n\n                  return !!t.match(s._deserialize(r));\n                },\n                index: n.index,\n                backward: n.backward\n              }, [4, n.collection.query(r)]) : [3, 3];\n\n            case 1:\n              return [4, a.sent().fetch({\n                limit: n.limit\n              })];\n\n            case 2:\n              return i = a.sent(), [2, Promise.all(i.map(function (e) {\n                return L(s, void 0, void 0, function () {\n                  var t, r, i;\n                  return P(this, function (s) {\n                    switch (s.label) {\n                      case 0:\n                        return t = this._deserialize(e), (r = e.messageParams) && r.file && te.isFileTypeBlob(r.fileType) && \"string\" == typeof t._messageParams.file ? (i = t._messageParams, [4, n.collection.getBlob(r.file)]) : [3, 2];\n\n                      case 1:\n                        i._file = s.sent(), s.label = 2;\n\n                      case 2:\n                        return [2, t];\n                    }\n                  });\n                });\n              }))];\n\n            case 3:\n              return [2, []];\n          }\n        });\n      });\n    }, e.fetch = function (t, n, r) {\n      return L(this, void 0, void 0, function () {\n        var i,\n            s,\n            a = this;\n        return P(this, function (o) {\n          switch (o.label) {\n            case 0:\n              return i = {\n                where: function where(i) {\n                  if (!i) return !1;\n\n                  if (r.backward) {\n                    if (i.createdAt <= r.token) return !1;\n                  } else if (i.createdAt >= r.token) return !1;\n\n                  return !!n.match(e.deserialize(t, i));\n                },\n                index: r.index,\n                backward: r.backward\n              }, [4, r.collection.query(i)];\n\n            case 1:\n              return [4, o.sent().fetch({\n                limit: r.limit\n              })];\n\n            case 2:\n              return s = o.sent(), [2, Promise.all(s.map(function (n) {\n                return L(a, void 0, void 0, function () {\n                  var i, s, a;\n                  return P(this, function (o) {\n                    switch (o.label) {\n                      case 0:\n                        return i = e.deserialize(t, n), (s = n.messageParams) && s.file && te.isFileTypeBlob(s.fileType) && \"string\" == typeof i._messageParams.file ? (a = i._messageParams, [4, r.collection.getBlob(s.file)]) : [3, 2];\n\n                      case 1:\n                        a.file = o.sent(), o.label = 2;\n\n                      case 2:\n                        return [2, i];\n                    }\n                  });\n                });\n              }))];\n          }\n        });\n      });\n    }, e.prototype.get = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n, r;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return this._localCacheEnabled ? (n = this._getMessageCollectionByType(t), r = this._deserialize, [4, n.getByKey(e)]) : [3, 2];\n\n            case 1:\n              return [2, r.apply(this, [i.sent()])];\n\n            case 2:\n              return [2, null];\n          }\n        });\n      });\n    }, e.prototype.getPreviousAndNextMessages = function (e, t, n, r, i) {\n      return void 0 === r && (r = 30), L(this, void 0, void 0, function () {\n        var s, a;\n        return P(this, function (o) {\n          switch (o.label) {\n            case 0:\n              return [4, this.getPreviousMessages(e, t, n, r, i)];\n\n            case 1:\n              return s = o.sent(), [4, this.getNextMessages(e, t, n, r, i)];\n\n            case 2:\n              return a = o.sent(), [2, function (e) {\n                for (var t = [], n = {}, r = 0, i = e; r < i.length; r++) {\n                  var s = i[r];\n                  s.messageId ? n[s.messageId] || (n[s.messageId] = !0, t.push(s)) : t.push(s);\n                }\n\n                return t;\n              }(w(w([], s, !0), a, !0))];\n          }\n        });\n      });\n    }, e.prototype.getPreviousMessages = function (e, t, n, r, i) {\n      return void 0 === r && (r = 30), L(this, void 0, void 0, function () {\n        var s;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return s = this._getMessageCollectionByType(i), [4, this._fetch(e, t, {\n                token: n,\n                limit: r,\n                backward: !1,\n                collection: s,\n                index: this._getIndexByCollection(s)\n              })];\n\n            case 1:\n              return [2, a.sent().reverse()];\n          }\n        });\n      });\n    }, e.prototype.getNextMessages = function (e, t, n, r, i) {\n      return void 0 === r && (r = 30), L(this, void 0, void 0, function () {\n        var s;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return s = this._getMessageCollectionByType(i), [4, this._fetch(e, t, {\n                token: n,\n                limit: r,\n                backward: !0,\n                collection: s,\n                index: this._getIndexByCollection(s)\n              })];\n\n            case 1:\n              return [2, a.sent()];\n          }\n        });\n      });\n    }, e.prototype.getAllChildMessages = function (e, t, n) {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return [4, this._fetch(e.channelUrl, t, {\n                token: Date.now(),\n                limit: null,\n                collection: n,\n                backward: !1,\n                index: Me.CHILD_MESSAGE_FIRST,\n                parentMessageId: e.messageId\n              })];\n\n            case 1:\n              return [2, r.sent()];\n          }\n        });\n      });\n    }, e.prototype.getUnsentMessages = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return n = this._getMessageCollectionByType(fe.UNSENT), [4, this._fetch(e, t, {\n                token: 0,\n                limit: null,\n                collection: n,\n                backward: !0,\n                index: Me.LATEST_UNSENT\n              })];\n\n            case 1:\n              return [2, r.sent()];\n          }\n        });\n      });\n    }, e.prototype.getAllUnsentMessages = function (t) {\n      return L(this, void 0, void 0, function () {\n        var n;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return n = this._getMessageCollectionByType(fe.UNSENT), [4, e.fetch(this._iid, t, {\n                token: Date.now(),\n                limit: null,\n                collection: n,\n                backward: !1,\n                index: Me.LATEST_UNSENT\n              })];\n\n            case 1:\n              return [2, r.sent()];\n          }\n        });\n      });\n    }, e.prototype.countBetween = function (e, t, n, r, i) {\n      return L(this, void 0, void 0, function () {\n        var s,\n            a = this;\n        return P(this, function (o) {\n          switch (o.label) {\n            case 0:\n              return this._localCacheEnabled ? (s = {\n                where: function where(i) {\n                  return i.channelUrl === e && !(n > i.createdAt || i.createdAt > r) && t.match(a._deserialize(i));\n                },\n                index: Me.LATEST\n              }, [4, this._getMessageCollectionByType(i).query(s)]) : [3, 3];\n\n            case 1:\n              return [4, o.sent().count()];\n\n            case 2:\n              return [2, o.sent()];\n\n            case 3:\n              return [2, 0];\n          }\n        });\n      });\n    }, e.prototype._serializeMessages = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n,\n            r,\n            i = this;\n        return P(this, function (s) {\n          switch (s.label) {\n            case 0:\n              return n = this._getMessageCollectionByType(t), r = [], [4, Promise.all(e.map(function (e) {\n                return L(i, void 0, void 0, function () {\n                  var t, i;\n                  return P(this, function (s) {\n                    switch (s.label) {\n                      case 0:\n                        return (t = e.serialize()) ? ((t = _R({}, t)).messageParams && (t.messageParams = _R({}, t.messageParams)), e.sendingStatus && \"succeeded\" !== e.sendingStatus ? t.messageId = \"unsent-\".concat(e.reqId) : t.messageId = \"\".concat(e.messageId), e.isFileMessage() && e._messageParams && e._messageParams.file && te.isBlob(e._messageParams.file) && te.isFileTypeBlob(e._messageParams.fileType) ? [4, n.saveBlob(e._messageParams.file, e.reqId)] : [3, 2]) : [3, 3];\n\n                      case 1:\n                        i = s.sent(), t.messageParams.file = i, s.label = 2;\n\n                      case 2:\n                        r.push(t), s.label = 3;\n\n                      case 3:\n                        return [2];\n                    }\n                  });\n                });\n              }))];\n\n            case 1:\n              return s.sent(), [2, r];\n          }\n        });\n      });\n    }, e.prototype.upsert = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n, r, i, s, a, o, l, u, c, d, h, p, f, _, g;\n\n        return P(this, function (y) {\n          switch (y.label) {\n            case 0:\n              return this._localCacheEnabled ? (n = ji.getInstance(this._iid), r = this._getMessageCollectionByType(t), [4, this._serializeMessages(e, t)]) : [3, 13];\n\n            case 1:\n              return i = y.sent(), [4, r.upsertMany(i)];\n\n            case 2:\n              if (y.sent(), t && t !== fe.SUCCEEDED) return [3, 13];\n              s = [], a = [], o = 0, y.label = 3;\n\n            case 3:\n              return o < e.length ? (l = e[o]).sendingStatus && l.sendingStatus === n.MessageSendingStatus.SUCCEEDED && l.updatedAt > 0 ? (c = (u = s).concat, [4, this._locallyUpdateChildMessages(l, fe.SUCCEEDED)]) : [3, 6] : [3, 7];\n\n            case 4:\n              return s = c.apply(u, [y.sent()]), h = (d = a).concat, [4, this._locallyUpdateChildMessages(l, fe.UNSENT)];\n\n            case 5:\n              a = h.apply(d, [y.sent()]), y.label = 6;\n\n            case 6:\n              return o++, [3, 3];\n\n            case 7:\n              return s.length > 0 ? (p = this._getMessageCollectionByType(fe.SUCCEEDED), [4, this._serializeMessages(s, fe.SUCCEEDED)]) : [3, 10];\n\n            case 8:\n              return f = y.sent(), [4, p.upsertMany(f)];\n\n            case 9:\n              y.sent(), y.label = 10;\n\n            case 10:\n              return a.length > 0 ? (_ = this._getMessageCollectionByType(fe.UNSENT), [4, this._serializeMessages(a, fe.UNSENT)]) : [3, 13];\n\n            case 11:\n              return g = y.sent(), [4, _.upsertMany(g)];\n\n            case 12:\n              y.sent(), y.label = 13;\n\n            case 13:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype._locallyUpdateChildMessages = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n, r, i;\n        return P(this, function (s) {\n          switch (s.label) {\n            case 0:\n              return n = new Re(), r = [], i = this._getMessageCollectionByType(t), [4, this.getAllChildMessages(e, n, i)];\n\n            case 1:\n              return s.sent().forEach(function (t) {\n                t.applyParentMessage(e) && r.push(t);\n              }), [2, r];\n          }\n        });\n      });\n    }, e.prototype.remove = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n, r;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return this._localCacheEnabled ? [4, De(500)] : [3, 3];\n\n            case 1:\n              return i.sent(), n = this._getMessageCollectionByType(t), r = {\n                messageId: {\n                  \"/in\": e.map(function (e) {\n                    return \"\".concat(e);\n                  })\n                }\n              }, [4, n.removeIf({\n                where: r\n              })];\n\n            case 2:\n              i.sent(), i.label = 3;\n\n            case 3:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.removeUnsentMessages = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s, a;\n        return P(this, function (o) {\n          switch (o.label) {\n            case 0:\n              return t = e.channelUrl, n = e.sendingStatus, r = e.reqIds, i = [], this._localCacheEnabled ? [4, De(500)] : [3, 3];\n\n            case 1:\n              return o.sent(), s = this._getMessageCollectionByType(fe.UNSENT), a = {\n                channelUrl: {\n                  \"=\": t\n                }\n              }, n && (a.sendingStatus = {\n                \"=\": n\n              }), r && r.length > 0 && (a.reqId = {\n                \"/in\": r\n              }), [4, s.removeIf({\n                where: a\n              })];\n\n            case 2:\n              i = o.sent(), o.label = 3;\n\n            case 3:\n              return [2, i];\n          }\n        });\n      });\n    }, e.prototype.removeFailedMessages = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n, r, i, s;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return n = [], this._localCacheEnabled ? [4, De(500)] : [3, 3];\n\n            case 1:\n              return a.sent(), r = this._getMessageCollectionByType(fe.UNSENT), i = ji.getInstance(this._iid), s = {\n                channelUrl: {\n                  \"=\": e\n                },\n                sendingStatus: {\n                  \"=\": i.MessageSendingStatus.FAILED\n                }\n              }, t && t.length > 0 && (s.reqId = {\n                \"/in\": t\n              }), [4, r.removeIf({\n                where: s\n              })];\n\n            case 2:\n              n = a.sent(), a.label = 3;\n\n            case 3:\n              return [2, n];\n          }\n        });\n      });\n    }, e.prototype.clearByChannelUrl = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t = this;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, Promise.all(Object.keys(fe).map(function (n) {\n                var r = t._getMessageCollectionByType(fe[n]),\n                    i = {\n                  channelUrl: {\n                    \"=\": e\n                  }\n                };\n\n                return r.removeIf({\n                  where: i\n                });\n              }))];\n\n            case 1:\n              return n.sent(), [2];\n          }\n        });\n      });\n    }, e.prototype.clear = function (e) {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return this._localCacheEnabled ? [4, this._getMessageCollectionByType(e).clear()] : [3, 2];\n\n            case 1:\n              t.sent(), t.label = 2;\n\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.clearAll = function () {\n      return L(this, void 0, void 0, function () {\n        var e = this;\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return this._localCacheEnabled ? [4, Promise.all(Object.keys(fe).map(function (t) {\n                return e.clear(fe[t]);\n              }))] : [3, 2];\n\n            case 1:\n              t.sent(), t.label = 2;\n\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.clearAbove = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n, r;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return this._localCacheEnabled ? (n = this._getMessageCollectionByType(t), r = {\n                createdAt: {\n                  \"<\": e\n                }\n              }, [4, n.removeIf({\n                where: r\n              })]) : [3, 2];\n\n            case 1:\n              i.sent(), i.label = 2;\n\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e;\n  }(),\n      xe = function () {\n    function e(e) {\n      var t = e.top,\n          n = e.bottom;\n      this.top = t, this.bottom = n;\n    }\n\n    return e.prototype.include = function (e) {\n      return this.top <= e && e <= this.bottom;\n    }, e.prototype.overlap = function (e) {\n      return this.include(e.top) || this.include(e.bottom);\n    }, e;\n  }(),\n      je = {},\n      Be = function Be(e, t) {\n    return \"sendbird:\".concat(e, \"@channel/\").concat(t, \"/message/sync\");\n  },\n      Ve = function () {\n    function e(e) {\n      var t = e.iid,\n          n = e.channel,\n          r = e.limit,\n          i = void 0 === r ? Ze : r,\n          s = this;\n      this._prevSync = null, this._nextSync = null, this._syncRange = new xe({\n        top: Number.MAX_SAFE_INTEGER,\n        bottom: -1\n      }), this._isPrevSyncComplete = !1, this._isNextSyncComplete = !1, this._iid = t, this._channel = n, this._limit = i;\n      var a = x.get(this._iid).BaseChannel,\n          o = U.get(this._iid),\n          l = o.get(\"currentUserId\"),\n          u = o.get(\"store\"),\n          c = o.get(\"apiClient\"),\n          d = Ge.of(this._iid),\n          h = ge.of(this._iid),\n          p = Be(l, this._channel.url),\n          f = o.container.concurrentCallLimit,\n          _ = o.container.backOffDelay;\n      this._prevSync = new ut(p, function (e) {\n        return L(s, void 0, void 0, function () {\n          var e,\n              t,\n              r,\n              i,\n              s,\n              o,\n              l,\n              f,\n              _,\n              g = this;\n\n          return P(this, function (y) {\n            switch (y.label) {\n              case 0:\n                return e = {\n                  hasNext: !0,\n                  nextParams: null\n                }, [4, u.get(p)];\n\n              case 1:\n                return (t = y.sent()) && t.isPrevSyncComplete ? [3, 7] : (t && (this._syncRange = t.range, this._isPrevSyncComplete = t.isPrevSyncComplete), r = Pe({\n                  channel: this._channel,\n                  ts: this._syncRange.top,\n                  prevLimit: this._limit\n                }), [4, c.getMessageList(r)]);\n\n              case 2:\n                return i = y.sent(), s = [], o = i.messages.map(function (e) {\n                  var t = a.buildMessage(e, g._channel);\n                  return (t.isUserMessage() || t.isFileMessage()) && t._isSentByMe() && s.push(t.reqId), t;\n                }), l = this.getMinCreatedAt(o), this._syncRange.top = Math.min(this._syncRange.top, l), this._syncRange.bottom < 0 && (this._syncRange.bottom = this.getMaxCreatedAt(o)), this._isPrevSyncComplete = o.length < this._limit, J.debug(\"Message collection background sync fetched messages count: \", o.length), [4, d.upsert(o)];\n\n              case 3:\n                return y.sent(), s.length > 0 ? [4, d.removeUnsentMessages({\n                  channelUrl: this._channel.url,\n                  reqIds: s\n                })] : [3, 5];\n\n              case 4:\n                y.sent(), y.label = 5;\n\n              case 5:\n                return f = {\n                  range: this._syncRange,\n                  isPrevSyncComplete: this._isPrevSyncComplete,\n                  isNextSyncComplete: t ? t.isNextSyncComplete : this._isNextSyncComplete\n                }, [4, u.set({\n                  key: p,\n                  value: f,\n                  generation: 1\n                })];\n\n              case 6:\n                return y.sent(), _ = {\n                  source: de.MESSAGE_BACKGROUND,\n                  payload: {\n                    channel: n,\n                    messages: o\n                  }\n                }, h.send(_), e.hasNext = !this._isPrevSyncComplete, [3, 8];\n\n              case 7:\n                J.debug(\"Message collection background sync has finished.\"), e.hasNext = !1, y.label = 8;\n\n              case 8:\n                return [2, e];\n            }\n          });\n        });\n      }, f, _), this._nextSync = new ut(p, function (e) {\n        return L(s, void 0, void 0, function () {\n          var e,\n              t,\n              r,\n              i,\n              s,\n              o,\n              l,\n              f,\n              _,\n              g = this;\n\n          return P(this, function (y) {\n            switch (y.label) {\n              case 0:\n                return e = {\n                  hasNext: !0,\n                  nextParams: null\n                }, [4, u.get(p)];\n\n              case 1:\n                return (t = y.sent()) ? (this._syncRange = t.range, r = Pe({\n                  channel: this._channel,\n                  ts: this._syncRange.bottom,\n                  nextLimit: this._limit\n                }), [4, c.getMessageList(r)]) : [3, 7];\n\n              case 2:\n                return i = y.sent(), s = [], o = i.messages.map(function (e) {\n                  var t = a.buildMessage(e, g._channel);\n                  return (t.isUserMessage() || t.isFileMessage()) && t._isSentByMe() && s.push(t.reqId), t;\n                }), l = this.getMaxCreatedAt(o), this._syncRange.bottom = Math.max(this._syncRange.bottom, l), this._isNextSyncComplete = o.length < this._limit, [4, d.upsert(o)];\n\n              case 3:\n                return y.sent(), s.length > 0 ? [4, d.removeUnsentMessages({\n                  channelUrl: this._channel.url,\n                  reqIds: s\n                })] : [3, 5];\n\n              case 4:\n                y.sent(), y.label = 5;\n\n              case 5:\n                return f = {\n                  range: this._syncRange,\n                  isPrevSyncComplete: t ? t.isPrevSyncComplete : this._isPrevSyncComplete,\n                  isNextSyncComplete: this._isNextSyncComplete\n                }, [4, u.set({\n                  key: p,\n                  value: f,\n                  generation: 1\n                })];\n\n              case 6:\n                y.sent(), _ = {\n                  source: de.MESSAGE_BACKGROUND,\n                  payload: {\n                    channel: n,\n                    messages: o\n                  }\n                }, h.send(_), e.hasNext = !this._isNextSyncComplete, y.label = 7;\n\n              case 7:\n                return [2, e];\n            }\n          });\n        });\n      }, f, _);\n    }\n\n    return e.of = function (t, n, r) {\n      return void 0 === r && (r = Ze), je[t] || (je[t] = {}), je[t][n.url] || (je[t][n.url] = new e({\n        iid: t,\n        channel: n,\n        limit: r\n      })), je[t][n.url];\n    }, Object.defineProperty(e.prototype, \"priority\", {\n      set: function set(e) {\n        this._prevSync.priority = e, this._nextSync.priority = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"range\", {\n      get: function get() {\n        return this._syncRange;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.resume = function () {\n      J.debug(\"Message collection background sync has resumed.\"), this._isPrevSyncComplete || this._prevSync.resume(null), this._isNextSyncComplete || this._nextSync.resume(null);\n    }, e.prototype.pause = function () {\n      J.debug(\"Message collection background sync has paused.\"), this._prevSync.stop(), this._nextSync.stop();\n    }, e.prototype.getMinCreatedAt = function (e) {\n      var t = Number.MAX_SAFE_INTEGER;\n      return e.forEach(function (e) {\n        var n = e.createdAt;\n        n < t && (t = n);\n      }), t;\n    }, e.prototype.getMaxCreatedAt = function (e) {\n      var t = 0;\n      return e.forEach(function (e) {\n        var n = e.createdAt;\n        n > t && (t = n);\n      }), t;\n    }, e;\n  }(),\n      qe = {},\n      Ke = function Ke(e, t) {\n    return \"sendbird:\".concat(e, \"@channel/\").concat(t, \"/message/changelogs\");\n  },\n      ze = function () {\n    function e(e) {\n      var t = e.iid,\n          n = e.channel,\n          r = this;\n      this._token = 0, this._sync = null, this._iid = t, this._channel = n;\n      var i = x.get(this._iid).BaseChannel,\n          s = U.get(this._iid),\n          a = s.get(\"currentUserId\"),\n          o = s.get(\"store\"),\n          l = s.get(\"apiClient\"),\n          u = s.container.localCacheEnabled,\n          c = Ge.of(this._iid),\n          d = ge.of(this._iid),\n          h = Ke(a, this._channel.url);\n      this._sync = new ut(h, function (e) {\n        return L(r, void 0, void 0, function () {\n          var e,\n              t,\n              r,\n              a,\n              p,\n              f,\n              _,\n              g,\n              y,\n              m = this;\n\n          return P(this, function (E) {\n            switch (E.label) {\n              case 0:\n                return e = {\n                  hasNext: !0,\n                  nextParams: \"\"\n                }, u ? [4, o.get(h)] : [3, 2];\n\n              case 1:\n                return r = E.sent(), [3, 3];\n\n              case 2:\n                r = null, E.label = 3;\n\n              case 3:\n                t = r, this._token = t ? t.token : s.get(\"firstConnectedAt\") / 1e3, a = {\n                  channelUrl: this._channel.url,\n                  isOpenChannel: this._channel.isOpenChannel(),\n                  includeMetaArray: !0,\n                  includeReactions: !0,\n                  includeReplies: !0,\n                  includeParentMessageText: !0,\n                  includeThreadInfo: !0\n                }, \"number\" == typeof this._token ? a.timestamp = this._token : a.token = this._token, E.label = 4;\n\n              case 4:\n                return E.trys.push([4, 12,, 15]), [4, l.getMessageChangeLogs(a)];\n\n              case 5:\n                return p = E.sent(), f = p.updated.map(function (e) {\n                  return i.buildMessage(e, m._channel);\n                }), _ = {\n                  updatedMessages: f,\n                  deletedMessageIds: p.deleted.map(function (e) {\n                    return parseInt(e.message_id);\n                  })\n                }, e.hasNext = p.has_more, e.nextParams = this._token = p.next, u ? (g = [], f.forEach(function (e) {\n                  (e.isUserMessage() || e.isFileMessage()) && e._isSentByMe() && g.push(e.reqId);\n                }), g.length > 0 ? [4, c.removeUnsentMessages({\n                  channelUrl: this._channel.url,\n                  reqIds: g\n                })] : [3, 7]) : [3, 11];\n\n              case 6:\n                E.sent(), E.label = 7;\n\n              case 7:\n                return [4, c.upsert(f)];\n\n              case 8:\n                return E.sent(), [4, c.remove(_.deletedMessageIds)];\n\n              case 9:\n                return E.sent(), [4, o.set({\n                  key: h,\n                  value: {\n                    token: this._token\n                  },\n                  generation: 1\n                })];\n\n              case 10:\n                E.sent(), E.label = 11;\n\n              case 11:\n                return J.debug(\"Message collection changelog sync update messages count: \", _.updatedMessages.length), J.debug(\"Message collection changelog sync deleted message ids count: \", _.deletedMessageIds.length), y = {\n                  source: de.MESSAGE_CHANGELOG,\n                  payload: _R({\n                    channel: n\n                  }, _)\n                }, d.send(y), [2, e];\n\n              case 12:\n                return E.sent().isInvalidTokenError ? [4, o.remove(h)] : [3, 14];\n\n              case 13:\n                E.sent(), E.label = 14;\n\n              case 14:\n                return [3, 15];\n\n              case 15:\n                return [2];\n            }\n          });\n        });\n      });\n    }\n\n    return e.of = function (t, n) {\n      return qe[t] || (qe[t] = {}), qe[t][n.url] || (qe[t][n.url] = new e({\n        iid: t,\n        channel: n\n      })), qe[t][n.url];\n    }, e.prototype.resume = function () {\n      J.debug(\"Message collection changelog sync has resumed.\"), this._sync.resume(null, !0);\n    }, e.prototype.pause = function () {\n      J.debug(\"Message collection changelog sync has paused.\"), this._sync.stop();\n    }, e;\n  }();\n\n  !function (e) {\n    e.CACHE_AND_REPLACE_BY_API = \"cache_and_replace_by_api\", e.CACHE_ONLY = \"cache_only\";\n  }(Fe || (Fe = {}));\n\n  var Ye,\n      Qe = function () {\n    function e() {\n      this._onCacheResult = null, this._onApiResult = null;\n    }\n\n    return e.prototype.invokeCacheResult = function (e, t) {\n      this._onCacheResult(e, t);\n    }, e.prototype.invokeApiResult = function (e, t) {\n      this._onApiResult(e, t);\n    }, e.prototype.onCacheResult = function (e) {\n      return this._onCacheResult = e, this;\n    }, e.prototype.onApiResult = function (e) {\n      return this._onApiResult = e, this;\n    }, e;\n  }(),\n      We = function We() {\n    var e = new Date().getTime();\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (t) {\n      var n = (e + 16 * Math.random()) % 16 | 0;\n      return e = Math.floor(e / 16), (\"x\" === t ? n : 3 & n | 8).toString(16);\n    });\n  },\n      Je = function () {\n    function e() {}\n\n    return e.prototype.isNetworkConnected = function () {\n      return !(\"undefined\" == typeof navigator || !navigator.onLine);\n    }, e.ready = function () {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (e) {\n          return \"undefined\" != typeof navigator && navigator && \"boolean\" == typeof navigator.onLine ? [2, navigator.onLine] : [2, new Promise(function (e, t) {\n            i.default.get(\"https://www.google.com\").then(function () {\n              return e(!0);\n            }).catch(function () {\n              return e(!1);\n            });\n          })];\n        });\n      });\n    }, e;\n  }();\n\n  !function (e) {\n    e[e.BACKGROUND_SYNC_CLOSE = 0] = \"BACKGROUND_SYNC_CLOSE\", e[e.BACKGROUND_SYNC_OPEN = 1] = \"BACKGROUND_SYNC_OPEN\", e[e.FILL = 2] = \"FILL\", e[e.USER_CALL = 3] = \"USER_CALL\";\n  }(Ye || (Ye = {}));\n\n  var Xe,\n      Ze = 100,\n      $e = new xe({\n    top: Number.MAX_SAFE_INTEGER,\n    bottom: 0\n  }),\n      et = new Map(),\n      tt = function tt(e) {\n    return \"sendbird@message/fill/\".concat(e, \"/\").concat(We());\n  },\n      nt = function () {\n    function e(e) {\n      var t = e.iid,\n          n = e.channel,\n          r = e.startingPoint,\n          i = e.filter,\n          s = e.limit,\n          a = void 0 === s ? 100 : s,\n          o = this;\n      this._hugeGapCheckTimer = null, this._messages = [], this._syncRange = new xe(_R({}, $e)), this._hasPrevious = !0, this._hasNext = !0, this._unsentMessages = [], this._iid = t, this._channel = n, this._startingPoint = r, this._filter = i, this._limit = a, this._syncLimit = Math.max(a, Ze), this._eventObserver = {\n        onevent: function onevent(e) {\n          return L(o, void 0, void 0, function () {\n            return P(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, this._handleEvent(e)];\n\n                case 1:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }\n      }, this._eventHandler = {\n        onMessagesAdded: Oe,\n        onMessagesUpdated: Oe,\n        onMessagesDeleted: Oe,\n        onChannelUpdated: Oe,\n        onChannelDeleted: Oe,\n        onHugeGapDetected: Oe\n      };\n      var l = U.get(this._iid);\n      this._localCacheEnabled = l.container.localCacheEnabled, this._localCacheEnabled && (this._backgroundSync = Ve.of(this._iid, this._channel, this._syncLimit), this._backgroundSync.resume()), this._changelogSync = ze.of(this._iid, this._channel), this._connectionObserver = {\n        onConnect: function onConnect() {\n          o._checkHugeGap(), o._localCacheEnabled && o._backgroundSync.resume(), o._changelogSync.resume();\n        },\n        onDisconnect: function onDisconnect() {\n          return L(o, void 0, void 0, function () {\n            return P(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return [4, Je.ready()];\n\n                case 1:\n                  return e.sent() || (this._previousFillSync.stop(), this._nextFillSync.stop(), this._localCacheEnabled && this._backgroundSync.pause(), this._changelogSync.pause()), [2];\n              }\n            });\n          });\n        }\n      }, this._previousFillSync = new ut(tt(\"prev\"), function (e) {\n        return L(o, void 0, void 0, function () {\n          var t, n, r;\n          return P(this, function (i) {\n            switch (i.label) {\n              case 0:\n                return [4, this._getRemoteMessages({\n                  ts: e,\n                  prevLimit: this._syncLimit\n                })];\n\n              case 1:\n                return (t = i.sent()).length > 0 ? (n = Math.min.apply(Math, t.map(function (e) {\n                  return e.createdAt;\n                })), this._syncRange.top = Math.min(this._syncRange.top, n), r = new ke(de.MESSAGE_FILL, t[0].sendingStatus), this._addOnlyMessageToView(t, {\n                  context: r\n                }), [2, {\n                  hasNext: t.length < this._syncLimit || this._syncRange.top >= n,\n                  nextParams: this._syncRange.top\n                }]) : [2, {\n                  hasNext: !1,\n                  nextParams: 0\n                }];\n            }\n          });\n        });\n      }), this._nextFillSync = new ut(tt(\"next\"), function (e) {\n        return L(o, void 0, void 0, function () {\n          var t, n, r;\n          return P(this, function (i) {\n            switch (i.label) {\n              case 0:\n                return [4, this._getRemoteMessages({\n                  ts: e,\n                  nextLimit: this._syncLimit\n                })];\n\n              case 1:\n                return (t = i.sent()).length > 0 ? (n = Math.max.apply(Math, t.map(function (e) {\n                  return e.createdAt;\n                })), this._syncRange.bottom = Math.max(this._syncRange.bottom, n), r = new ke(de.MESSAGE_FILL, t[0].sendingStatus), this._addOnlyMessageToView(t, {\n                  context: r\n                }), [2, {\n                  hasNext: t.length < this._syncLimit || this._syncRange.bottom <= n,\n                  nextParams: this._syncRange.bottom\n                }]) : [2, {\n                  hasNext: !1,\n                  nextParams: 0\n                }];\n            }\n          });\n        });\n      }), pe.of(this._iid).addObserver(this._connectionObserver);\n    }\n\n    return e.prototype._handleEvent = function (e) {\n      var t = e.source,\n          n = e.payload,\n          r = void 0 === n ? {} : n,\n          i = ji.getInstance(this._iid);\n\n      switch (e.source) {\n        case de.MESSAGE_BACKGROUND:\n          break;\n\n        case de.MESSAGE_CHANGELOG:\n          var s = r,\n              a = s.channel,\n              o = s.updatedMessages,\n              l = s.deletedMessageIds;\n\n          if (a && a.url === this._channel.url) {\n            if (o && o.length > 0) {\n              this._removeMatchingUnsentMessagesFromView(o);\n\n              var u = new ke(t, o[0].sendingStatus);\n\n              this._addMessagesToView(o, {\n                context: u\n              });\n            }\n\n            if (l && l.length > 0) if ((p = this._removeMessagesFromView(l, {})).length > 0) {\n              u = new ke(t, p[0].sendingStatus);\n\n              this._eventHandler.onMessagesDeleted(u, this._channel, p);\n            }\n          }\n\n          break;\n\n        case de.LOCAL_MESSAGE_PENDING_CREATED:\n        case de.LOCAL_MESSAGE_RESEND_STARTED:\n        case de.LOCAL_MESSAGE_CANCELED:\n          var c = r,\n              d = (a = c.channel, c.message);\n          u = new ke(t, d.sendingStatus);\n          a.url === this._channel.url && this._upsertUnsentMessagesToView([d], {\n            context: u\n          });\n          break;\n\n        case de.EVENT_MESSAGE_SENT:\n          var h = r;\n          a = h.channel, d = h.message;\n\n          if (a.url === this._channel.url) {\n            var p = this._removeMatchingUnsentMessagesFromView([d]);\n\n            if (this._hasNext) {\n              if (p.length > 0) {\n                u = new ke(t, p[0].sendingStatus);\n\n                this._eventHandler.onMessagesDeleted(u, a, p);\n              }\n            } else {\n              this._addMessagesToView([d], {});\n\n              var u = new ke(t, d.sendingStatus);\n              p.length > 0 ? this._eventHandler.onMessagesUpdated(u, a, [d]) : this._eventHandler.onMessagesAdded(u, a, [d]);\n            }\n          }\n\n          break;\n\n        case de.EVENT_MESSAGE_RECEIVED:\n          var f = r;\n          a = f.channel, d = f.message;\n\n          if (a.url === this._channel.url && !this._hasNext) {\n            u = new ke(t, d.sendingStatus);\n\n            this._addMessagesToView([d], {\n              context: u\n            });\n          }\n\n          break;\n\n        case de.LOCAL_MESSAGE_FAILED:\n          var _ = r;\n          a = _.channel, d = _.message;\n\n          if (a.url === this._channel.url && d.sendingStatus === i.MessageSendingStatus.FAILED) {\n            u = new ke(t, d.sendingStatus);\n\n            this._upsertUnsentMessagesToView([d], {\n              context: u\n            });\n          }\n\n          break;\n\n        case de.EVENT_MESSAGE_UPDATED:\n          var g = r;\n          a = g.channel, d = g.message;\n\n          if (a.url === this._channel.url) {\n            u = new ke(t, d.sendingStatus);\n\n            this._addMessagesToView([d], {\n              context: u,\n              isUpdateOnly: !0\n            });\n          }\n\n          break;\n\n        case de.EVENT_MESSAGE_DELETED:\n          var y = r,\n              m = (a = y.channel, y.messageId);\n          if (a.url === this._channel.url) if (et.delete(m), (p = this._removeMessagesFromView([m], {})).length > 0) {\n            u = new ke(t, p[0].sendingStatus);\n\n            this._eventHandler.onMessagesDeleted(u, this._channel, p);\n          }\n          break;\n\n        case de.EVENT_DELIVERY_RECEIPT_UPDATED:\n        case de.EVENT_READ_RECEIPT_UPDATED:\n          if ((a = r.channel).isGroupChannel()) {\n            o = [];\n\n            for (var E = 0, v = this._messages; E < v.length; E++) {\n              d = v[E];\n              (et.get(d.messageId) || 0) !== (T = this.channel.getUnreadMemberCount(d)) && (o.push(d), T > 0 ? et.set(d.messageId, T) : et.delete(d.messageId));\n            }\n\n            if (o.length > 0) {\n              u = new ke(t, o[0].sendingStatus);\n\n              this._eventHandler.onMessagesUpdated(u, a, o);\n            }\n          }\n\n          break;\n\n        case de.EVENT_USER_LEFT:\n          var b = U.get(this._iid),\n              C = r,\n              A = (a = C.channel, C.user),\n              N = b.get(\"currentUserId\");\n\n          if (A.userId !== N) {\n            o = [];\n\n            for (var S = 0, I = this._messages; S < I.length; S++) {\n              var T;\n              d = I[S];\n              (et.get(d.messageId) || 0) !== (T = this.channel.getUnreadMemberCount(d)) && (o.push(d), T > 0 ? et.set(d.messageId, T) : et.delete(d.messageId));\n            }\n\n            if (o.length > 0) {\n              u = new ke(t, o[0].sendingStatus);\n\n              this._eventHandler.onMessagesUpdated(u, a, o);\n            }\n          } else {\n            u = new Te(t);\n\n            this._eventHandler.onChannelDeleted(u, a.url);\n          }\n\n          break;\n\n        case de.EVENT_CHANNEL_CHANGED:\n        case de.EVENT_USER_RECEIVED_INVITATION:\n        case de.EVENT_USER_JOINED:\n        case de.EVENT_CHANNEL_FROZEN:\n        case de.EVENT_CHANNEL_UNFROZEN:\n        case de.EVENT_CHANNEL_HIDDEN:\n        case de.EVENT_CHANNEL_UNHIDDEN:\n        case de.EVENT_USER_MUTED:\n        case de.EVENT_USER_UNMUTED:\n        case de.EVENT_TYPING_STATUS_UPDATED:\n        case de.EVENT_OPERATOR_UPDATED:\n        case de.EVENT_CHANNEL_METADATA_UPDATED:\n        case de.EVENT_CHANNEL_METADATA_DELETED:\n        case de.EVENT_CHANNEL_METACOUNTER_UPDATED:\n        case de.EVENT_CHANNEL_METACOUNTER_DELETED:\n          a = r.channel, u = new Te(t);\n\n          this._eventHandler.onChannelUpdated(u, a);\n\n          break;\n\n        case de.EVENT_CHANNEL_DELETED:\n          a = r.channel, u = new Te(t);\n\n          this._eventHandler.onChannelDeleted(u, a.url);\n\n      }\n    }, e.prototype._createRemoteMessageParams = function (e) {\n      var t = e.prevLimit,\n          n = void 0 === t ? 0 : t,\n          r = e.nextLimit,\n          i = void 0 === r ? 0 : r,\n          s = new (0, x.get(this._iid).MessageListParams)();\n      return s.isInclusive = !0, s.prevResultSize = n, s.nextResultSize = i, s.includeMetaArray = !0, s.includeReactions = !0, s.includeThreadInfo = !0, s.includeReplies = !0, s.includeParentMessageText = !0, s;\n    }, e.prototype._getRemoteMessages = function (e) {\n      var t = e.ts,\n          n = e.prevLimit,\n          r = void 0 === n ? 0 : n,\n          i = e.nextLimit,\n          s = void 0 === i ? 0 : i;\n      return L(this, void 0, void 0, function () {\n        var e, n, i, a;\n        return P(this, function (o) {\n          switch (o.label) {\n            case 0:\n              return e = [], r > 0 ? (i = this._createRemoteMessageParams({\n                prevLimit: r,\n                nextLimit: 0\n              }), [4, this._channel.getMessagesByTimestamp(t, i)]) : [3, 2];\n\n            case 1:\n              n = o.sent(), e = e.concat(n), this._hasPrevious = n.length >= r, o.label = 2;\n\n            case 2:\n              return s > 0 ? (i = this._createRemoteMessageParams({\n                prevLimit: 0,\n                nextLimit: s\n              }), [4, this._channel.getMessagesByTimestamp(t, i)]) : [3, 4];\n\n            case 3:\n              a = o.sent(), e = e.concat(a), this._hasNext = a.length >= s, o.label = 4;\n\n            case 4:\n              return e.length > 0 ? [4, this._upsertRemotelyFetchedMessages(e)] : [3, 6];\n\n            case 5:\n              o.sent(), o.label = 6;\n\n            case 6:\n              return [2, e];\n          }\n        });\n      });\n    }, e.prototype._upsertRemotelyFetchedMessages = function (e, t) {\n      return void 0 === t && (t = {}), L(this, void 0, void 0, function () {\n        var n, r, i, s;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return n = t.context, r = void 0 === n ? null : n, i = Ge.of(this._iid), s = e.map(function (e) {\n                return e.reqId;\n              }), [4, i.removeUnsentMessages({\n                channelUrl: this.channel.url,\n                reqIds: s\n              })];\n\n            case 1:\n              return a.sent(), this._removeMatchingUnsentMessagesFromView(e, {\n                context: r\n              }), [4, i.upsert(e, fe.SUCCEEDED)];\n\n            case 2:\n              return a.sent(), [2];\n          }\n        });\n      });\n    }, e.prototype._checkHugeGap = function () {\n      return L(this, void 0, void 0, function () {\n        var e,\n            t,\n            n,\n            r,\n            i,\n            s,\n            a,\n            o,\n            l,\n            u,\n            c,\n            d,\n            h,\n            p,\n            f,\n            _ = this;\n\n        return P(this, function (g) {\n          switch (g.label) {\n            case 0:\n              return g.trys.push([0, 12,, 13]), e = x.get(this._iid).BaseChannel, t = U.get(this._iid), n = t.get(\"apiClient\"), this._messages.length > 0 ? (r = Ge.of(this._iid), i = {\n                from: this._messages[0].createdAt,\n                to: Math.min(this._syncRange.top, this._messages[this._messages.length - 1].createdAt),\n                cachedCount: 0\n              }, s = i, [4, r.countBetween(this._channel.url, this._filter, i.from, i.to)]) : [3, 8];\n\n            case 1:\n              return s.cachedCount = g.sent(), a = {\n                from: Math.max(this._syncRange.bottom, this._messages[0].createdAt),\n                to: this.hasNext ? this._messages[this._messages.length - 1].createdAt : Number.MAX_SAFE_INTEGER,\n                cachedCount: 0\n              }, o = a, [4, r.countBetween(this._channel.url, this._filter, a.from, a.to)];\n\n            case 2:\n              return o.cachedCount = g.sent(), l = {\n                iid: this._iid,\n                channelUrl: this._channel.url,\n                channelType: this._channel.channelType,\n                filter: this._filter,\n                previous: i,\n                next: a\n              }, [4, n.checkMessageHugeGap(_R(_R({}, l), l.filter))];\n\n            case 3:\n              return u = g.sent(), (c = {\n                isHugeGap: !!u.is_huge_gap,\n                previousMessages: u.prev_messages.map(function (t) {\n                  return e.buildMessage(t, _._channel);\n                }) || [],\n                previousHasMore: !!u.prev_hasmore,\n                nextMessages: u.next_messages.map(function (t) {\n                  return e.buildMessage(t, _._channel);\n                }) || [],\n                nextHasMore: !!u.next_hasmore\n              }).isHugeGap ? [3, 6] : (h = w(w([], c.previousMessages, !0), c.nextMessages, !0), J.debug(\"Message collection non-huge gap message fill count: \", h.length), h.length > 0 ? (p = new ke(de.MESSAGE_FILL, h[0].sendingStatus), [4, this._upsertRemotelyFetchedMessages(h, {\n                context: p\n              })]) : [3, 5]);\n\n            case 4:\n              g.sent(), this._addOnlyMessageToView(h, {\n                context: p\n              }), this._extendSyncRange([\"prev\"], c.previousMessages), this._extendSyncRange([\"next\"], c.nextMessages), c.previousHasMore && this._previousFillSync.run(this._syncRange.top), c.nextHasMore && this._nextFillSync.run(this._syncRange.bottom), g.label = 5;\n\n            case 5:\n              return [3, 7];\n\n            case 6:\n              setTimeout(function () {\n                return _._eventHandler.onHugeGapDetected();\n              }, 10), g.label = 7;\n\n            case 7:\n              return [3, 11];\n\n            case 8:\n              return d = Math.floor(this._syncLimit / 2), [4, this._getRemoteMessages({\n                ts: this._startingPoint,\n                prevLimit: d,\n                nextLimit: d\n              })];\n\n            case 9:\n              return (h = g.sent()).length > 0 ? (p = new ke(de.MESSAGE_FILL, h[0].sendingStatus), [4, this._upsertRemotelyFetchedMessages(h, {\n                context: p\n              })]) : [3, 11];\n\n            case 10:\n              g.sent(), this._addOnlyMessageToView(h, {\n                context: p\n              }), this._extendSyncRange([\"prev\", \"next\"], this._messages), g.label = 11;\n\n            case 11:\n              return [3, 13];\n\n            case 12:\n              return f = g.sent(), J.warn(\"Message collection huge gap checker error: \", f), this._hugeGapCheckTimer = setTimeout(function () {\n                _._hugeGapCheckTimer = null, _._checkHugeGap();\n              }, 3e3), [3, 13];\n\n            case 13:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype._extendSyncRange = function (e, t) {\n      if (t.length > 0) {\n        var n = t.map(function (e) {\n          return e.createdAt;\n        });\n        e.includes(\"prev\") && (this._syncRange.top = Math.min.apply(Math, w([this._syncRange.top], n, !1))), e.includes(\"next\") && (this._syncRange.bottom = Math.max.apply(Math, w([this._syncRange.bottom], n, !1)));\n      }\n    }, e.prototype._updateChildMessagesInView = function (e) {\n      var t = [];\n      return this._messages.forEach(function (n) {\n        n.applyParentMessage(e) && t.push(n);\n      }), t;\n    }, e.prototype._addOnlyMessageToView = function (e, t) {\n      void 0 === t && (t = {});\n      var n = t.context,\n          r = void 0 === n ? null : n;\n      t.isUpdateOnly;\n\n      for (var i = ji.getInstance(this._iid), s = [], a = 0, o = e; a < o.length; a++) {\n        var l = o[a];\n\n        if (l.sendingStatus === i.MessageSendingStatus.SUCCEEDED) {\n          var u = this._messages.map(function (e) {\n            return e.messageId;\n          }).indexOf(l.messageId);\n\n          if (this._filter.match(l)) {\n            var c = this._channel.getUnreadMemberCount(l);\n\n            if (et.set(l.messageId, c), -1 === u) {\n              var d = Le(this._messages, l);\n              s.push(l), this._messages.splice(d, 0, l);\n            }\n          }\n        }\n      }\n\n      r && s.length > 0 && this._eventHandler.onMessagesAdded(r, this._channel, s);\n    }, e.prototype._addMessagesToView = function (e, t) {\n      void 0 === t && (t = {});\n\n      for (var n = t.context, r = void 0 === n ? null : n, i = t.isUpdateOnly, s = void 0 !== i && i, a = ji.getInstance(this._iid), o = [], l = [], u = [], c = 0, d = e; c < d.length; c++) {\n        var h = d[c];\n\n        if (h.sendingStatus === a.MessageSendingStatus.SUCCEEDED) {\n          var p = this._messages.map(function (e) {\n            return e.messageId;\n          }).indexOf(h.messageId);\n\n          if (this._filter.match(h)) {\n            var f = this._channel.getUnreadMemberCount(h);\n\n            if (et.set(h.messageId, f), p >= 0) {\n              if (l.push(h), this._messages[p] = h, h.updatedAt > 0) {\n                var _ = this._updateChildMessagesInView(h);\n\n                l = l.concat(_);\n              }\n            } else if (!s) {\n              var g = Le(this._messages, h);\n              o.push(h), this._messages.splice(g, 0, h);\n            }\n          } else p >= 0 && (u.push(h), this._messages.splice(p, 1));\n        }\n      }\n\n      r && (o.length > 0 && this._eventHandler.onMessagesAdded(r, this._channel, o), l.length > 0 && this._eventHandler.onMessagesUpdated(r, this._channel, l), u.length > 0 && this._eventHandler.onMessagesDeleted(r, this._channel, u));\n    }, e.prototype._removeMessagesFromView = function (e, t) {\n      void 0 === t && (t = {});\n\n      for (var n = t.context, r = void 0 === n ? null : n, i = [], s = 0, a = e; s < a.length; s++) {\n        var o = a[s],\n            l = this._messages.map(function (e) {\n          return e.messageId;\n        }).indexOf(o);\n\n        if (l >= 0) {\n          var u = this._messages[l];\n          i.push(u), this._messages.splice(l, 1);\n        }\n      }\n\n      return r && i.length > 0 && this._eventHandler.onMessagesDeleted(r, this._channel, i), i;\n    }, e.prototype._upsertUnsentMessagesToView = function (e, t) {\n      void 0 === t && (t = {});\n\n      for (var n = t.context, r = void 0 === n ? null : n, i = [], s = [], a = [], o = 0, l = e; o < l.length; o++) {\n        var u = l[o],\n            c = this._unsentMessages.map(function (e) {\n          return e.reqId;\n        }).indexOf(u.reqId);\n\n        if (this._filter.match(u)) {\n          if (c >= 0) s.push(u), this._unsentMessages[c] = u;else {\n            var d = Le(this._unsentMessages, u);\n            i.push(u), this._unsentMessages.splice(d, 0, u);\n          }\n        } else c >= 0 && (this._unsentMessages.splice(c, 1), a.push(u));\n      }\n\n      r && (i.length > 0 && this._eventHandler.onMessagesAdded(r, this._channel, i), s.length > 0 && this._eventHandler.onMessagesUpdated(r, this._channel, s), a.length > 0 && this._eventHandler.onMessagesDeleted(r, this._channel, a));\n    }, e.prototype._removeMatchingUnsentMessagesFromView = function (e, t) {\n      void 0 === t && (t = {});\n\n      for (var n = t.context, r = void 0 === n ? null : n, i = [], s = 0, a = e; s < a.length; s++) {\n        var o = a[s];\n\n        if ((o.isUserMessage() || o.isFileMessage()) && o._isSentByMe()) {\n          var l = this._unsentMessages.map(function (e) {\n            return e.reqId;\n          }).indexOf(o.reqId);\n\n          if (l >= 0) {\n            var u = this._unsentMessages[l];\n            i.push(u), this._unsentMessages.splice(l, 1);\n          }\n        }\n      }\n\n      return r && i.length > 0 && this._eventHandler.onMessagesDeleted(r, this._channel, i), i;\n    }, e.prototype._removeFailedMessagesFromView = function (e) {\n      var t = ji.getInstance(this._iid),\n          n = [],\n          r = [],\n          i = this._unsentMessages.map(function (e) {\n        return e.reqId;\n      });\n\n      if (e) for (var s = 0, a = e; s < a.length; s++) {\n        var o = a[s],\n            l = i.indexOf(o.reqId);\n        l >= 0 && this._unsentMessages[l].sendingStatus === t.MessageSendingStatus.FAILED ? n.push(this._unsentMessages[l]) : r.push(this._unsentMessages[l]);\n      } else for (var u = 0, c = this._unsentMessages; u < c.length; u++) {\n        (o = c[u]).sendingStatus === t.MessageSendingStatus.FAILED ? n.push(o) : r.push(o);\n      }\n      return this._unsentMessages = r, n;\n    }, e._processNextAutoResend = function (e) {\n      if (e.isCacheEnabled && !e.isInBackground && e.getConnectionState() === e.ConnectionState.OPEN) try {\n        var t = e.getAutoResendQueue();\n\n        if (t.length > 0) {\n          e.getIsProcessingAutoResend() || (J.debug(\"Auto-resend queue started.\"), e.setIsProcessingAutoResend(!0));\n          var n = t[0];\n          J.debug(\"Processing auto-resend for message request id: \", n.reqId), x.get(e._iid).GroupChannel.getChannel(n.channelUrl, T.INTERNAL_CALL, function (t, r) {\n            var i;\n            if (e.getErrorFirstCallback() && (r = (i = [t, r])[0], t = i[1]), r) throw r;\n            n.isUserMessage() ? t._autoResendUserMessage(n) : n.isFileMessage() && t._autoResendFileMessage(n);\n          });\n        } else J.debug(\"Auto-resend queue finished.\"), e.setIsProcessingAutoResend(!1);\n      } catch (t) {\n        J.warn(\"Process auto-resend error: \", t), e.setIsProcessingAutoResend(!1);\n      }\n    }, e._completeCurrentAndProcessNextAutoResend = function (e, t) {\n      if (e.isCacheEnabled && t._isAutoResendRegistered) {\n        var n = e.getAutoResendQueue();\n        if (t.sendingStatus === e.MessageSendingStatus.SUCCEEDED || t.sendingStatus === e.MessageSendingStatus.FAILED && !se.isAutoResendableError(t.errorCode)) n.length > 0 && t.reqId === n[0].reqId && (n.shift(), this._processNextAutoResend(e));else if (t.sendingStatus === e.MessageSendingStatus.PENDING) {\n          if (n.length > 0 && n.map(function (e) {\n            return e.reqId;\n          }).indexOf(t.reqId) > -1) return;\n          n.push(t), !e.getIsProcessingAutoResend() && n.length > 0 && this._processNextAutoResend(e);\n        }\n      }\n    }, e._processAutoResendRegisteredPendingMessages = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s, a, o, l, u, c, d, h;\n        return P(this, function (p) {\n          switch (p.label) {\n            case 0:\n              return t = Ge.of(e._iid), n = ge.of(e._iid), (r = new Re()).sendingStatus = e.MessageSendingStatus.PENDING, [4, t.getAllUnsentMessages(r)];\n\n            case 1:\n              i = p.sent(), s = 0, a = i, p.label = 2;\n\n            case 2:\n              return s < a.length ? (o = a[s], [4, e.GroupChannel.getChannel(o.channelUrl)]) : [3, 7];\n\n            case 3:\n              return l = p.sent(), o._isAutoResendRegistered ? (u = new Date().getTime(), c = o.createdAt + 2592e5, u <= c ? (-1 === (d = e.getAutoResendQueue()).map(function (e) {\n                return e.reqId;\n              }).indexOf(o.reqId) && d.push(o), [3, 6]) : [3, 4]) : [3, 6];\n\n            case 4:\n              return J.debug(\"Auto-resend registered pending messaged expired. Expiration date: \", new Date(c).toLocaleString()), (h = o._clone()).sendingStatus = e.MessageSendingStatus.FAILED, h.requestState = e.MessageRequestState.FAILED, h._isAutoResendRegistered = !1, [4, t.upsert([h], fe.UNSENT)];\n\n            case 5:\n              p.sent(), n.send({\n                source: de.LOCAL_MESSAGE_FAILED,\n                payload: {\n                  channel: l,\n                  message: h\n                }\n              }), p.label = 6;\n\n            case 6:\n              return s++, [3, 2];\n\n            case 7:\n              return [2];\n          }\n        });\n      });\n    }, e._processNonAutoResendRegisteredPendingMessages = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s, a, o, l, u;\n        return P(this, function (c) {\n          switch (c.label) {\n            case 0:\n              return t = Ge.of(e._iid), n = ge.of(e._iid), (r = new Re()).sendingStatus = e.MessageSendingStatus.PENDING, [4, t.getAllUnsentMessages(r)];\n\n            case 1:\n              i = c.sent(), s = 0, a = i, c.label = 2;\n\n            case 2:\n              return s < a.length ? (o = a[s], [4, e.GroupChannel.getChannel(o.channelUrl)]) : [3, 6];\n\n            case 3:\n              return l = c.sent(), o._isAutoResendRegistered ? [3, 5] : (J.debug(\"Cached pending message is not auto-resend registered. Changing its sending status to failed: \", o.reqId), (u = o._clone()).sendingStatus = e.MessageSendingStatus.FAILED, u.requestState = e.MessageRequestState.FAILED, u.errorCode = H.ACK_TIMEOUT, [4, t.upsert([u], fe.UNSENT)]);\n\n            case 4:\n              c.sent(), n.send({\n                source: de.LOCAL_MESSAGE_FAILED,\n                payload: {\n                  channel: l,\n                  message: u\n                }\n              }), c.label = 5;\n\n            case 5:\n              return s++, [3, 2];\n\n            case 6:\n              return [2];\n          }\n        });\n      });\n    }, Object.defineProperty(e.prototype, \"channel\", {\n      get: function get() {\n        return this._channel;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"succeededMessages\", {\n      get: function get() {\n        return this._messages;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"pendingMessages\", {\n      get: function get() {\n        var e = ji.getInstance(this._iid);\n        return this._unsentMessages.filter(function (t) {\n          return t.sendingStatus === e.MessageSendingStatus.PENDING;\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"failedMessages\", {\n      get: function get() {\n        var e = ji.getInstance(this._iid);\n        return this._unsentMessages.filter(function (t) {\n          return t.sendingStatus === e.MessageSendingStatus.FAILED;\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"startingPoint\", {\n      get: function get() {\n        return this._startingPoint;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"hasPrevious\", {\n      get: function get() {\n        return this._hasPrevious;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"hasNext\", {\n      get: function get() {\n        return this._hasNext;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.initialize = function (e) {\n      var t = this,\n          n = new Qe();\n      this._messages = [], this._syncRange = new xe(_R({}, $e)), this._hasNext = !0, this._hasPrevious = !0;\n      var r = Math.floor(this._limit / 2),\n          i = Ge.of(this._iid),\n          s = ge.of(this._iid);\n\n      switch (e) {\n        case Fe.CACHE_ONLY:\n          i.getPreviousAndNextMessages(this._channel.url, this._filter, this._startingPoint, r).then(function (e) {\n            return L(t, void 0, void 0, function () {\n              var t;\n              return P(this, function (r) {\n                switch (r.label) {\n                  case 0:\n                    return [4, i.getUnsentMessages(this._channel.url, this._filter)];\n\n                  case 1:\n                    return t = r.sent(), this._upsertUnsentMessagesToView(t), this._addMessagesToView(e), n.invokeCacheResult(null, e), [2];\n                }\n              });\n            });\n          }).catch(function (e) {\n            n.invokeCacheResult(e, null);\n          }).finally(function () {\n            s.addObserver(t._eventObserver);\n          });\n          break;\n\n        case Fe.CACHE_AND_REPLACE_BY_API:\n          i.getPreviousAndNextMessages(this._channel.url, this._filter, this._startingPoint, r).then(function (e) {\n            return L(t, void 0, void 0, function () {\n              var t;\n              return P(this, function (r) {\n                switch (r.label) {\n                  case 0:\n                    return [4, i.getUnsentMessages(this._channel.url, this._filter)];\n\n                  case 1:\n                    return t = r.sent(), this._upsertUnsentMessagesToView(t), this._addMessagesToView(e), n.invokeCacheResult(null, e), [2];\n                }\n              });\n            });\n          }).catch(function (e) {\n            n.invokeCacheResult(e, null);\n          }).finally(function () {\n            t._getRemoteMessages({\n              ts: t._startingPoint,\n              prevLimit: r,\n              nextLimit: r\n            }).then(function (e) {\n              t._messages = [], t._addMessagesToView(e), t._extendSyncRange([\"prev\", \"next\"], t._messages), n.invokeApiResult(null, e);\n            }).catch(function (e) {\n              n.invokeApiResult(e, null);\n            }).finally(function () {\n              s.addObserver(t._eventObserver);\n            });\n          });\n      }\n\n      return n;\n    }, e.prototype.loadPrevious = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return this._hasPrevious ? (e = this._messages.length > 0 ? Math.min.apply(Math, this._messages.map(function (e) {\n                return e.createdAt;\n              })) : Number.MAX_SAFE_INTEGER, [4, Je.ready()]) : [3, 5];\n\n            case 1:\n              return n.sent() ? [3, 3] : (J.debug(\"Message collection loadPrevious() from the cache.\"), [4, Ge.of(this._iid).getPreviousMessages(this._channel.url, this._filter, e, this._limit)]);\n\n            case 2:\n              return t = n.sent(), this._addMessagesToView(t), [2, t];\n\n            case 3:\n              return J.debug(\"Message collection loadPrevious() from the server.\"), [4, this._getRemoteMessages({\n                ts: e,\n                prevLimit: this._limit\n              })];\n\n            case 4:\n              return t = n.sent(), this._addMessagesToView(t), we(this._syncRange, [\"prev\"], this._messages), [2, t];\n\n            case 5:\n              return [2, []];\n          }\n        });\n      });\n    }, e.prototype.loadNext = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return this._hasNext ? (e = this._messages.length > 0 ? Math.max.apply(Math, this._messages.map(function (e) {\n                return e.createdAt;\n              })) : 0, [4, Je.ready()]) : [3, 5];\n\n            case 1:\n              return n.sent() ? [3, 3] : (J.debug(\"Message collection loadNext() from the cache.\"), [4, Ge.of(this._iid).getNextMessages(this._channel.url, this._filter, e, this._limit)]);\n\n            case 2:\n              return t = n.sent(), this._addMessagesToView(t), [2, t];\n\n            case 3:\n              return J.debug(\"Message collection loadNext() from the server.\"), [4, this._getRemoteMessages({\n                ts: e,\n                nextLimit: this._limit\n              })];\n\n            case 4:\n              return t = n.sent(), this._addMessagesToView(t), we(this._syncRange, [\"next\"], this._messages), [2, t];\n\n            case 5:\n              return [2, []];\n          }\n        });\n      });\n    }, e.prototype.removeFailedMessages = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i;\n        return P(this, function (s) {\n          switch (s.label) {\n            case 0:\n              return t = ji.getInstance(this._iid), n = Ge.of(this._iid), r = e.map(function (e) {\n                return e.reqId;\n              }), [4, n.removeUnsentMessages({\n                channelUrl: this.channel.url,\n                sendingStatus: t.MessageSendingStatus.FAILED,\n                reqIds: r\n              })];\n\n            case 1:\n              return i = s.sent(), this._removeFailedMessagesFromView(e), [2, i];\n          }\n        });\n      });\n    }, e.prototype.removeAllFailedMessages = function () {\n      return L(this, void 0, void 0, function () {\n        var e;\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return e = ji.getInstance(this._iid), [4, Ge.of(this._iid).removeUnsentMessages({\n                channelUrl: this.channel.url,\n                sendingStatus: e.MessageSendingStatus.FAILED\n              })];\n\n            case 1:\n              return t.sent(), this._removeFailedMessagesFromView(), [2];\n          }\n        });\n      });\n    }, e.prototype.dispose = function () {\n      this._localCacheEnabled && (this._previousFillSync.stop(), this._nextFillSync.stop(), this._backgroundSync.pause()), this._changelogSync.pause(), pe.of(this._iid).removeObserver(this._connectionObserver), this._hugeGapCheckTimer && (clearTimeout(this._hugeGapCheckTimer), this._hugeGapCheckTimer = null), ge.of(this._iid).removeObserver(this._eventObserver);\n    }, e.prototype.setMessageCollectionHandler = function (e) {\n      this._eventHandler = e;\n    }, e;\n  }(),\n      rt = new Map(),\n      it = new Map(),\n      st = new Map(),\n      at = function () {\n    function e(t) {\n      var n = t.key,\n          r = t.concurrentCallLimit,\n          i = void 0 === r ? 2 : r,\n          s = t.backOffDelay,\n          a = void 0 === s ? 0 : s,\n          o = this;\n      this._holdersKey = e.createSemaphoreHoldersKey(n), this._resolversKey = e.createSemaphoreResolversKey(n), this._chainProcessStateKey = e.createChainProcessStateKey(n), this._numLocks = i, this._backOffDelay = a, this._localAcquiredKeys = [], this._localResolversData = [], $() ? (rt[this._holdersKey] || (rt[this._holdersKey] = []), it[this._resolversKey] || (it[this._resolversKey] = [])) : (window.addEventListener(\"storage\", function (e) {\n        return L(o, void 0, void 0, function () {\n          var t, n;\n          return P(this, function (r) {\n            if (this._localResolversData.length > 0 && this.numLocksAvailable > 0 && !this._isProcessChainAcquireRunning() && this._hasHighestPriorityResolver()) switch (e.key) {\n              case this._holdersKey:\n                if (t = JSON.parse(e.oldValue), n = JSON.parse(e.newValue), !t || !n || n.length >= t.length) return [2];\n\n                this._processChainResolve();\n\n                break;\n\n              case this._chainProcessStateKey:\n                if (JSON.parse(e.newValue)) return [2];\n\n                this._processChainResolve();\n\n                break;\n\n              default:\n                return [2];\n            }\n            return [2];\n          });\n        });\n      }), window.addEventListener(\"beforeunload\", function () {\n        var e = o._getLocalResolversData(),\n            t = o._localResolversData.map(function (e) {\n          return e.key;\n        }),\n            n = e.filter(function (e) {\n          return t.indexOf(e.key) < 0;\n        });\n\n        n.length > 0 ? window.localStorage.setItem(o._resolversKey, JSON.stringify(n)) : window.localStorage.removeItem(o._resolversKey), o._localAcquiredKeys.forEach(function (e) {\n          return o.release(e);\n        });\n      }));\n    }\n\n    return e.createSemaphoreHoldersKey = function (e) {\n      return \"collection@semaphore_holders_for:\" + e;\n    }, e.createSemaphoreResolversKey = function (e) {\n      return \"collection@semaphore_resolvers_for:\" + e;\n    }, e.createChainProcessStateKey = function (e) {\n      return \"collection@semaphore_chain_process_state_for:\" + e;\n    }, Object.defineProperty(e.prototype, \"numLocks\", {\n      get: function get() {\n        return this._numLocks;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"backOffDelay\", {\n      get: function get() {\n        return this._backOffDelay;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"numLocksAvailable\", {\n      get: function get() {\n        if ($()) return this.numLocks - rt[this._holdersKey].length;\n\n        var e = this._getLocalHoldersData();\n\n        return this.numLocks - e.length;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"waitCount\", {\n      get: function get() {\n        return $() ? it[this._resolversKey].length : this._getLocalResolversData().length;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype._hasHighestPriorityResolver = function () {\n      var e = this._getLocalResolversData();\n\n      return e.length > 0 && this._localResolversData.map(function (e) {\n        return e.key;\n      }).indexOf(e[0].key) >= 0;\n    }, e.prototype._isProcessChainAcquireRunning = function () {\n      if ($()) return st[this._chainProcessStateKey];\n      var e = window.localStorage[this._chainProcessStateKey];\n      return void 0 !== e && JSON.parse(e);\n    }, e.prototype._setProcessChainAcquireRunning = function (e) {\n      $() ? st[this._chainProcessStateKey] = e : e ? window.localStorage.setItem(this._chainProcessStateKey, JSON.stringify(e)) : window.localStorage.removeItem(this._chainProcessStateKey);\n    }, e.prototype._processChainResolve = function () {\n      return L(this, void 0, void 0, function () {\n        var e;\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return this.waitCount > 0 && this.numLocksAvailable > 0 && !this._isProcessChainAcquireRunning() ? (this._setProcessChainAcquireRunning(!0), this._tryResolve() ? [4, (n = this._backOffDelay, L(void 0, void 0, void 0, function () {\n                return P(this, function (e) {\n                  return [2, new Promise(function (e) {\n                    return setTimeout(e, n);\n                  })];\n                });\n              }))] : [3, 2]) : [3, 3];\n\n            case 1:\n              t.sent(), t.label = 2;\n\n            case 2:\n              this._setProcessChainAcquireRunning(!1), $() ? this._processChainResolve() : (e = new StorageEvent(\"storage\", {\n                key: this._chainProcessStateKey,\n                oldValue: JSON.stringify(!0),\n                newValue: JSON.stringify(!1)\n              }), dispatchEvent(e)), t.label = 3;\n\n            case 3:\n              return [2];\n          }\n\n          var n;\n        });\n      });\n    }, e.prototype.acquire = function (e) {\n      return void 0 === e && (e = Ye.BACKGROUND_SYNC_CLOSE), L(this, void 0, void 0, function () {\n        var t,\n            n = this;\n        return P(this, function (r) {\n          return $() ? [2, new Promise(function (t) {\n            var r = {\n              key: We(),\n              resolver: function resolver(e) {\n                return t(e);\n              },\n              priority: e\n            };\n\n            switch (e) {\n              case Ye.USER_CALL:\n              case Ye.FILL:\n              case Ye.BACKGROUND_SYNC_OPEN:\n                for (var i = it[n._resolversKey], s = -1, a = 0; a < i.length && s < 0; a++) {\n                  e > i[a].priority && (s = a);\n                }\n\n                if (s >= 0) {\n                  it[n._resolversKey].splice(s, 0, r);\n\n                  break;\n                }\n\n              case Ye.BACKGROUND_SYNC_CLOSE:\n                it[n._resolversKey].push(r);\n\n            }\n\n            n._processChainResolve();\n          })] : (t = this._getLocalResolversData(), [2, new Promise(function (r) {\n            var i = We(),\n                s = {\n              key: i,\n              priority: e\n            },\n                a = {\n              key: i,\n              resolver: function resolver(e) {\n                return r(e);\n              },\n              priority: e\n            };\n\n            switch (e) {\n              case Ye.USER_CALL:\n              case Ye.FILL:\n              case Ye.BACKGROUND_SYNC_OPEN:\n                for (var o = -1, l = 0; l < t.length && o < 0; l++) {\n                  e > t[l].priority && (o = l);\n                }\n\n                if (o >= 0) {\n                  t.splice(o, 0, s), window.localStorage.setItem(n._resolversKey, JSON.stringify(t)), n._localResolversData.splice(o, 0, a);\n                  break;\n                }\n\n              case Ye.BACKGROUND_SYNC_CLOSE:\n                t.push(s), window.localStorage.setItem(n._resolversKey, JSON.stringify(t)), n._localResolversData.push(a);\n            }\n\n            n._processChainResolve();\n          })]);\n        });\n      });\n    }, e.prototype.release = function (e) {\n      if ($()) {\n        if ((t = rt[this._holdersKey].indexOf(e)) >= 0) return rt[this._holdersKey].splice(t, 1), this._processChainResolve(), !0;\n      } else {\n        var t,\n            n = JSON.parse(window.localStorage[this._holdersKey]),\n            r = w([], n, !0);\n\n        if ((t = n.indexOf(e)) >= 0) {\n          n.splice(t, 1), n.length > 0 ? window.localStorage.setItem(this._holdersKey, JSON.stringify(n)) : window.localStorage.removeItem(this._holdersKey), this._localAcquiredKeys.splice(this._localAcquiredKeys.indexOf(e), 1);\n          var i = new StorageEvent(\"storage\", {\n            key: this._holdersKey,\n            oldValue: JSON.stringify(r),\n            newValue: JSON.stringify(n)\n          });\n          return dispatchEvent(i), !0;\n        }\n      }\n\n      return !1;\n    }, e.prototype._tryResolve = function () {\n      if ($()) {\n        if (rt[this._holdersKey].length < this.numLocks) {\n          var e = We();\n          return rt[this._holdersKey] = w(w([], rt[this._holdersKey], !0), [e], !1), (n = it[this._resolversKey].shift()).resolver(e), !0;\n        }\n      } else {\n        var t = this._getLocalHoldersData();\n\n        if (t.length < this.numLocks) {\n          e = We();\n\n          var n = this._localResolversData.shift(),\n              r = this._getLocalResolversData(),\n              i = r.map(function (e) {\n            return e.key;\n          }).indexOf(n.key);\n\n          r.splice(i, 1), r.length > 0 ? window.localStorage.setItem(this._resolversKey, JSON.stringify(r)) : window.localStorage.removeItem(this._resolversKey), window.localStorage.setItem(this._holdersKey, JSON.stringify(w(w([], t, !0), [e], !1))), this._localAcquiredKeys.push(e);\n          var s = new StorageEvent(\"storage\", {\n            key: this._holdersKey,\n            oldValue: JSON.stringify(w([], t, !0)),\n            newValue: JSON.stringify(w(w([], t, !0), [e], !1))\n          });\n          return dispatchEvent(s), (0, n.resolver)(e), !0;\n        }\n      }\n\n      return !1;\n    }, e.prototype._getLocalHoldersData = function () {\n      var e = window.localStorage[this._holdersKey];\n      return void 0 !== e ? JSON.parse(e) : [];\n    }, e.prototype._getLocalResolversData = function () {\n      var e = window.localStorage[this._resolversKey];\n      return void 0 !== e ? JSON.parse(e) : [];\n    }, e;\n  }();\n\n  !function (e) {\n    e[e.IDLE = 0] = \"IDLE\", e[e.RUNNING = 1] = \"RUNNING\", e[e.END = 2] = \"END\";\n  }(Xe || (Xe = {}));\n\n  var ot,\n      lt = function lt() {},\n      ut = function () {\n    function e(e, t, n, r) {\n      void 0 === n && (n = 2), void 0 === r && (r = 10), this._worker = null, this._state = Xe.IDLE, this._retryCount = 0, this._retryLimit = 3, this._isPaused = !1, this.priority = Ye.BACKGROUND_SYNC_CLOSE, this.onProgress = lt, this.onStop = lt, this.onError = lt, this.onEnd = lt, this._key = e, this._worker = t, this._semaphore = new at({\n        key: e,\n        concurrentCallLimit: n,\n        backOffDelay: r\n      });\n    }\n\n    return Object.defineProperty(e.prototype, \"isIdle\", {\n      get: function get() {\n        return this._state === Xe.IDLE;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isRunning\", {\n      get: function get() {\n        return this._state === Xe.RUNNING;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isDone\", {\n      get: function get() {\n        return this._state === Xe.END;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isPaused\", {\n      get: function get() {\n        return this._isPaused;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"retryCount\", {\n      get: function get() {\n        return this._retryCount;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"retryLimit\", {\n      get: function get() {\n        return this._retryLimit;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.resume = function (e, t) {\n      return void 0 === t && (t = !1), this._isPaused = !1, this.isDone && t && (this._state = Xe.IDLE), this.run(e);\n    }, e.prototype.run = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return this._isPaused || !this.isIdle ? [3, 5] : (t = this, [4, this._semaphore.acquire(this.priority)]);\n\n            case 1:\n              t._key = i.sent(), this._state = Xe.RUNNING, i.label = 2;\n\n            case 2:\n              return i.trys.push([2, 4,, 5]), [4, this._worker(e)];\n\n            case 3:\n              return n = i.sent(), this._retryCount = 0, this.onProgress(n), n.hasNext ? (this._state = Xe.IDLE, this._isPaused ? (this._semaphore.release(this._key), this.onStop()) : (this.run(n.nextParams), this._semaphore.release(this._key))) : (this._state = Xe.END, this._semaphore.release(this._key), this.onEnd(), this._isPaused && this.onStop()), [3, 5];\n\n            case 4:\n              return r = i.sent(), J.warn(\"Collection sync run error: \", r), this._state = Xe.IDLE, this._semaphore.release(this._key), this.onError(r), this._retryCount < this._retryLimit ? (this._retryCount++, J.debug(\"Failed collection sync retry count: \", this._retryCount), this.run(e)) : (J.debug(\"Failed collection sync all retries failed.\"), this.stop(), this.onStop()), [3, 5];\n\n            case 5:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.stop = function () {\n      this._isPaused = !0;\n    }, e;\n  }(),\n      ct = {},\n      dt = function () {\n    function e(e) {\n      var t = e.iid,\n          n = e.limit,\n          r = void 0 === n ? mt : n,\n          i = this;\n      this._token = \"\", this._sync = null, this._syncRange = new xe({\n        top: Number.MAX_SAFE_INTEGER,\n        bottom: 0\n      }), this._completed = !1, this._pkIndex = Date.now(), this._iid = t, this._limit = r;\n      var s = x.get(this._iid).GroupChannel,\n          a = U.get(this._iid),\n          o = a.get(\"currentUserId\"),\n          l = a.get(\"apiClient\"),\n          u = a.get(\"store\"),\n          c = bt.of(this._iid),\n          d = ge.of(this._iid),\n          h = \"sendbird:\".concat(o, \"@groupchannel/sync\");\n      this._sync = new ut(h, function (e) {\n        return L(i, void 0, void 0, function () {\n          var e,\n              t,\n              n,\n              r,\n              i,\n              a,\n              o = this;\n          return P(this, function (p) {\n            switch (p.label) {\n              case 0:\n                return e = {\n                  hasNext: !0,\n                  nextParams: \"\"\n                }, [4, u.get(h)];\n\n              case 1:\n                if ((t = p.sent()) && t.completed) return [3, 10];\n                t && (this._token = t.token, this._syncRange = t.range, this._pkIndex = t.primaryKeyIndex), n = {\n                  token: this._token,\n                  limit: this._limit,\n                  includeEmpty: !0,\n                  order: \"chronological\"\n                }, p.label = 2;\n\n              case 2:\n                return p.trys.push([2, 6,, 9]), [4, l.loadGroupChannelList(n)];\n\n              case 3:\n                return r = p.sent(), i = r.channels.map(function (e) {\n                  return r.ts && (e.ts = r.ts), e.cached_primary_key = o._pkIndex--, s.upsert(e);\n                }), this._syncRange.top = Math.min(this._syncRange.top, Math.min.apply(Math, i.map(function (e) {\n                  return e.createdAt;\n                }))), this._syncRange.bottom = Math.max(this._syncRange.bottom, Math.max.apply(Math, i.map(function (e) {\n                  return e.createdAt;\n                }))), e.hasNext = i.length >= this._limit, e.nextParams = this._token = r.next, this._token || (e.hasNext = !1), this._completed = !e.hasNext, J.debug(\"Group channel collection background sync fetched channels count: \", i.length), [4, c.upsert(i)];\n\n              case 4:\n                return p.sent(), [4, u.set({\n                  key: h,\n                  value: {\n                    token: this._token,\n                    range: this._syncRange,\n                    completed: this._completed,\n                    primaryKeyIndex: this._pkIndex\n                  },\n                  generation: 1\n                })];\n\n              case 5:\n                return p.sent(), a = {\n                  source: de.CHANNEL_BACKGROUND,\n                  payload: {\n                    channels: i\n                  }\n                }, d.send(a), [3, 9];\n\n              case 6:\n                return p.sent().isInvalidTokenError ? [4, u.remove(h)] : [3, 8];\n\n              case 7:\n                p.sent(), p.label = 8;\n\n              case 8:\n                return [3, 9];\n\n              case 9:\n                return [3, 11];\n\n              case 10:\n                J.debug(\"Group channel collection background sync has finished.\"), e.hasNext = !1, p.label = 11;\n\n              case 11:\n                return [2, e];\n            }\n          });\n        });\n      });\n    }\n\n    return e.of = function (t, n) {\n      return void 0 === n && (n = mt), ct[t] || (ct[t] = new e({\n        iid: t,\n        limit: n\n      })), ct[t];\n    }, Object.defineProperty(e.prototype, \"range\", {\n      get: function get() {\n        return this._syncRange;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"completed\", {\n      get: function get() {\n        return this._completed;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.resume = function () {\n      J.debug(\"Group channel collection background sync has resumed.\"), this._sync.resume(\"\");\n    }, e.prototype.pause = function () {\n      J.debug(\"Group channel collection background sync has paused.\"), this._sync.stop();\n    }, e;\n  }(),\n      ht = {},\n      pt = function () {\n    function e(e) {\n      var t = e.iid,\n          n = this;\n      this._token = 0, this._sync = null, this._pkIndex = Date.now(), this._iid = t;\n      var r = x.get(this._iid).GroupChannel,\n          i = U.get(this._iid);\n      this._token = i.get(\"firstConnectedAt\") / 1e3;\n      var s = i.get(\"currentUserId\"),\n          a = i.get(\"store\"),\n          o = i.get(\"apiClient\"),\n          l = i.container.localCacheEnabled,\n          u = bt.of(this._iid),\n          c = ge.of(this._iid),\n          d = \"sendbird:\".concat(s, \"@groupchannel/changelogs\");\n      this._sync = new ut(d, function (e) {\n        return L(n, void 0, void 0, function () {\n          var e,\n              t,\n              n,\n              i,\n              s,\n              h,\n              p,\n              f = this;\n          return P(this, function (_) {\n            switch (_.label) {\n              case 0:\n                return e = {\n                  hasNext: !0,\n                  nextParams: \"\"\n                }, l ? [4, a.get(d)] : [3, 2];\n\n              case 1:\n                return n = _.sent(), [3, 3];\n\n              case 2:\n                n = null, _.label = 3;\n\n              case 3:\n                (t = n) && (this._token = t.token, this._pkIndex = t.primaryKeyIndex), i = {}, \"number\" == typeof this._token ? i.ts = this._token : i.token = this._token, _.label = 4;\n\n              case 4:\n                return _.trys.push([4, 10,, 13]), [4, o.getMyGroupChannelChangeLogs(i)];\n\n              case 5:\n                return s = _.sent(), h = {\n                  updatedChannels: s.updated.map(function (e) {\n                    return e.cached_primary_key = f._pkIndex--, r.upsert(e);\n                  }),\n                  deletedChannelUrls: s.deleted\n                }, e.hasNext = s.has_more, e.nextParams = this._token = s.next, J.debug(\"Group channel collection changelog sync update channels count: \", h.updatedChannels.length), J.debug(\"Group channel collection changelog sync deleted channel urls count: \", h.deletedChannelUrls.length), l ? [4, u.upsert(h.updatedChannels)] : [3, 9];\n\n              case 6:\n                return _.sent(), [4, u.remove(h.deletedChannelUrls)];\n\n              case 7:\n                return _.sent(), [4, a.set({\n                  key: d,\n                  value: {\n                    token: this._token,\n                    primaryKeyIndex: this._pkIndex\n                  },\n                  generation: 1\n                })];\n\n              case 8:\n                _.sent(), _.label = 9;\n\n              case 9:\n                return p = {\n                  source: de.CHANNEL_CHANGELOG,\n                  payload: h\n                }, c.send(p), [2, e];\n\n              case 10:\n                return _.sent().isInvalidTokenError ? [4, a.remove(d)] : [3, 12];\n\n              case 11:\n                _.sent(), _.label = 12;\n\n              case 12:\n                return [3, 13];\n\n              case 13:\n                return [2];\n            }\n          });\n        });\n      });\n    }\n\n    return e.of = function (t) {\n      return ht[t] || (ht[t] = new e({\n        iid: t\n      })), ht[t];\n    }, e.prototype.resume = function () {\n      J.debug(\"Group channel collection changelog sync has resumed.\"), this._sync.resume(0, !0);\n    }, e.prototype.pause = function () {\n      J.debug(\"Group channel collection changelog sync has paused.\"), this._sync.stop();\n    }, e;\n  }(),\n      ft = function ft(e, t) {\n    for (var n = 0; n < e.length; n++) {\n      if (e[n].url === t.url) return n;\n    }\n\n    return -1;\n  },\n      _t = function _t(e, t, n) {\n    if (e.length > 0) {\n      for (var r = 0, i = e.length - 1, s = Math.floor((r + i) / 2); r < i;) {\n        var a = yt(e[s], t, n);\n        if (a > 0) i = s, s = Math.floor((r + i) / 2);else {\n          if (!(a < 0)) return s;\n          r = s + 1, s = Math.floor((r + i) / 2);\n        }\n      }\n\n      return yt(e[s], t, n) > 0 ? s : s + 1;\n    }\n\n    return e.length;\n  },\n      gt = function gt(e, t) {\n    return t - e;\n  },\n      yt = function yt(e, t, n) {\n    switch (n) {\n      case ot.LATEST_LAST_MESSAGE:\n        if (e.lastMessage && !t.lastMessage) return -1;\n        if (!e.lastMessage && t.lastMessage) return 1;\n\n        if (e.lastMessage && t.lastMessage) {\n          var r = e.lastMessage.createdAt;\n\n          if (0 === (s = t.lastMessage.createdAt - r)) {\n            var i = e.createdAt;\n            0 === (s = t.createdAt - i) && (s = gt(e.cachedPrimaryKey, t.cachedPrimaryKey));\n          }\n\n          return s;\n        }\n\n        r = e.createdAt;\n        return 0 === (s = t.createdAt - r) && (s = gt(e.cachedPrimaryKey, t.cachedPrimaryKey)), s;\n\n      case ot.CHRONOLOGICAL:\n        return 0 === (s = t.createdAt - e.createdAt) && (s = gt(e.cachedPrimaryKey, t.cachedPrimaryKey)), s;\n\n      case ot.CHANNEL_NAME_ALPHABETICAL:\n        var s;\n        return 0 === (s = e.name.localeCompare(t.name)) && (s = gt(e.cachedPrimaryKey, t.cachedPrimaryKey)), s;\n    }\n  },\n      mt = 40;\n\n  !function (e) {\n    e.LATEST_LAST_MESSAGE = \"latest_last_message\", e.CHRONOLOGICAL = \"chronological\", e.CHANNEL_NAME_ALPHABETICAL = \"channel_name_alphabetical\";\n  }(ot || (ot = {}));\n\n  var Et = function () {\n    function e(e) {\n      var t = e.iid,\n          n = e.filter,\n          r = e.order,\n          i = e.limit,\n          s = void 0 === i ? 20 : i,\n          a = this;\n      this._channels = [], this._token = null, this._hasMore = !0, this._iid = t, this._filter = n, this._order = r, this._limit = s, this._syncLimit = Math.max(s, mt), this._eventObserver = {\n        onevent: function onevent(e) {\n          return L(a, void 0, void 0, function () {\n            return P(this, function (t) {\n              return [2, this._handleEvent(e)];\n            });\n          });\n        }\n      }, this._eventHandler = {\n        onChannelsAdded: Oe,\n        onChannelsUpdated: Oe,\n        onChannelsDeleted: Oe\n      };\n      var o = U.get(this._iid);\n      this._localCacheEnabled = o.container.localCacheEnabled, this._localCacheEnabled && (this._backgroundSync = dt.of(this._iid, this._syncLimit), this._backgroundSync.resume()), this._changelogSync = pt.of(this._iid), ge.of(this._iid).addObserver(this._eventObserver), this._connectionStateObserver = {\n        onConnect: function onConnect() {\n          a._localCacheEnabled && a._backgroundSync.resume(), a._changelogSync.resume();\n        },\n        onDisconnect: function onDisconnect() {\n          return L(a, void 0, void 0, function () {\n            return P(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return [4, Je.ready()];\n\n                case 1:\n                  return e.sent() || (this._localCacheEnabled && this._backgroundSync.pause(), this._changelogSync.pause()), [2];\n              }\n            });\n          });\n        }\n      }, pe.of(this._iid).addObserver(this._connectionStateObserver);\n    }\n\n    return e.prototype._handleEvent = function (e) {\n      var t = this,\n          n = e.source,\n          r = e.payload,\n          i = U.get(this._iid),\n          s = new Te(n);\n\n      switch (n) {\n        case de.CHANNEL_BACKGROUND:\n          break;\n\n        case de.CHANNEL_CHANGELOG:\n          var a = r,\n              o = a.updatedChannels,\n              l = a.deletedChannelUrls,\n              u = o.filter(function (e) {\n            return t._filter.match(e);\n          });\n          this._addChannelsToView(u, {\n            context: s\n          }), this._removeChannelsFromView(l, {\n            context: s\n          });\n          break;\n\n        case de.EVENT_USER_DECLINED_INVITATION:\n          var c = i.get(\"currentUserId\"),\n              d = r,\n              h = d.channel;\n          d.invitee.userId === c ? this._removeChannelsFromView([h.url], {\n            context: s\n          }) : this._filter.match(h) ? this._addChannelsToView([h], {\n            context: s\n          }) : this._removeChannelsFromView([h.url], {\n            context: s\n          });\n          break;\n\n        case de.EVENT_USER_LEFT:\n          c = i.get(\"currentUserId\");\n          var p = r;\n          h = p.channel;\n          p.user.userId === c ? this._removeChannelsFromView([h.url], {\n            context: s\n          }) : this._filter.match(h) ? this._addChannelsToView([h], {\n            context: s\n          }) : this._removeChannelsFromView([h.url], {\n            context: s\n          });\n          break;\n\n        case de.EVENT_USER_BANNED:\n        case de.EVENT_USER_UNBANNED:\n          break;\n\n        case de.EVENT_USER_MUTED:\n        case de.EVENT_USER_UNMUTED:\n        case de.EVENT_TYPING_STATUS_UPDATED:\n        case de.EVENT_OPERATOR_UPDATED:\n        case de.EVENT_CHANNEL_METADATA_UPDATED:\n        case de.EVENT_CHANNEL_METADATA_DELETED:\n        case de.EVENT_CHANNEL_METACOUNTER_UPDATED:\n        case de.EVENT_CHANNEL_METACOUNTER_DELETED:\n          h = r.channel;\n          this._filter.match(h) ? this._addChannelsToView([h], {\n            context: s\n          }) : this._removeChannelsFromView([h.url], {\n            context: s\n          });\n          break;\n\n        case de.EVENT_READ_RECEIPT_UPDATED:\n        case de.EVENT_USER_RECEIVED_INVITATION:\n        case de.EVENT_USER_JOINED:\n        case de.EVENT_CHANNEL_FROZEN:\n        case de.EVENT_CHANNEL_UNFROZEN:\n        case de.EVENT_CHANNEL_HIDDEN:\n        case de.EVENT_CHANNEL_UNHIDDEN:\n        case de.EVENT_CHANNEL_CHANGED:\n          h = r.channel;\n          this._filter.match(h) ? this._addChannelsToView([h], {\n            context: s\n          }) : this._removeChannelsFromView([h.url], {\n            context: s\n          });\n          break;\n\n        case de.EVENT_CHANNEL_DELETED:\n          var f = r.channelUrl;\n\n          this._removeChannelsFromView([f], {\n            context: s\n          });\n\n      }\n    }, e.prototype._getRemoteChannels = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t, n, r;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return e = x.get(this._iid).GroupChannel, t = U.get(this._iid), [4, t.get(\"apiClient\").loadGroupChannelList(_R(_R({}, this._filter), {\n                order: this._order,\n                token: this._token,\n                limit: this._limit,\n                userIdsFilter: this._filter.userIdsFilter,\n                searchFilter: (s = this._filter.searchFilter, s.searchQuery && s.searchFields ? {\n                  search_query: s.searchQuery,\n                  search_fields: s.searchFields.join(\",\").toLocaleLowerCase()\n                } : {})\n              }))];\n\n            case 1:\n              return n = i.sent(), r = n.channels.map(function (t) {\n                return \"number\" == typeof n.ts && (t.ts = n.ts), e.upsert(t);\n              }), [4, bt.of(this._iid).upsert(r)];\n\n            case 2:\n              return i.sent(), [2, [r, n.next]];\n          }\n\n          var s;\n        });\n      });\n    }, e.prototype._addChannelsToView = function (e, t) {\n      void 0 === t && (t = {});\n\n      for (var n = t.context, r = void 0 === n ? null : n, i = [], s = [], a = 0, o = e; a < o.length; a++) {\n        var l = o[a],\n            u = ft(this._channels, l);\n\n        if (u < 0) {\n          i.push(l), (c = _t(this._channels, l, this._order)) === this._channels.length ? this._channels.push(l) : this._channels.splice(c, 0, l);\n        } else {\n          s.push(l), this._channels.splice(u, 1);\n\n          var c = _t(this._channels, l, this._order);\n\n          this._channels.splice(c, 0, l);\n        }\n      }\n\n      r && (i.length > 0 && this._eventHandler.onChannelsAdded(r, i), s.length > 0 && this._eventHandler.onChannelsUpdated(r, s));\n    }, e.prototype._removeChannelsFromView = function (e, t) {\n      void 0 === t && (t = {});\n\n      for (var n = t.context, r = void 0 === n ? null : n, i = [], s = 0, a = e; s < a.length; s++) {\n        var o = a[s],\n            l = this._channels.map(function (e) {\n          return e.url;\n        }).indexOf(o);\n\n        l >= 0 && (i.push(this._channels[l].url), this._channels.splice(l, 1));\n      }\n\n      return r && i.length > 0 && this._eventHandler.onChannelsDeleted(r, i), i;\n    }, Object.defineProperty(e.prototype, \"channelList\", {\n      get: function get() {\n        return this._channels;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"hasMore\", {\n      get: function get() {\n        return this._hasMore;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.loadMore = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t, n, r, i;\n        return P(this, function (s) {\n          switch (s.label) {\n            case 0:\n              return this._hasMore ? [4, Je.ready()] : [3, 5];\n\n            case 1:\n              return s.sent() ? [3, 3] : (J.debug(\"Group channel collection loadMore() from the cache.\"), e = bt.of(this._iid), t = e.getNextContainerToken(this._order, this._channels), [4, e.getNextChannels(this._filter, this._order, t, this._limit)]);\n\n            case 2:\n              return r = s.sent(), this._addChannelsToView(r), [2, r];\n\n            case 3:\n              return J.debug(\"Group channel collection loadMore() from the server.\"), [4, this._getRemoteChannels()];\n\n            case 4:\n              return n = s.sent(), r = n[0], i = n[1], this._token = i, this._token || (this._hasMore = !1), this._addChannelsToView(r), [2, r];\n\n            case 5:\n              return [2, []];\n          }\n        });\n      });\n    }, e.prototype.dispose = function () {\n      pe.of(this._iid).removeObserver(this._connectionStateObserver), this._localCacheEnabled && this._backgroundSync.pause(), this._changelogSync.pause(), ge.of(this._iid).removeObserver(this._eventObserver);\n    }, e.prototype.setGroupChannelCollectionHandler = function (e) {\n      this._eventHandler = e;\n    }, e.GroupChannelOrder = ot, e;\n  }(),\n      vt = {},\n      bt = function () {\n    function e(e) {\n      var t = e.iid,\n          n = e.collection,\n          r = void 0 === n ? null : n;\n      this._collection = null, this._pkIndex = Date.now(), this._lastFetchedPrimaryKey = Date.now(), this._iid = t, this._collection = r, vt[t] = this;\n    }\n\n    return e.of = function (e) {\n      return vt[e];\n    }, e.prototype._serialize = function (e) {\n      var t = this._createPk();\n\n      return e.cachedPrimaryKey = t, _R(_R({}, e.serialize()), {\n        lastMessageCreatedAt: e.lastMessage ? e.lastMessage.createdAt : -1,\n        pk: t\n      });\n    }, e.prototype._deserialize = function (e) {\n      return e ? x.get(this._iid).GroupChannel.buildFromSerializedData(e) : null;\n    }, Object.defineProperty(e.prototype, \"_localCacheEnabled\", {\n      get: function get() {\n        return U.get(this._iid).get(\"localCacheEnabled\");\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype._createPk = function () {\n      return this._pkIndex++;\n    }, e.prototype._fetch = function (e, t, n) {\n      return L(this, void 0, void 0, function () {\n        var r,\n            i,\n            s,\n            a,\n            o,\n            l,\n            u,\n            c = this;\n        return P(this, function (d) {\n          switch (d.label) {\n            case 0:\n              if (!this._localCacheEnabled) return [3, 2];\n\n              switch (r = Ue.LATEST_LAST_MESSAGE, t) {\n                case ot.CHANNEL_NAME_ALPHABETICAL:\n                  r = Ue.NAME_ALPHABETICAL;\n                  break;\n\n                case ot.CHRONOLOGICAL:\n                  r = Ue.CHRONOLOGICAL;\n                  break;\n\n                case ot.LATEST_LAST_MESSAGE:\n                  r = Ue.LATEST_LAST_MESSAGE;\n              }\n\n              return i = n.containerToken, s = i.lastMessageCreatedAt, a = i.createdAt, o = i.name, l = i.lastFetchedPrimaryKey, u = {\n                where: function where(n) {\n                  switch (t) {\n                    case ot.LATEST_LAST_MESSAGE:\n                      if (n.lastMessageCreatedAt > s) return !1;\n                      if (n.lastMessageCreatedAt === s && gt(l, n.pk) >= 0) return !1;\n\n                      if (n.lastMessageCreatedAt < 0) {\n                        if (n.createdAt > a) return !1;\n                        if (n.createdAt === a && gt(l, n.pk) >= 0) return !1;\n                      }\n\n                      break;\n\n                    case ot.CHANNEL_NAME_ALPHABETICAL:\n                      var r = n.name.localeCompare(o);\n                      if (r < 0) return !1;\n                      if (0 === r && gt(l, n.pk) >= 0) return !1;\n                      break;\n\n                    case ot.CHRONOLOGICAL:\n                      if (n.createdAt > a) return !1;\n                      if (n.createdAt === a && gt(l, n.pk) >= 0) return !1;\n                  }\n\n                  return e.match(c._deserialize(n));\n                },\n                index: r\n              }, [4, this._collection.query(u).fetch({\n                limit: n.limit\n              })];\n\n            case 1:\n              return [2, d.sent().map(function (e) {\n                return c._deserialize(e);\n              })];\n\n            case 2:\n              return [2, []];\n          }\n        });\n      });\n    }, e.prototype.getNextContainerToken = function (e, t) {\n      switch (e) {\n        case ot.LATEST_LAST_MESSAGE:\n          return t.length > 0 ? {\n            lastMessageCreatedAt: (n = t[t.length - 1]).lastMessage ? n.lastMessage.createdAt : -1,\n            createdAt: n.createdAt,\n            lastFetchedPrimaryKey: n.cachedPrimaryKey\n          } : {\n            lastMessageCreatedAt: Number.MAX_SAFE_INTEGER,\n            createdAt: Number.MAX_SAFE_INTEGER,\n            lastFetchedPrimaryKey: this._lastFetchedPrimaryKey\n          };\n\n        case ot.CHRONOLOGICAL:\n          return t.length > 0 ? {\n            createdAt: (n = t[t.length - 1]).createdAt,\n            lastFetchedPrimaryKey: n.cachedPrimaryKey\n          } : {\n            createdAt: Number.MAX_SAFE_INTEGER,\n            lastFetchedPrimaryKey: this._lastFetchedPrimaryKey\n          };\n\n        case ot.CHANNEL_NAME_ALPHABETICAL:\n          var n;\n          return t.length > 0 ? {\n            name: (n = t[t.length - 1]).name,\n            lastFetchedPrimaryKey: n.cachedPrimaryKey\n          } : {\n            name: \"\",\n            lastFetchedPrimaryKey: this._lastFetchedPrimaryKey\n          };\n      }\n    }, e.prototype.get = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return this._localCacheEnabled ? (t = this._deserialize, [4, this._collection.getByKey(e)]) : [3, 2];\n\n            case 1:\n              return [2, t.apply(this, [n.sent()])];\n\n            case 2:\n              return [2, null];\n          }\n        });\n      });\n    }, e.prototype.getNextChannels = function (e, t, n, r) {\n      return void 0 === r && (r = 100), L(this, void 0, void 0, function () {\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return [4, this._fetch(e, t, {\n                containerToken: n,\n                limit: r\n              })];\n\n            case 1:\n              return [2, i.sent()];\n          }\n        });\n      });\n    }, e.prototype.upsert = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t,\n            n = this;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return this._localCacheEnabled ? (t = e.map(function (e) {\n                return n._serialize(e);\n              }), [4, this._collection.upsertMany(t)]) : [3, 2];\n\n            case 1:\n              r.sent(), r.label = 2;\n\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.remove = function (e) {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return this._localCacheEnabled ? [4, this._collection.removeIf({\n                where: {\n                  url: {\n                    \"/in\": e\n                  }\n                }\n              })] : [3, 3];\n\n            case 1:\n              return t.sent(), [4, ji.getInstance(this._iid).clearCachedMessages(e)];\n\n            case 2:\n              t.sent(), t.label = 3;\n\n            case 3:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.clear = function () {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (e) {\n          switch (e.label) {\n            case 0:\n              return this._localCacheEnabled ? [4, this._collection.clear()] : [3, 2];\n\n            case 1:\n              e.sent(), e.label = 2;\n\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e;\n  }(),\n      Ct = function () {\n    function e() {\n      this.messageId = null, this.userId = null, this.key = null, this.operation = \"\", this.updatedAt = null;\n    }\n\n    return e.createFromJson = function (e) {\n      var t = parseInt(e.msg_id),\n          n = e.user_id,\n          r = e.operation,\n          i = e.reaction,\n          s = e.updated_at;\n\n      if (t && \"string\" == typeof n && \"string\" == typeof r && [\"add\", \"delete\"].indexOf(r.toLowerCase()) >= 0 && \"string\" == typeof i && i && \"number\" == typeof s) {\n        var a = new this();\n        return a.messageId = t, a.userId = n, a.key = i, a.operation = r.toLowerCase(), a.updatedAt = s, a;\n      }\n\n      return null;\n    }, e;\n  }(),\n      At = function At(e) {\n    return Object.keys(e).forEach(function (t) {\n      e[t] && \"object\" == typeof e[t] && At(e[t]);\n    }), Object.freeze(e);\n  },\n      Nt = function () {\n    function e() {}\n\n    return e.serialize = function (e, t) {\n      void 0 === t && (t = null);\n      var n = JSON.parse(JSON.stringify(e));\n      return t && t(n), At(n);\n    }, e.serializeWithoutFreeze = function (e, t) {\n      void 0 === t && (t = null);\n      var n = JSON.parse(JSON.stringify(e));\n      return t && t(n), n;\n    }, e.deserialize = function (e, t) {\n      void 0 === t && (t = null);\n      var n = JSON.parse(JSON.stringify(e));\n      return t && t(n), n;\n    }, e;\n  }(),\n      St = {\n    TIMESTAMP: \"timestamp\",\n    MESSAGE_ID: \"messageId\"\n  },\n      It = new WeakMap(),\n      Tt = function () {\n    function e(t) {\n      c(this, e), this.messageId = 0, this.messageType = e.MESSAGE_TYPE_BASE, this.channelUrl = \"\", this.data = null, this.customType = null, this.silent = !1, this.createdAt = 0, this.updatedAt = 0, this.channelType = null, this.metaArrays = [], this.reactions = [], this.mentionType = null, this.mentionedUsers = [], this.mentionedUserIds = [], this.mentionedMessageTemplate = null, this.sendingStatus = null, It.set(this, 0), this.parentMessageId = 0, this.parentMessageText = null, this.threadInfo = null, this.isReplyToChannel = !1, this.parentMessage = null, this.ogMetaData = null, this.isOperatorMessage = !1, this.appleCriticalAlertOptions = null, this.reqId = \"\", this._isAutoResendRegistered = !1, t && this.__update(t);\n    }\n\n    return h(e, [{\n      key: \"serialize\",\n      value: function value(e) {\n        var t = this;\n        return Nt.serialize(this, function (n) {\n          n.hasOwnProperty(\"_sender\") && (n.sender = n._sender, delete n._sender), n.hasOwnProperty(\"_isAutoResendRegistered\") && (n.isAutoResendRegistered = n._isAutoResendRegistered, delete n._isAutoResendRegistered), t.appleCriticalAlertOptions && (n.appleCriticalAlertOptions = t.appleCriticalAlertOptions.serialize()), e && e(n);\n        });\n      }\n    }, {\n      key: \"isIdentical\",\n      value: function value(e) {\n        return !(\"object\" !== u(e) || !e.hasOwnProperty(\"messageId\")) && (0 !== this.messageId && 0 !== e.messageId ? this.messageId === e.messageId : this.reqId === e.reqId);\n      }\n    }, {\n      key: \"isEqual\",\n      value: function value(e) {\n        return se.deepEqual(this, e);\n      }\n    }, {\n      key: \"isOpenChannel\",\n      value: function value() {\n        var e = x.get(this._iid).BaseChannel;\n        return this.channelType === e.CHANNEL_TYPE_OPEN;\n      }\n    }, {\n      key: \"isGroupChannel\",\n      value: function value() {\n        var e = x.get(this._iid).BaseChannel;\n        return this.channelType === e.CHANNEL_TYPE_GROUP;\n      }\n    }, {\n      key: \"isUserMessage\",\n      value: function value() {\n        return this.messageType === e.MESSAGE_TYPE_USER;\n      }\n    }, {\n      key: \"isAdminMessage\",\n      value: function value() {\n        return this.messageType === e.MESSAGE_TYPE_ADMIN;\n      }\n    }, {\n      key: \"isFileMessage\",\n      value: function value() {\n        return this.messageType === e.MESSAGE_TYPE_FILE;\n      }\n    }, {\n      key: \"__update\",\n      value: function value(e) {\n        var t = this,\n            n = ji.getInstance(this._iid),\n            r = x.get(this._iid),\n            i = r.User,\n            s = r.BaseChannel,\n            a = r.BaseMessageParams,\n            o = r.BaseMessage,\n            u = r.Reaction,\n            c = r.MessageMetaArray,\n            d = r.ThreadInfo,\n            h = r.OGMetaData,\n            p = r.AppleCriticalAlertOptions;\n        if (e.hasOwnProperty(\"msg_id\") && e.msg_id && (this.messageId = parseInt(e.msg_id)), e.hasOwnProperty(\"type\")) switch (e.type) {\n          case \"MESG\":\n            this.messageType = o.MESSAGE_TYPE_USER;\n            break;\n\n          case \"FILE\":\n            this.messageType = o.MESSAGE_TYPE_FILE;\n            break;\n\n          case \"BRDM\":\n          case \"ADMM\":\n            this.messageType = o.MESSAGE_TYPE_ADMIN;\n        }\n        e.hasOwnProperty(\"message_id\") && e.message_id && (this.messageId = parseInt(e.message_id)), this.channelUrl = e.hasOwnProperty(\"channel_url\") ? String(e.channel_url) : \"\", this.data = e.hasOwnProperty(\"data\") ? String(e.data) : \"\", this.customType = e.hasOwnProperty(\"custom_type\") ? String(e.custom_type) : \"\", e.hasOwnProperty(\"silent\") && (this.silent = e.silent), this.createdAt = e.hasOwnProperty(\"ts\") ? parseInt(e.ts) : 0, e.hasOwnProperty(\"created_at\") && (this.createdAt = parseInt(e.created_at)), this.updatedAt = e.hasOwnProperty(\"updated_at\") ? parseInt(e.updated_at) : 0, this.channelType = e.hasOwnProperty(\"channel_type\") ? String(e.channel_type) : s.CHANNEL_TYPE_GROUP;\n\n        var f = e.hasOwnProperty(\"metaarray\") ? e.metaarray : {},\n            _ = e.hasOwnProperty(\"metaarray_key_order\") ? e.metaarray_key_order : Object.keys(f).sort(function (e, t) {\n          return e.localeCompare(t);\n        });\n\n        this.metaArrays = [];\n\n        for (var g = 0; g < _.length; g++) {\n          var y = _[g];\n          this.metaArrays.push(new c(y, f[y] || []));\n        }\n\n        if (e.hasOwnProperty(\"sorted_metaarray\")) {\n          var m = e.sorted_metaarray;\n          Array.isArray(m) && (this.metaArrays = m.map(function (e) {\n            return new c(e.key, e.value);\n          }));\n        }\n\n        if (this.reactions = [], e.hasOwnProperty(\"reactions\") && Array.isArray(e.reactions)) for (var E = 0; E < e.reactions.length; E++) {\n          var v = u.createFromJson(e.reactions[E]);\n          v && this.reactions.push(v);\n        }\n        (this.mentionType = e.hasOwnProperty(\"mention_type\") ? e.mention_type : a.MentionType.USERS, this.mentionedUsers = [], e.hasOwnProperty(\"mentioned_users\")) && e.mentioned_users.forEach(function (e) {\n          var n = new i(e);\n          t.mentionedUsers.push(n);\n        });\n\n        if (this.mentionedUserIds = [], e.hasOwnProperty(\"mentioned_user_ids\") && (this.mentionedUserIds = e.mentioned_user_ids), e.hasOwnProperty(\"mentioned_message_template\") && e.mentioned_message_template && (this.mentionedMessageTemplate = e.mentioned_message_template), this.sendingStatus = this.messageId > 0 ? n.MessageSendingStatus.SUCCEEDED : n.MessageSendingStatus.FAILED, e.hasOwnProperty(\"sending_status\") && (this.sendingStatus = e.sending_status), e.hasOwnProperty(\"root_message_id\") && e.root_message_id && It.set(this, parseInt(e.root_message_id)), e.hasOwnProperty(\"parent_message_id\") && e.parent_message_id && (this.parentMessageId = parseInt(e.parent_message_id)), this.threadInfo = new d(e.thread_info), this.isReplyToChannel = !!e.hasOwnProperty(\"is_reply_to_channel\") && e.is_reply_to_channel, e.hasOwnProperty(\"parent_message_info\")) {\n          var b = l({}, e.parent_message_info);\n          e.parent_message_info.hasOwnProperty(\"file\") && (b.require_auth = !!e.parent_message_info.file.require_auth);\n          var C = {\n            channelType: this.channelType,\n            channelUrl: this.channelUrl\n          };\n\n          switch (this.parentMessage = s.buildMessage(b, C), this.parentMessage.messageType) {\n            case o.MESSAGE_TYPE_USER:\n              this.parentMessageText = this.parentMessage.message;\n              break;\n\n            case o.MESSAGE_TYPE_FILE:\n              this.parentMessageText = this.parentMessage.name;\n          }\n        }\n\n        e.hasOwnProperty(\"og_tag\") && (this.ogMetaData = new h(e.og_tag)), e.hasOwnProperty(\"is_op_msg\") && (this.isOperatorMessage = e.is_op_msg), e.hasOwnProperty(\"apple_critical_alert_options\") && (this.appleCriticalAlertOptions = new p(e.apple_critical_alert_options)), e.hasOwnProperty(\"is_auto_resend_registered\") && (this._isAutoResendRegistered = e.is_auto_resend_registered), this.reqId = e.hasOwnProperty(\"req_id\") ? e.req_id : \"\";\n      }\n    }, {\n      key: \"getMetaArraysByKeys\",\n      value: function value(e) {\n        return Array.isArray(e) ? this.metaArrays.filter(function (t) {\n          return e.indexOf(t.key) > -1;\n        }) : [];\n      }\n    }, {\n      key: \"metaArray\",\n      get: function get() {\n        var e = {};\n        return this.metaArrays.forEach(function (t) {\n          e[t.key] = t.value;\n        }), e;\n      },\n      set: function set(e) {\n        if (\"object\" === u(e) && e) {\n          var t = x.get(this._iid).MessageMetaArray,\n              n = [];\n          Object.keys(e).forEach(function (r) {\n            n.push(new t(r, e[r]));\n          }), this.metaArrays = n;\n        }\n      }\n    }, {\n      key: \"getMetaArrayByKeys\",\n      value: function value(e) {\n        var t = {};\n        return this.getMetaArraysByKeys(e).forEach(function (e) {\n          t[e.key] = e.value;\n        }), t;\n      }\n    }, {\n      key: \"applyReactionEvent\",\n      value: function value(e) {\n        var t = this,\n            n = x.get(this._iid),\n            r = n.Reaction,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: Ct,\n          constraint: function constraint(e) {\n            return parseInt(e.messageId) === parseInt(t.messageId);\n          }\n        })]),\n            a = C(s, 2);\n\n        if (i = a[0], e = a[1], !i) {\n          for (var o = !1, l = 0; l < this.reactions.length; l++) {\n            if (this.reactions[l].key === e.key) {\n              this.reactions[l]._applyEvent(e), this.reactions[l].isEmpty && this.reactions.splice(l, 1), o = !0;\n              break;\n            }\n          }\n\n          o || \"add\" !== e.operation || this.reactions.push(new r(e.key, [e.userId], e.updatedAt));\n        }\n      }\n    }, {\n      key: \"_getThreadedMessageList\",\n      value: function value(t, n, r, i) {\n        var s = this,\n            a = x.get(this._iid),\n            o = a.ThreadedMessageListParams,\n            u = null,\n            c = me.parse(arguments, [new me({\n          type: \"number\"\n        }), new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return Object.values(St).includes(e);\n          }\n        }), new me({\n          type: o,\n          constraint: function constraint(e) {\n            return e._validate();\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            d = C(c, 5);\n        return u = d[0], t = d[1], n = d[2], r = d[3], i = d[4], oe(this._iid, function (i) {\n          if (u) i(u, null);else {\n            var a = x.get(s._iid),\n                o = a.GroupChannel,\n                c = a.OpenChannel;\n            s.isGroupChannel() ? o.getChannel(s.channelUrl, T.INTERNAL_CALL, function (a, o) {\n              if (ji.getInstance(s._iid).getErrorFirstCallback()) {\n                var u = [a, o];\n                o = u[0], a = u[1];\n              }\n\n              o ? i(o, null) : U.get(s._iid).container.apiClient.getMessageList(l(l({\n                channel: a,\n                token: t,\n                tokenType: n\n              }, r), {}, {\n                shouldReverse: r.reverse,\n                parentMessageId: s.messageId,\n                includeThreadInfo: !0,\n                replyType: e.ReplyType.ALL\n              })).then(function (e) {\n                var t = x.get(s._iid).BaseChannel,\n                    n = e.messages.map(function (e) {\n                  return t.buildMessage(e, a);\n                }).filter(function (e) {\n                  return null !== e;\n                }),\n                    r = n.filter(function (e) {\n                  return e.messageId === s.messageId;\n                })[0],\n                    o = n.filter(function (e) {\n                  return e.parentMessageId === s.messageId;\n                });\n                i(null, {\n                  parentMessage: r,\n                  threadedReplies: o\n                });\n              }).catch(function (e) {\n                i(e, null);\n              });\n            }) : s.isOpenChannel() && c.getChannel(s.channelUrl, T.INTERNAL_CALL, function (a, o) {\n              if (ji.getInstance(s._iid).getErrorFirstCallback()) {\n                var u = [a, o];\n                o = u[0], a = u[1];\n              }\n\n              o ? i(o, null) : U.get(s._iid).container.apiClient.getMessageList(l(l({\n                channel: a,\n                token: t,\n                tokenType: n\n              }, r), {}, {\n                shouldReverse: r.reverse,\n                parentMessageId: s.messageId,\n                includeThreadInfo: !0,\n                replyType: e.ReplyType.ALL\n              })).then(function (e) {\n                var t = x.get(s._iid).BaseChannel,\n                    n = e.messages.map(function (e) {\n                  return t.buildMessage(e, a);\n                }).filter(function (e) {\n                  return null !== e;\n                }),\n                    r = n.filter(function (e) {\n                  return e.messageId === s.messageId;\n                })[0],\n                    o = n.filter(function (e) {\n                  return e.parentMessageId === s.messageId;\n                });\n                i(null, {\n                  parentMessage: r,\n                  threadedReplies: o\n                });\n              }).catch(function (e) {\n                i(e, null);\n              });\n            });\n          }\n        }, i);\n      }\n    }, {\n      key: \"getThreadedMessagesByTimestamp\",\n      value: function value(e, t, n) {\n        return this._getThreadedMessageList(e, St.TIMESTAMP, t, n);\n      }\n    }, {\n      key: \"applyThreadInfoUpdateEvent\",\n      value: function value(e) {\n        var t = this,\n            n = x.get(this._iid),\n            r = n.ThreadInfoUpdateEvent,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: r,\n          constraint: function constraint(e) {\n            return parseInt(e.targetMessageId) === parseInt(t.messageId);\n          }\n        })]),\n            a = C(s, 2);\n        return i = a[0], e = a[1], !i && (this.threadInfo = e.threadInfo, !0);\n      }\n    }, {\n      key: \"applyParentMessage\",\n      value: function value(e) {\n        if (this.parentMessageId === e.messageId) {\n          var t = this.parentMessage.updatedAt;\n          if (e.updatedAt >= t) return this.parentMessage = e, !0;\n        }\n\n        return !1;\n      }\n    }, {\n      key: \"_setRootMessageId\",\n      value: function value(e) {\n        It.set(this, e);\n      }\n    }], [{\n      key: \"MESSAGE_TYPE_BASE\",\n      get: function get() {\n        return \"base\";\n      }\n    }, {\n      key: \"MESSAGE_TYPE_ADMIN\",\n      get: function get() {\n        return \"admin\";\n      }\n    }, {\n      key: \"MESSAGE_TYPE_USER\",\n      get: function get() {\n        return \"user\";\n      }\n    }, {\n      key: \"MESSAGE_TYPE_FILE\",\n      get: function get() {\n        return \"file\";\n      }\n    }, {\n      key: \"SendingStatus\",\n      get: function get() {\n        return {\n          NONE: \"none\",\n          PENDING: \"pending\",\n          FAILED: \"failed\",\n          CANCELED: \"canceled\",\n          SUCCEEDED: \"succeeded\"\n        };\n      }\n    }, {\n      key: \"ReplyType\",\n      get: function get() {\n        return {\n          ALL: \"all\",\n          NONE: \"none\",\n          ONLY_REPLY_TO_CHANNEL: \"only_reply_to_channel\"\n        };\n      }\n    }, {\n      key: \"getMessage\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.BaseChannel,\n            s = r.MessageRetrievalParams,\n            a = null,\n            o = me.parse(arguments, [new me({\n          type: s,\n          constraint: function constraint(e) {\n            return e._validate();\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            u = C(o, 3);\n        return a = u[0], e = u[1], t = u[2], oe(this._iid, function (t) {\n          if (a) t(a, null);else {\n            var r = x.get(n._iid),\n                s = r.GroupChannel,\n                o = r.OpenChannel;\n\n            switch (e.channelType) {\n              case i.CHANNEL_TYPE_GROUP:\n                s.getChannel(e.channelUrl, T.INTERNAL_CALL, function (r, s) {\n                  if (ji.getInstance(n._iid).getErrorFirstCallback()) {\n                    var a = [r, s];\n                    s = a[0], r = a[1];\n                  }\n\n                  s ? t(s, null) : U.get(n._iid).container.apiClient.getMessage(l({\n                    channel: r\n                  }, e), function (e, n) {\n                    if (e) t(e, null);else {\n                      var s = i.buildMessage(n, r);\n                      t(null, s);\n                    }\n                  });\n                });\n                break;\n\n              case i.CHANNEL_TYPE_OPEN:\n                o.getChannel(e.channelUrl, T.INTERNAL_CALL, function (r, s) {\n                  if (ji.getInstance(n._iid).getErrorFirstCallback()) {\n                    var a = [r, s];\n                    s = a[0], r = a[1];\n                  }\n\n                  s ? t(s, null) : U.get(n._iid).container.apiClient.getMessage(l({\n                    channel: r\n                  }, e), function (e, n) {\n                    if (e) t(e, null);else {\n                      var s = i.buildMessage(n, r);\n                      t(null, s);\n                    }\n                  });\n                });\n            }\n          }\n        }, t);\n      }\n    }]), e;\n  }(),\n      Ot = function () {\n    function e(e) {\n      this.nickname = \"\", this.plainProfileUrl = \"\", this.userId = \"\", this.connectionStatus = \"\", this.lastSeenAt = null, this.metaData = {}, this.isActive = !0, this.friendDiscoveryKey = null, this.friendName = null, this._preferredLanguages = null, this.requireAuth = null, e && this.__update(e);\n    }\n\n    return e.objectify = function (e) {\n      var t = e.userId,\n          n = void 0 === t ? null : t,\n          r = e.nickname,\n          i = void 0 === r ? \"\" : r,\n          s = e.plainProfileUrl,\n          a = void 0 === s ? \"\" : s,\n          o = e.connectionStatus,\n          l = void 0 === o ? \"\" : o,\n          u = e.lastSeenAt,\n          c = void 0 === u ? 0 : u,\n          d = e.metaData,\n          h = void 0 === d ? {} : d,\n          p = e.isActive,\n          f = void 0 === p || p,\n          _ = e.friendDiscoveryKey,\n          g = void 0 === _ ? null : _,\n          y = e.friendName,\n          m = void 0 === y ? null : y,\n          E = e.preferredLanguages,\n          v = void 0 === E ? null : E,\n          b = e.requireAuth;\n      return {\n        user_id: n,\n        nickname: i,\n        profile_url: a,\n        is_online: l,\n        last_seen_at: c,\n        metadata: h,\n        is_active: f,\n        friend_discovery_key: g,\n        friend_name: m,\n        preferred_languages: v,\n        require_auth_for_profile_image: void 0 !== b && b\n      };\n    }, e.buildFromSerializedData = function (e) {\n      var t = x.get(this._iid).User,\n          n = Nt.deserialize(e);\n      return new t(t.objectify(n));\n    }, Object.defineProperty(e.prototype, \"preferredLanguages\", {\n      get: function get() {\n        return this._preferredLanguages;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.__update = function (t) {\n      var n = U.get(this._iid).container.auth;\n      t.hasOwnProperty(\"guest_id\") && (this.userId = t.guest_id), t.hasOwnProperty(\"user_id\") && (this.userId = t.user_id), t.hasOwnProperty(\"name\") && (this.nickname = t.name), t.hasOwnProperty(\"nickname\") && (this.nickname = t.nickname), t.hasOwnProperty(\"require_auth_for_profile_image\") ? this.requireAuth = t.require_auth_for_profile_image : this.requireAuth = null, (t.hasOwnProperty(\"image\") || t.hasOwnProperty(\"profile_url\")) && (this.plainProfileUrl = t.image || t.profile_url || \"\", Object.defineProperty(this, \"profileUrl\", {\n        value: this.requireAuth ? \"\".concat(this.plainProfileUrl, \"?auth=\").concat(n.eKey) : this.plainProfileUrl,\n        configurable: !0,\n        writable: !1\n      })), t.hasOwnProperty(\"is_online\") ? t.is_online === e.NON_AVAILABLE ? this.connectionStatus = e.NON_AVAILABLE : this.connectionStatus = t.is_online ? e.ONLINE : e.OFFLINE : this.connectionStatus = e.NON_AVAILABLE, t.hasOwnProperty(\"last_seen_at\") ? this.lastSeenAt = parseInt(t.last_seen_at) : this.lastSeenAt = 0, t.hasOwnProperty(\"metadata\") ? this.metaData = t.metadata : this.metaData = {}, t.hasOwnProperty(\"is_active\") ? this.isActive = void 0 === t.is_active || t.is_active : this.isActive = !0, t.hasOwnProperty(\"friend_discovery_key\") ? this.friendDiscoveryKey = t.friend_discovery_key : this.friendDiscoveryKey = null, t.hasOwnProperty(\"friend_name\") ? this.friendName = t.friend_name : this.friendName = null, t.hasOwnProperty(\"preferred_languages\") ? this._preferredLanguages = t.preferred_languages || null : this._preferredLanguages = null;\n    }, e.prototype._updateMetaData = function (e, t) {\n      var n = this;\n      void 0 === t && (t = !1);\n      var r = x.get(this._iid).GroupChannel;\n      Object.keys(e).forEach(function (r) {\n        t ? delete n.metaData[r] : n.metaData[r] = e[r];\n      }), Object.keys(r.cachedChannels).forEach(function (e) {\n        if (r.cachedChannels.hasOwnProperty(e)) {\n          var t = r.cachedChannels[e];\n          if (t.memberMap.hasOwnProperty(n.userId)) t.memberMap[n.userId].metaData = n.metaData;\n        }\n      });\n    }, e.prototype.serialize = function () {\n      return Nt.serialize(this, function (e) {\n        e.hasOwnProperty(\"_preferredLanguages\") && (e.preferredLanguages = e._preferredLanguages, delete e._preferredLanguages);\n      });\n    }, e.prototype.getOriginalProfileUrl = function () {\n      var e = \"\";\n\n      if (((e = (e = this.plainProfileUrl.indexOf(\"://\") > -1 ? this.plainProfileUrl.split(\"/\")[2] : this.plainProfileUrl.split(\"/\")[0]).split(\"?\")[0]).indexOf(\"sendbird.com\") > -1 || e.indexOf(\"sendbirdtest.com\") > -1 || e.indexOf(\"intoz.com\") > -1 || e.indexOf(\"file-local\") > -1) && this.plainProfileUrl.indexOf(e + \"/profile_images/\") > -1) {\n        var t = this.plainProfileUrl.replace(\"profile_images/\", \"\");\n        return t === this.plainProfileUrl ? \"\" : t;\n      }\n\n      return \"\";\n    }, e.prototype.createMetaData = function (e, t) {\n      var n,\n          r = this,\n          i = null;\n      return n = me.parse(arguments, [new me({\n        type: \"object\",\n        constraint: function constraint(e) {\n          return Object.keys(e).length > 0 && !Array.isArray(e);\n        }\n      }), new me({\n        type: \"callback\"\n      })]), i = n[0], e = n[1], t = n[2], oe(this._iid, function (t) {\n        i ? t(i, null) : U.get(r._iid).container.apiClient.createUserMetaData({\n          metaData: e\n        }, function (e, n) {\n          e || r._updateMetaData(n), t(e, n);\n        });\n      }, t);\n    }, e.prototype.updateMetaData = function (e, t, n) {\n      var r,\n          i = this,\n          s = null;\n      return r = me.parse(arguments, [new me({\n        type: \"object\",\n        constraint: function constraint(e) {\n          return !Array.isArray(e) && Object.keys(e).length > 0 && Object.keys(e).map(function (t) {\n            return e[t];\n          }).every(function (e) {\n            return \"string\" == typeof e;\n          });\n        }\n      }), new me({\n        type: \"boolean\",\n        optional: !0,\n        defaultValue: !1\n      }), new me({\n        type: \"callback\"\n      })]), s = r[0], e = r[1], t = r[2], n = r[3], oe(this._iid, function (n) {\n        s ? n(s, null) : U.get(i._iid).container.apiClient.updateUserMetaData({\n          metaData: e,\n          upsert: t\n        }, function (e, t) {\n          e || i._updateMetaData(t), n(e, t);\n        });\n      }, n);\n    }, e.prototype.deleteMetaData = function (e, t) {\n      var n,\n          r = this,\n          i = null;\n      return n = me.parse(arguments, [new me({\n        type: \"string\",\n        constraint: function constraint(e) {\n          return e.length > 0;\n        }\n      }), new me({\n        type: \"callback\"\n      })]), i = n[0], e = n[1], t = n[2], oe(this._iid, function (t) {\n        if (i) t(i, null);else {\n          var n = {};\n          n[e] = \"\", U.get(r._iid).container.apiClient.deleteUserMetaData({\n            metaDataKey: e\n          }, function (e, i) {\n            e || r._updateMetaData(n, !0), t(e, i);\n          });\n        }\n      }, t);\n    }, e.prototype.deleteAllMetaData = function (e) {\n      var t = this;\n      return oe(this._iid, function (e) {\n        var n = t.metaData;\n        U.get(t._iid).container.apiClient.deleteAllUserMetaData({}, function (r, i) {\n          r || t._updateMetaData(n, !0), e(r, i);\n        });\n      }, e);\n    }, Object.defineProperty(e, \"NON_AVAILABLE\", {\n      get: function get() {\n        return \"nonavailable\";\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e, \"ONLINE\", {\n      get: function get() {\n        return \"online\";\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e, \"OFFLINE\", {\n      get: function get() {\n        return \"offline\";\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e;\n  }(),\n      Ut = {\n    TIMESTAMP: \"timestamp\",\n    MESSAGE_ID: \"messageId\"\n  },\n      Mt = new WeakMap(),\n      kt = new WeakMap(),\n      Rt = function () {\n    function e(t) {\n      c(this, e), this.url = \"\", this.channelType = e.CHANNEL_TYPE_BASE, this.name = \"\", this.coverUrl = \"\", this.creator = null, this.createdAt = 0, this.data = null, this.customType = null, this.isFrozen = !1, this.isEphemeral = !1, Mt.set(this, {}), kt.set(this, \"\"), t && this.__update(t);\n    }\n\n    return h(e, [{\n      key: \"__update\",\n      value: function value(e) {\n        this.url = e.hasOwnProperty(\"channel_url\") ? String(e.channel_url) : \"\", this.name = e.hasOwnProperty(\"name\") ? String(e.name) : \"\", this.coverUrl = e.hasOwnProperty(\"cover_url\") ? String(e.cover_url) : \"\", this.createdAt = e.hasOwnProperty(\"created_at\") ? 1e3 * e.created_at : 0, this.data = e.hasOwnProperty(\"data\") ? String(e.data) : \"\", this.customType = e.hasOwnProperty(\"custom_type\") ? e.custom_type : \"\", this.isFrozen = !!e.hasOwnProperty(\"freeze\") && e.freeze, this.isEphemeral = !!e.hasOwnProperty(\"is_ephemeral\") && e.is_ephemeral, e.hasOwnProperty(\"created_by\") && null !== e.created_by && \"object\" === u(e.created_by) && Object.keys(e.created_by).length > 0 ? this.creator = new Ot(e.created_by) : this.creator = null, e.hasOwnProperty(\"metadata\") && null !== e.metadata && (e.hasOwnProperty(\"ts\") && \"number\" == typeof e.ts ? this._refreshMetaData(e.metadata, e.ts) : this._refreshMetaData(e.metadata, -1)), e.hasOwnProperty(\"cached_primary_key\") && (this.cachedPrimaryKey = e.cached_primary_key);\n      }\n    }, {\n      key: \"_addOrUpdateCachedMetaData\",\n      value: function value(e, t) {\n        var n = this,\n            r = Mt.get(this);\n        Object.keys(e).forEach(function (i) {\n          var s = r[i],\n              a = e[i];\n          s ? t > s.updatedAt && (s.value = a, s.updatedAt = t, s.isRemoved = !1) : r[i] = {\n            value: a,\n            updatedAt: t,\n            isRemoved: !1\n          }, bt.of(n._iid).upsert([n]).then(function () {}).catch(function (e) {\n            J.error(e);\n          });\n        });\n      }\n    }, {\n      key: \"_markAsDeletedCachedMetaData\",\n      value: function value(e, t) {\n        var n = this,\n            r = Mt.get(this);\n        e.forEach(function (e) {\n          var i = r[e];\n          i ? t > i.updatedAt && (i.isRemoved = !0, i.updatedAt = t) : r[e] = {\n            value: null,\n            updatedAt: t,\n            isRemoved: !0\n          }, bt.of(n._iid).upsert([n]).then(function () {}).catch(function (e) {\n            J.error(e);\n          });\n        });\n      }\n    }, {\n      key: \"_refreshMetaData\",\n      value: function value(e, t) {\n        var n = {};\n        Object.keys(e).forEach(function (r) {\n          n[r] = {\n            value: e[r],\n            updatedAt: t,\n            isRemoved: !1\n          };\n        }), Mt.set(this, n);\n      }\n    }, {\n      key: \"_clearCachedMetaData\",\n      value: function value() {\n        Mt.set(this, {});\n      }\n    }, {\n      key: \"cachedPrimaryKey\",\n      get: function get() {\n        return kt.get(this);\n      },\n      set: function set(e) {\n        kt.set(this, e);\n      }\n    }, {\n      key: \"isGroupChannel\",\n      value: function value() {\n        var e = x.get(this._iid).BaseChannel;\n        return this.channelType === e.CHANNEL_TYPE_GROUP;\n      }\n    }, {\n      key: \"isOpenChannel\",\n      value: function value() {\n        var e = x.get(this._iid).BaseChannel;\n        return this.channelType === e.CHANNEL_TYPE_OPEN;\n      }\n    }, {\n      key: \"createOperatorListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).OperatorListQuery)(this);\n      }\n    }, {\n      key: \"createMessageListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).MessageListQuery)(this);\n      }\n    }, {\n      key: \"createPreviousMessageListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).PreviousMessageListQuery)(this);\n      }\n    }, {\n      key: \"createPollListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).PollListQuery)({\n          channelUrl: this.url\n        });\n      }\n    }, {\n      key: \"createPollVoterListQuery\",\n      value: function value(e, t) {\n        return new (0, x.get(this._iid).PollVoterListQuery)({\n          channelUrl: this.url,\n          pollId: e,\n          optionId: t\n        });\n      }\n    }, {\n      key: \"serialize\",\n      value: function value() {\n        var e = this;\n        return Nt.serialize(this, function (t) {\n          if (null !== t.lastMessage && \"object\" === u(t.lastMessage)) {\n            var n = t.lastMessage;\n            n.hasOwnProperty(\"_sender\") && (n.sender = n._sender, delete n._sender, t.lastMessage = n);\n          }\n\n          t.hasOwnProperty(\"_messageOffsetTimestamp\") && (t.messageOffsetTimestamp = t._messageOffsetTimestamp, delete t._messageOffsetTimestamp), t.metadata = e.getCachedMetaData(), e.cachedPrimaryKey && (t.cachedPrimaryKey = e.cachedPrimaryKey);\n        });\n      }\n    }, {\n      key: \"getMessageChangeLogsByTimestamp\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: \"number\",\n          constraint: function constraint(e) {\n            return e >= 0;\n          }\n        }), new me({\n          type: \"boolean\",\n          optional: !0,\n          defaultValue: !1\n        }), new me({\n          type: \"boolean\",\n          optional: !0,\n          defaultValue: !1\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 5);\n        return s = o[0], e = o[1], t = o[2], n = o[3], r = o[4], oe(this._iid, function (r) {\n          s ? r(s, null) : U.get(i._iid).container.apiClient.getMessageChangeLogs({\n            channelUrl: i.url,\n            ts: e,\n            token: null,\n            isOpenChannel: i.isOpenChannel(),\n            includeMetaArray: t,\n            includeReactions: n\n          }).then(function (e) {\n            var t = x.get(i._iid).BaseChannel,\n                n = {\n              updatedMessages: e.updated.map(function (e) {\n                return t.buildMessage(e, i);\n              }),\n              deletedMessageIds: e.deleted.map(function (e) {\n                return parseInt(e.message_id);\n              }),\n              hasMore: e.has_more,\n              token: e.next\n            };\n            r(null, n);\n          }).catch(function (e) {\n            r(e, null);\n          });\n        }, r);\n      }\n    }, {\n      key: \"getMessageChangeLogsByToken\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: \"string\",\n          nullable: !0\n        }), new me({\n          type: \"boolean\",\n          optional: !0,\n          defaultValue: !1\n        }), new me({\n          type: \"boolean\",\n          optional: !0,\n          defaultValue: !1\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 5);\n        return s = o[0], e = o[1], t = o[2], n = o[3], r = o[4], oe(this._iid, function (r) {\n          s ? r(s, null) : U.get(i._iid).container.apiClient.getMessageChangeLogs({\n            channelUrl: i.url,\n            ts: null,\n            token: e,\n            isOpenChannel: i.isOpenChannel(),\n            includeMetaArray: t,\n            includeReactions: n\n          }).then(function (e) {\n            var t = x.get(i._iid).BaseChannel,\n                n = {\n              updatedMessages: e.updated.map(function (e) {\n                return t.buildMessage(e, i);\n              }),\n              deletedMessageIds: e.deleted.map(function (e) {\n                return parseInt(e.message_id);\n              }),\n              hasMore: e.has_more,\n              token: e.next\n            };\n            r(null, n);\n          }).catch(function (e) {\n            r(e, null);\n          });\n        }, r);\n      }\n    }, {\n      key: \"getMessageChangeLogsSinceToken\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = x.get(this._iid),\n            s = i.BaseChannel,\n            a = i.MessageChangeLogsParams,\n            o = null,\n            u = me.parse(arguments, [new me({\n          type: \"string\",\n          nullable: !0\n        }), new me({\n          type: a,\n          constraint: function constraint(e) {\n            return e._validate();\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            c = C(u, 4);\n        return o = c[0], e = c[1], t = c[2], n = c[3], oe(this._iid, function (n) {\n          o ? n(o, null) : U.get(r._iid).container.apiClient.getMessageChangeLogs(l({\n            channelUrl: r.url,\n            ts: null,\n            token: e,\n            isOpenChannel: r.isOpenChannel()\n          }, t)).then(function (e) {\n            var t = {\n              updatedMessages: e.updated.map(function (e) {\n                return s.buildMessage(e, r);\n              }),\n              deletedMessageIds: e.deleted.map(function (e) {\n                return parseInt(e.message_id);\n              }),\n              hasMore: e.has_more,\n              token: e.next\n            };\n            n(null, t);\n          }).catch(function (e) {\n            n(e, null);\n          });\n        }, n);\n      }\n    }, {\n      key: \"getMessageChangeLogsSinceTimestamp\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = x.get(this._iid),\n            s = i.BaseChannel,\n            a = i.MessageChangeLogsParams,\n            o = null,\n            u = me.parse(arguments, [new me({\n          type: \"number\",\n          constraint: function constraint(e) {\n            return e >= 0;\n          }\n        }), new me({\n          type: a,\n          constraint: function constraint(e) {\n            return e._validate();\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            c = C(u, 4);\n        return o = c[0], e = c[1], t = c[2], n = c[3], oe(this._iid, function (n) {\n          o ? n(o, null) : U.get(r._iid).container.apiClient.getMessageChangeLogs(l({\n            channelUrl: r.url,\n            timestamp: e,\n            token: null,\n            isOpenChannel: r.isOpenChannel()\n          }, t)).then(function (e) {\n            var t = {\n              updatedMessages: e.updated.map(function (e) {\n                return s.buildMessage(e, r);\n              }),\n              deletedMessageIds: e.deleted.map(function (e) {\n                return parseInt(e.message_id);\n              }),\n              hasMore: e.has_more,\n              token: e.next\n            };\n            n(null, t);\n          }).catch(function (e) {\n            n(e, null);\n          });\n        }, n);\n      }\n    }, {\n      key: \"getMyMutedInfo\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          var n = ji.getInstance(t._iid);\n          U.get(t._iid).container.apiClient.getMyMutedInfo({\n            channelUrl: t.url,\n            userId: n.currentUser ? n.currentUser.userId : null,\n            isGroupChannel: t.isGroupChannel()\n          }, function (t, n) {\n            var r = null;\n            t || (r = {\n              isMuted: n.is_muted,\n              startAt: n.start_at,\n              endAt: n.end_at,\n              remainingDuration: n.remaining_duration,\n              description: n.description\n            }), e(t, r);\n          });\n        }, e);\n      }\n    }, {\n      key: \"_parseMessageListParams\",\n      value: function value(e) {\n        for (var t = x.get(this._iid), n = t.MessageListParams, r = new n(), i = null, s = !1, a = 0, o = 0, l = !1, u = \"\", c = \"\", d = null, h = !1, p = !1, f = null, _ = arguments.length, g = new Array(_ > 1 ? _ - 1 : 0), y = 1; y < _; y++) {\n          g[y - 1] = arguments[y];\n        }\n\n        switch (e) {\n          case \"prev\":\n            var m = me.parse(g, [new me({\n              type: \"number\"\n            }), new me({\n              type: \"boolean\"\n            }), new me({\n              type: \"number\"\n            }), new me({\n              type: \"boolean\"\n            }), new me({\n              type: \"string\"\n            }), new me({\n              type: \"string\"\n            }), new me({\n              type: \"array\",\n              optional: !0\n            }), new me({\n              type: \"boolean\",\n              optional: !0,\n              defaultValue: !1\n            }), new me({\n              type: \"boolean\",\n              optional: !0,\n              defaultValue: !1\n            }), new me({\n              type: \"callback\"\n            })]),\n                E = C(m, 11);\n            i = E[0], s = E[2], a = E[3], l = E[4], u = E[5], c = E[6], d = E[7], h = E[8], p = E[9], f = E[10];\n            break;\n\n          case \"next\":\n            var v = me.parse(g, [new me({\n              type: \"number\"\n            }), new me({\n              type: \"boolean\"\n            }), new me({\n              type: \"number\"\n            }), new me({\n              type: \"boolean\"\n            }), new me({\n              type: \"string\"\n            }), new me({\n              type: \"string\"\n            }), new me({\n              type: \"array\",\n              optional: !0\n            }), new me({\n              type: \"boolean\",\n              optional: !0,\n              defaultValue: !1\n            }), new me({\n              type: \"boolean\",\n              optional: !0,\n              defaultValue: !1\n            }), new me({\n              type: \"callback\"\n            })]),\n                b = C(v, 11);\n            i = b[0], s = b[2], o = b[3], l = b[4], u = b[5], c = b[6], d = b[7], h = b[8], p = b[9], f = b[10];\n            break;\n\n          case \"prevnext\":\n            var A = me.parse(g, [new me({\n              type: \"number\"\n            }), new me({\n              type: \"number\"\n            }), new me({\n              type: \"number\"\n            }), new me({\n              type: \"boolean\"\n            }), new me({\n              type: \"string\"\n            }), new me({\n              type: \"string\"\n            }), new me({\n              type: \"array\",\n              optional: !0\n            }), new me({\n              type: \"boolean\",\n              optional: !0,\n              defaultValue: !1\n            }), new me({\n              type: \"boolean\",\n              optional: !0,\n              defaultValue: !1\n            }), new me({\n              type: \"callback\"\n            })]),\n                N = C(A, 11);\n            i = N[0], a = N[2], o = N[3], l = N[4], u = N[5], c = N[6], d = N[7], h = N[8], p = N[9], f = N[10], s = !0;\n        }\n\n        return i ? [null, f] : (r.isInclusive = s, r.prevResultSize = a, r.nextResultSize = o, r.reverse = l, r.messageType = u, r.customType = c, \"\" === r.customType && (r.customType = \"*\"), r.senderUserIds = d, r.includeMetaArray = h, r.includeReactions = p, [r, f]);\n      }\n    }, {\n      key: \"_getMessageList\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = x.get(this._iid),\n            a = s.MessageListParams,\n            o = null,\n            u = me.parse(arguments, [new me({\n          type: \"number\"\n        }), new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return Object.values(Ut).includes(e);\n          }\n        }), new me({\n          type: a,\n          constraint: function constraint(e) {\n            return e._validate();\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            c = C(u, 5);\n        return o = c[0], e = c[1], t = c[2], n = c[3], r = c[4], oe(this._iid, function (r) {\n          o ? r(o, null) : U.get(i._iid).container.apiClient.getMessageList(l(l({\n            channel: i,\n            token: e,\n            tokenType: t\n          }, n), {}, {\n            shouldReverse: n.reverse\n          })).then(function (e) {\n            var t = x.get(i._iid).BaseChannel,\n                n = e.messages.map(function (e) {\n              return t.buildMessage(e, i);\n            }).filter(function (e) {\n              return null !== e;\n            });\n            r(null, n);\n          }).catch(function (e) {\n            r(e, null);\n          });\n        }, r);\n      }\n    }, {\n      key: \"getPreviousMessagesByTimestamp\",\n      value: function value(e) {\n        var t = this._parseMessageListParams.apply(this, [\"prev\"].concat(A(me.toArray(arguments)))),\n            n = C(t, 2),\n            r = n[0],\n            i = n[1];\n\n        return this._getMessageList(e, Ut.TIMESTAMP, r, i);\n      }\n    }, {\n      key: \"getNextMessagesByTimestamp\",\n      value: function value(e) {\n        var t = this._parseMessageListParams.apply(this, [\"next\"].concat(A(me.toArray(arguments)))),\n            n = C(t, 2),\n            r = n[0],\n            i = n[1];\n\n        return this._getMessageList(e, Ut.TIMESTAMP, r, i);\n      }\n    }, {\n      key: \"getPreviousAndNextMessagesByTimestamp\",\n      value: function value(e) {\n        var t = this._parseMessageListParams.apply(this, [\"prevnext\"].concat(A(me.toArray(arguments)))),\n            n = C(t, 2),\n            r = n[0],\n            i = n[1];\n\n        return this._getMessageList(e, Ut.TIMESTAMP, r, i);\n      }\n    }, {\n      key: \"getPreviousMessagesByID\",\n      value: function value(e) {\n        var t = this._parseMessageListParams.apply(this, [\"prev\"].concat(A(me.toArray(arguments)))),\n            n = C(t, 2),\n            r = n[0],\n            i = n[1];\n\n        return this._getMessageList(e, Ut.MESSAGE_ID, r, i);\n      }\n    }, {\n      key: \"getNextMessagesByID\",\n      value: function value(e) {\n        var t = this._parseMessageListParams.apply(this, [\"next\"].concat(A(me.toArray(arguments)))),\n            n = C(t, 2),\n            r = n[0],\n            i = n[1];\n\n        return this._getMessageList(e, Ut.MESSAGE_ID, r, i);\n      }\n    }, {\n      key: \"getPreviousAndNextMessagesByID\",\n      value: function value(e) {\n        var t = this._parseMessageListParams.apply(this, [\"prevnext\"].concat(A(me.toArray(arguments)))),\n            n = C(t, 2),\n            r = n[0],\n            i = n[1];\n\n        return this._getMessageList(e, Ut.MESSAGE_ID, r, i);\n      }\n    }, {\n      key: \"getMessagesByTimestamp\",\n      value: function value(e, t, n) {\n        return this._getMessageList(e, Ut.TIMESTAMP, t, n);\n      }\n    }, {\n      key: \"getMessagesByMessageId\",\n      value: function value(e, t, n) {\n        return this._getMessageList(e, Ut.MESSAGE_ID, t, n);\n      }\n    }, {\n      key: \"_sendUserMessage\",\n      value: function value(e) {\n        var t = this,\n            n = e.reqId,\n            r = e.message,\n            i = e.data,\n            s = e.customType,\n            a = e.metaArrays,\n            o = e.mentionType,\n            u = e.mentionedUserIds,\n            c = e.mentionedUsers,\n            d = e.mentionedMessageTemplate,\n            h = e.pushNotificationDeliveryOption,\n            p = e.rootMessageId,\n            f = e.parentMessageId,\n            _ = e.translationTargetLanguages,\n            g = e.appleCriticalAlertOptions,\n            y = e.pollId,\n            m = e.silent,\n            E = void 0 !== m && m,\n            v = e.isReplyToChannel,\n            b = e.messageParams,\n            C = e.oldMessage,\n            A = void 0 === C ? null : C,\n            N = e.isManualResend,\n            S = void 0 !== N && N,\n            I = e.callback,\n            T = x.get(this._iid),\n            O = T.Command,\n            M = T.UserMessage,\n            k = ji.getInstance(this._iid),\n            R = Ge.of(this._iid),\n            L = bt.of(this._iid),\n            P = ge.of(this._iid),\n            w = U.get(this._iid).container.localCacheEnabled;\n        n || (n = O.generateRequestId());\n        var D = {};\n        Array.isArray(_) && _.forEach(function (e) {\n          return D[e] = \"\";\n        });\n        var F = M.objectify({\n          messageId: 0,\n          reqId: n,\n          user: k.currentUser || {},\n          channel: this,\n          message: r,\n          data: i,\n          customType: s,\n          metaArrays: a,\n          mentionType: o,\n          mentionedUserIds: u,\n          mentionedUsers: c,\n          mentionedMessageTemplate: d,\n          rootMessageId: p,\n          parentMessageId: f,\n          translations: D,\n          silent: E,\n          appleCriticalAlertOptions: g,\n          isReplyToChannel: v,\n          messageParams: b,\n          createdAt: new Date().getTime()\n        }),\n            G = new M(F);\n\n        if (G.requestState = k.MessageRequestState.PENDING, G.sendingStatus = k.MessageSendingStatus.PENDING, G.requestedMentionUserIds = u, G._messageParams = b, !k.currentUser) {\n          var j = new H(\"Connection should be made first.\", H.CONNECTION_REQUIRED),\n              B = new M(F);\n          return B.requestState = k.MessageRequestState.FAILED, B.sendingStatus = k.MessageSendingStatus.FAILED, B.requestedMentionUserIds = u, B.errorCode = j.code, I(j, B), G;\n        }\n\n        return (!t.isGroupChannel() || A && A._isAutoResendRegistered ? Promise.resolve() : R.upsert([G], fe.UNSENT).then(function () {\n          P.send({\n            source: S ? de.LOCAL_MESSAGE_RESEND_STARTED : de.LOCAL_MESSAGE_PENDING_CREATED,\n            payload: {\n              channel: t,\n              message: G\n            }\n          });\n        })).then(function () {\n          var e = O.bMessage({\n            channelUrl: t.url,\n            message: r,\n            data: i,\n            customType: s,\n            metaArrays: a,\n            mentionType: o,\n            mentionedUserIds: u,\n            mentionedMessageTemplate: d,\n            requestId: n,\n            rootMessageId: p,\n            parentMessageId: f,\n            silent: E,\n            translationTargetLanguages: _,\n            pushNotificationDeliveryOption: h,\n            appleCriticalAlertOptions: g,\n            pollId: y,\n            isReplyToChannel: v\n          });\n          (G.reqId = e.requestId, t.isGroupChannel() && k.getConnectionState() !== k.ConnectionState.OPEN && k.currentUser && !k.connecting && !k.reconnecting && \"string\" == typeof s && 0 === s.indexOf(\"SB_VIDEOCHAT\")) ? U.get(k._iid).container.apiClient.sendUserMessage({\n            channelUrl: t.url,\n            isOpenChannel: t.isOpenChannel(),\n            message: r,\n            data: i,\n            customType: s,\n            translationTargetLanguages: _,\n            metaArrays: a,\n            mentionType: o,\n            mentionedUserIds: u,\n            mentionedMessageTemplate: d,\n            pushNotificationDeliveryOption: h,\n            rootMessageId: p,\n            parentMessageId: f,\n            appleCriticalAlertOptions: g,\n            pollId: y,\n            isReplyToChannel: v\n          }, function (e, r) {\n            var i = null;\n\n            if (e) {\n              if (G._isAutoResendRegistered && se.isAutoResendableError(e.code)) return;\n              (i = new M(F)).requestState = k.MessageRequestState.FAILED, i.requestedMentionUserIds = u, A && (i._isAutoResendRegistered = A._isAutoResendRegistered), e.code === H.REQUEST_CANCELED ? (i.sendingStatus = k.MessageSendingStatus.CANCELED, R.removeUnsentMessages({\n                channelUrl: t.url,\n                sendingStatus: k.MessageSendingStatus.PENDING,\n                reqIds: [n]\n              }).then(function () {\n                P.send({\n                  source: de.LOCAL_MESSAGE_CANCELED,\n                  payload: {\n                    channel: t,\n                    message: i\n                  }\n                });\n              }).catch(function (e) {\n                return J.error(e);\n              }).finally(function () {\n                I && I(new H(e.message, e.code), i);\n              })) : (i.errorCode = e.code, i.sendingStatus = k.MessageSendingStatus.FAILED, w && se.isAutoResendableError(e.code) && (i.sendingStatus = k.MessageSendingStatus.PENDING, i.errorCode = 0, i._isAutoResendRegistered = !0), R.upsert([i], fe.UNSENT).then(function () {\n                nt._completeCurrentAndProcessNextAutoResend(k, i), P.send({\n                  source: de.LOCAL_MESSAGE_FAILED,\n                  payload: {\n                    channel: t,\n                    message: i\n                  }\n                });\n              }).catch(function (e) {\n                return J.error(e);\n              }).finally(function () {\n                var t = i._clone();\n\n                t.sendingStatus = k.MessageSendingStatus.FAILED, t.errorCode = e.code, t._isAutoResendRegistered = !1, I && I(new H(e.message, e.code), t);\n              }));\n            } else {\n              for (var s in (i = new M(r)).reqId = n, i.requestState = k.MessageRequestState.SUCCEEDED, i.sendingStatus = k.MessageSendingStatus.SUCCEEDED, A && (i._isAutoResendRegistered = A._isAutoResendRegistered), t.lastMessage = i, k.channelHandlers) {\n                k.channelHandlers[s].onChannelChanged(t);\n              }\n\n              L.upsert([t]).then(function () {\n                P.send({\n                  source: de.EVENT_CHANNEL_CHANGED,\n                  payload: {\n                    channel: t\n                  }\n                });\n              }).then(function () {\n                return R.removeUnsentMessages({\n                  channelUrl: t.url,\n                  sendingStatus: k.MessageSendingStatus.PENDING,\n                  reqIds: [n]\n                });\n              }).then(function () {\n                return R.upsert([i], fe.SUCCEEDED);\n              }).then(function () {\n                nt._completeCurrentAndProcessNextAutoResend(k, i), P.send({\n                  source: de.EVENT_MESSAGE_SENT,\n                  payload: {\n                    channel: t,\n                    message: i\n                  }\n                });\n              }).catch(function (e) {\n                return J.error(e);\n              }).finally(function () {\n                I && I(null, i);\n              });\n            }\n          }) : k.sendCommand(e, function (r, i) {\n            if (k.getErrorFirstCallback()) {\n              var s = [r, i];\n              i = s[0], r = s[1];\n            }\n\n            if (i) {\n              if (G._isAutoResendRegistered && se.isAutoResendableError(i.code)) return;\n              var a = new M(F);\n              a.reqId = e.requestId, a.requestState = k.MessageRequestState.FAILED, i.code === H.REQUEST_CANCELED ? (a.sendingStatus = k.MessageSendingStatus.CANCELED, t.isGroupChannel() && R.removeUnsentMessages({\n                channelUrl: t.url,\n                sendingStatus: k.MessageSendingStatus.PENDING,\n                reqIds: [n]\n              }).then(function () {\n                P.send({\n                  source: de.LOCAL_MESSAGE_CANCELED,\n                  payload: {\n                    channel: t,\n                    message: a\n                  }\n                });\n              }).catch(function (e) {\n                return J.error(e);\n              }).finally(function () {\n                I && I(new H(i.message, i.code), a);\n              })) : (a.sendingStatus = k.MessageSendingStatus.FAILED, a.errorCode = i.code, a.requestedMentionUserIds = u, t.isGroupChannel() ? (w && se.isAutoResendableError(i.code) && (a.sendingStatus = k.MessageSendingStatus.PENDING, a.errorCode = 0, a._isAutoResendRegistered = !0), R.upsert([a], fe.UNSENT).then(function () {\n                return nt._completeCurrentAndProcessNextAutoResend(k, a), P.send({\n                  source: de.LOCAL_MESSAGE_FAILED,\n                  payload: {\n                    channel: t,\n                    message: a\n                  }\n                });\n              }).catch(function (e) {\n                J.error(e);\n              }).finally(function () {\n                var e = a._clone();\n\n                e.sendingStatus = k.MessageSendingStatus.FAILED, e.errorCode = i.code, e._isAutoResendRegistered = !1, I && I(new H(i.message, i.code), e);\n              })) : I && I(new H(i.message, i.code), a));\n            } else {\n              var o = new M(l(l({}, r.getJsonElement()), {}, {\n                messageParams: b\n              }));\n              o.reqId = n, o.requestState = k.MessageRequestState.SUCCEEDED, o.sendingStatus = k.MessageSendingStatus.SUCCEEDED, A && (o._isAutoResendRegistered = A._isAutoResendRegistered);\n              var c = k.currentUser;\n\n              if (c && o._sender && c.userId === o._sender.userId && (c.nickname !== o._sender.nickname && (c.nickname = o._sender.nickname), c.plainProfileUrl !== o._sender.plainProfileUrl && (c.plainProfileUrl = o._sender.plainProfileUrl), se.deepEqual(c.metaData, o._sender.metaData) || (c.metaData = o._sender.metaData)), t.isGroupChannel()) {\n                t.lastMessage = o, Object.keys(k.channelHandlers).forEach(function (e) {\n                  k.channelHandlers[e].onChannelChanged(t);\n                });\n                var d = ge.of(t._iid);\n                bt.of(t._iid).upsert([t]).then(function () {\n                  d.send({\n                    source: de.EVENT_CHANNEL_CHANGED,\n                    payload: {\n                      channel: t\n                    }\n                  });\n                }).then(function () {\n                  return R.removeUnsentMessages({\n                    channelUrl: t.url,\n                    sendingStatus: k.MessageSendingStatus.PENDING,\n                    reqIds: [n]\n                  });\n                }).then(function () {\n                  return R.upsert([o], fe.SUCCEEDED);\n                }).then(function () {\n                  nt._completeCurrentAndProcessNextAutoResend(k, o), d.send({\n                    source: de.EVENT_MESSAGE_SENT,\n                    payload: {\n                      channel: t,\n                      message: o\n                    }\n                  });\n                }).catch(function (e) {\n                  J.error(e);\n                }).finally(function () {\n                  I && I(null, o);\n                });\n              } else I && I(null, o);\n            }\n          });\n        }), G;\n      }\n    }, {\n      key: \"sendUserMessage\",\n      value: function value() {\n        var e = me.toArray(arguments),\n            t = e.pop(),\n            n = null,\n            r = null,\n            i = x.get(this._iid),\n            s = i.UserMessageParams;\n        if (\"function\" == typeof t) {\n          if (e[0] instanceof s) null === (r = e[0]).data && (r.data = \"\"), null === r.customType && (r.customType = \"\");else if (\"string\" == typeof e[0]) switch ((r = new s()).message = e[0], e.length) {\n            case 1:\n              break;\n\n            case 2:\n              r.data = e[1] || \"\";\n              break;\n\n            case 3:\n              r.data = e[1] || \"\", r.customType = e[2] || \"\";\n              break;\n\n            case 4:\n              r.data = e[1] || \"\", r.customType = e[2] || \"\", r.translationTargetLanguages = Array.isArray(e[3]) ? e[3] : [e[3]];\n              break;\n\n            default:\n              n = me.error;\n          } else n = me.error;\n        } else n = me.error;\n        var a = U.get(this._iid),\n            o = a.container.isErrorFirstInCallback;\n        return !n && r._validate() && r.message ? this._sendUserMessage(l(l({}, r), {}, {\n          metaArrays: r.metaArrays,\n          mentionType: r.mentionType,\n          mentionedUserIds: r._mentionedUserIds,\n          mentionedUsers: r.mentionedUsers,\n          mentionedMessageTemplate: r.mentionedMessageTemplate,\n          rootMessageId: r.rootMessageId,\n          parentMessageId: r.parentMessageId,\n          translationTargetLanguages: r._translationTargetLanguages,\n          messageParams: r,\n          callback: function callback(e, n) {\n            o ? t(e, n) : t(n, e);\n          }\n        })) : (o ? t(me.error, null) : t(null, me.error), null);\n      }\n    }, {\n      key: \"_autoResendUserMessage\",\n      value: function value(e) {\n        var t = this,\n            n = ji.getInstance(this._iid);\n\n        if (n && n.currentUser) {\n          var r = e._messageParams;\n          return new Promise(function (n, i) {\n            return t._sendUserMessage(l(l({}, r), {}, {\n              reqId: e.reqId,\n              metaArrays: r.metaArrays,\n              mentionType: r.mentionType,\n              mentionedUserIds: r._mentionedUserIds,\n              rootMessageId: r.rootMessageId,\n              parentMessageId: r.parentMessageId,\n              translationTargetLanguages: r._translationTargetLanguages,\n              pushNotificationDeliveryOption: r.pushNotificationDeliveryOption,\n              messageParams: r,\n              oldMessage: e,\n              callback: function callback(e, t) {\n                e ? i(e) : n(t);\n              }\n            }));\n          });\n        }\n      }\n    }, {\n      key: \"_autoResendFileMessage\",\n      value: function value(e) {\n        var t = ji.getInstance(this._iid);\n\n        if (t && t.currentUser) {\n          var n = this._parsePendingFileMessage(e),\n              r = x.get(this._iid).FileMessageQueue;\n\n          r.create(this).addJob(new r.Job({\n            fileInfo: n,\n            pendingMessage: e._clone(),\n            requestId: e.reqId,\n            error: n.error,\n            response: null\n          }));\n        }\n      }\n    }, {\n      key: \"resendUserMessage\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.UserMessage,\n            s = r.UserMessageParams,\n            a = null,\n            o = me.parse(arguments, [new me({\n          type: i,\n          constraint: function constraint(e) {\n            return 0 === e.messageId && e.isResendable() && e.reqId && e.channelUrl === n.url && \"string\" == typeof e.message && \"string\" == typeof e.data && \"string\" == typeof e.customType && \"object\" === u(e.translations) && !Array.isArray(e.translations);\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            c = C(o, 3);\n        return a = c[0], e = c[1], t = c[2], oe(this._iid, function (t) {\n          if (a) a.message += \" Please check if the failed message is resend-able with `message.isResendable().`\", t(a, null);else {\n            var r = Object.keys(e.translations),\n                i = s.PushNotificationDeliveryOption.DEFAULT;\n\n            n._sendUserMessage(l(l({}, e), {}, {\n              mentionedUserIds: e.requestedMentionUserIds,\n              translationTargetLanguages: r,\n              pushNotificationDeliveryOption: i,\n              reqId: e.reqId,\n              messageParams: e._messageParams,\n              isManualResend: !0,\n              callback: t\n            }));\n          }\n        }, t);\n      }\n    }, {\n      key: \"updateUserMessage\",\n      value: function value(e, t, n, r, i) {\n        var s = this,\n            a = x.get(this._iid),\n            o = a.Command,\n            u = a.UserMessage,\n            c = a.UserMessageParams,\n            d = arguments,\n            h = null,\n            p = null;\n        if (\"number\" == typeof e) switch (d.length) {\n          case 3:\n            var f = me.parse(d, [new me({\n              type: \"number\"\n            }), new me({\n              type: c\n            }), new me({\n              type: \"callback\"\n            })]),\n                _ = C(f, 4);\n\n            h = _[0], e = _[1], p = _[2], i = _[3];\n            break;\n\n          case 5:\n            p = new c();\n            var g = me.parse(d, [new me({\n              type: \"number\"\n            }), new me({\n              type: \"string\",\n              nullable: !0\n            }), new me({\n              type: \"string\",\n              nullable: !0\n            }), new me({\n              type: \"string\",\n              nullable: !0\n            }), new me({\n              type: \"callback\"\n            })]),\n                y = C(g, 6);\n            h = y[0], e = y[1], t = y[2], n = y[3], r = y[4], i = y[5], p.message = t, p.data = n, p.customType = r;\n        }\n        return oe(this._iid, function (t) {\n          if (!h && p && p._validate()) {\n            var n = o.bUpdateUserMessage(l(l({\n              channelUrl: s.url,\n              messageId: e\n            }, p), {}, {\n              mentionType: p._mentionType,\n              mentionedUserIds: p._mentionedUserIds,\n              mentionedMessageTemplate: p.mentionedMessageTemplate\n            })),\n                r = ji.getInstance(s._iid);\n            r.sendCommand(n, function (e, n) {\n              if (r.getErrorFirstCallback()) {\n                var i = [e, n];\n                n = i[0], e = i[1];\n              }\n\n              var a = null;\n\n              if (!n && (a = new u(l(l({}, e.getJsonElement()), {}, {\n                messageParams: p\n              })), s.isGroupChannel())) {\n                var o = !1;\n                s.lastMessage ? (s.lastMessage.createdAt < a.createdAt || s.lastMessage.createdAt === a.createdAt && s.lastMessage.messageId === a.messageId && s.lastMessage.updatedAt < a.updatedAt) && (s.lastMessage = a, o = !0) : (s.lastMessage = a, o = !0);\n                var c = ge.of(s._iid);\n                if (!a.silent && o) Object.keys(r.channelHandlers).forEach(function (e) {\n                  r.channelHandlers[e].onChannelChanged(s);\n                }), bt.of(s._iid).upsert([s]).then(function () {\n                  c.send({\n                    source: de.EVENT_CHANNEL_CHANGED,\n                    payload: {\n                      channel: s\n                    }\n                  });\n                }).catch(function (e) {\n                  J.error(e);\n                });\n                Ge.of(s._iid).upsert([a], fe.SUCCEEDED).then(function () {\n                  c.send({\n                    source: de.EVENT_MESSAGE_UPDATED,\n                    payload: {\n                      channel: s,\n                      message: a\n                    }\n                  });\n                }).catch(function (e) {\n                  J.error(e);\n                });\n              }\n\n              t(n, a);\n            });\n          } else t(me.error, null);\n        }, i);\n      }\n    }, {\n      key: \"translateUserMessage\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = ji.getInstance(this._iid),\n            s = x.get(this._iid),\n            a = s.UserMessage,\n            o = null,\n            l = me.parse(arguments, [new me({\n          type: a,\n          constraint: function constraint(e) {\n            return e.channelUrl === r.url && e.sendingStatus === i.MessageSendingStatus.SUCCEEDED;\n          }\n        }), new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            u = C(l, 4);\n        return o = u[0], e = u[1], t = u[2], n = u[3], oe(this._iid, function (n) {\n          o ? n(o, null) : U.get(r._iid).container.apiClient.translateUserMessage({\n            channelUrl: r.url,\n            isOpenChannel: r.isOpenChannel(),\n            messageId: e.messageId,\n            translationTargetLanguages: t\n          }, function (e, t) {\n            var r = null;\n            e || (r = new a(t)), n(e, r);\n          });\n        }, n);\n      }\n    }, {\n      key: \"_parsePendingFileMessage\",\n      value: function value(e) {\n        var t = e._messageParams.serialize(),\n            n = t.data,\n            r = t.customType,\n            i = t.fileUrl,\n            s = t.thumbnailSizes,\n            a = t.mentionType,\n            o = t.mentionedUserIds,\n            l = t.metaArrays,\n            u = t.parentMessageId,\n            c = t.pushNotificationDeliveryOption,\n            d = e._messageParams;\n\n        return {\n          file: d.file ? d.file : i,\n          name: e.name,\n          type: e.type,\n          size: e.size,\n          data: n,\n          customType: r,\n          thumbnailSizes: s,\n          metaArrays: l,\n          mentionType: a,\n          mentionedUserIds: o,\n          pushNotificationDeliveryOption: c,\n          rootMessageId: u,\n          parentMessageId: u,\n          appleCriticalAlertOptions: d.appleCriticalAlertOptions,\n          messageParams: e._messageParams,\n          silent: e.silent,\n          error: null,\n          progressHandler: null,\n          callback: null\n        };\n      }\n    }, {\n      key: \"_parseFileMessageArguments\",\n      value: function value(e) {\n        var t = x.get(this._iid),\n            n = t.BaseMessageParams,\n            r = t.FileMessageParams,\n            i = {\n          reqId: null,\n          error: null,\n          file: null,\n          name: null,\n          type: null,\n          size: null,\n          data: \"\",\n          customType: \"\",\n          thumbnailSizes: [],\n          metaArrays: [],\n          mentionType: n.MentionType.USERS,\n          mentionedUserIds: [],\n          pushNotificationDeliveryOption: r.PushNotificationDeliveryOption.DEFAULT,\n          rootMessageId: null,\n          parentMessageId: null,\n          progressHandler: null,\n          silent: !1,\n          appleCriticalAlertOptions: null,\n          isReplyToChannel: !1,\n          messageParams: null,\n          callback: null\n        };\n        if (\"function\" == typeof e[e.length - 1] && (i.callback = e.pop()), \"function\" == typeof e[e.length - 1] && (i.progressHandler = e.pop()), e[0] instanceof r) i.reqId = e[0]._reqId, i.file = e[0].file || e[0].fileUrl, i.name = e[0].fileName, i.type = e[0].mimeType, i.size = e[0].fileSize, i.data = e[0].data, i.customType = e[0].customType, i.thumbnailSizes = e[0].thumbnailSizes, i.metaArrays = e[0].metaArrays, i.mentionType = e[0]._mentionType, i.mentionedUserIds = e[0]._mentionedUserIds, i.pushNotificationDeliveryOption = e[0].pushNotificationDeliveryOption ? e[0].pushNotificationDeliveryOption : r.PushNotificationDeliveryOption.DEFAULT, i.rootMessageId = e[0].rootMessageId, i.parentMessageId = e[0].parentMessageId, i.silent = e[0].silent, e[0]._validate() || (i.error = me.error), i.appleCriticalAlertOptions = e[0].appleCriticalAlertOptions, i.isReplyToChannel = e[0].isReplyToChannel, i.messageParams = e[0];else if (se.isFile(e[0]) || \"string\" == typeof e[0]) {\n          switch (i.file = e[0], e.length) {\n            case 1:\n              break;\n\n            case 2:\n              i.data = e[1];\n              break;\n\n            case 3:\n              i.data = e[1], i.customType = e[2];\n              break;\n\n            case 4:\n              i.data = e[1], i.customType = e[2], i.thumbnailSizes = e[3];\n              break;\n\n            case 5:\n              i.name = e[1], i.type = e[2], i.size = e[3], i.data = e[4];\n              break;\n\n            case 6:\n              i.name = e[1], i.type = e[2], i.size = e[3], i.data = e[4], i.customType = e[5];\n              break;\n\n            case 7:\n              i.name = e[1], i.type = e[2], i.size = e[3], i.data = e[4], i.customType = e[5], i.thumbnailSizes = e[6];\n          }\n\n          var s = C(me.parse([i.file, i.name, i.type, i.size, i.data, i.customType, i.thumbnailSizes], [new me({\n            type: [\"file\", \"string\"]\n          }), new me({\n            type: \"string\",\n            nullable: !0\n          }), new me({\n            type: \"string\",\n            nullable: !0\n          }), new me({\n            type: \"number\",\n            nullable: !0,\n            constraint: function constraint(e) {\n              return e >= 0;\n            }\n          }), new me({\n            type: \"string\",\n            nullable: !0\n          }), new me({\n            type: \"string\",\n            nullable: !0\n          }), new me({\n            type: \"array\"\n          })]), 8);\n          i.error = s[0], i.file = s[1], i.name = s[2], i.type = s[3], i.size = s[4], i.data = s[5], i.customType = s[6], i.thumbnailSizes = s[7];\n          var a = se.isFile(i.file);\n          a && (i.name = i.name || i.file.name, i.type = i.type || i.file.type, i.size = i.size || i.file.size), i.messageParams = {\n            mentionType: n.MentionType.USERS,\n            mentionedUserIds: i.mentionedUserIds,\n            cachedMentionedUsers: [],\n            cachedMentionedUserIds: [],\n            metaArrays: i.metaArrays,\n            parentMessageId: i.parentMessageId,\n            pushNotificationDeliveryOption: i.pushNotificationDeliveryOption,\n            appleCriticalAlertOptions: i.appleCriticalAlertOptions,\n            fileName: i.name,\n            mimeType: i.type,\n            fileSize: i.size,\n            data: i.data,\n            customType: i.customType,\n            isUpdate: !1,\n            file: a ? i.file : null,\n            fileUrl: a ? null : i.file,\n            thumbnailSizes: i.thumbnailSizes\n          };\n        } else i.error = me.error;\n        return se.isFile(i.file) && (i.name = i.name || i.file.name, i.type = i.type || i.file.type, i.size = i.size || i.file.size), i;\n      }\n    }, {\n      key: \"_createTempFileMessage\",\n      value: function value(e) {\n        try {\n          var t,\n              n = ji.getInstance(this._iid),\n              r = x.get(this._iid),\n              i = r.Command,\n              s = r.FileMessage,\n              a = l(l({}, e), {}, {\n            messageId: 0,\n            reqId: null !== (t = e.reqId) && void 0 !== t ? t : i.generateRequestId(),\n            user: n.currentUser || {},\n            channel: this,\n            plainUrl: \"string\" == typeof e.file ? e.file : \"\",\n            thumbnails: e.thumbnailSizes.map(function (e) {\n              return {\n                url: \"\",\n                plainUrl: \"\",\n                width: e.maxWidth,\n                height: e.maxHeight,\n                real_width: 0,\n                real_height: 0\n              };\n            }),\n            sendingStatus: n.MessageSendingStatus.PENDING,\n            createdAt: new Date().getTime()\n          }),\n              o = s.objectify(a);\n          return new s(o);\n        } catch (e) {\n          return null;\n        }\n      }\n    }, {\n      key: \"sendFileMessage\",\n      value: function value() {\n        var e = this,\n            t = me.toArray(arguments),\n            n = this._parseFileMessageArguments(t),\n            r = x.get(this._iid),\n            i = r.Command,\n            s = null,\n            a = i.generateRequestId();\n\n        n.error || ((s = this._createTempFileMessage(n)).requestedMentionUserIds = n.mentionedUserIds, a = s.reqId);\n        var o = ji.getInstance(this._iid);\n\n        if (o && o.currentUser || (n.error = new H(\"Connection should be made first.\", H.CONNECTION_REQUIRED)), this.isGroupChannel()) {\n          var l = Ge.of(this._iid),\n              u = ge.of(this._iid);\n          l.upsert([s], fe.UNSENT).then(function () {\n            u.send({\n              source: de.LOCAL_MESSAGE_PENDING_CREATED,\n              payload: {\n                channel: e,\n                message: s\n              }\n            });\n          });\n        }\n\n        var c = x.get(this._iid),\n            d = c.FileMessageQueue,\n            h = d.create(this);\n        return h.addJob(new d.Job({\n          fileInfo: n,\n          pendingMessage: s,\n          requestId: a,\n          error: n.error,\n          response: null\n        })), s;\n      }\n    }, {\n      key: \"sendFileMessages\",\n      value: function value(e) {\n        var t = this,\n            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n            r = n.progress ? n.progress : function () {},\n            i = n.sent ? n.sent : function () {},\n            s = n.complete ? n.complete : function () {};\n\n        if (Array.isArray(e) && e.length > 0 && e.length <= 20) {\n          var a = [];\n          return e.forEach(function (n, o) {\n            a.push(t.sendFileMessage(n, r, function (t, n) {\n              i(t, n), o === e.length - 1 && s(null);\n            }));\n          }), a;\n        }\n\n        return s(me.error), null;\n      }\n    }, {\n      key: \"resendFileMessage\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = x.get(this._iid),\n            s = i.FileMessage,\n            a = i.FileMessageParams,\n            o = null,\n            l = me.parse(arguments, [new me({\n          type: s,\n          constraint: function constraint(e) {\n            return 0 === e.messageId && e.isResendable() && e.reqId && e.channelUrl === r.url && Array.isArray(e.thumbnails);\n          }\n        }), new me({\n          type: \"file\",\n          optionalIf: function optionalIf(e) {\n            var t,\n                n,\n                r = !!e[0].plainUrl,\n                i = se.isFile(null === (t = e[0]) || void 0 === t || null === (n = t.messageParams) || void 0 === n ? void 0 : n.file);\n            return r || i;\n          },\n          defaultValue: null\n        }), new me({\n          type: \"callback\"\n        })]),\n            u = C(l, 4);\n        return o = u[0], e = u[1], t = u[2], n = u[3], oe(this._iid, function (n) {\n          if (o) o.message += \" Please check if the failed message is resend-able with `message.isResendable().`\", n(o, null);else {\n            var i,\n                s = new a();\n            s._reqId = e.reqId, e.plainUrl ? s.fileUrl = e.plainUrl : t ? s.file = t : se.isFile(null === (i = e.messageParams) || void 0 === i ? void 0 : i.file) && (s.file = e.messageParams.file), s.fileName = e.name, s.fileSize = e.size, s.mimeType = e.type, s.data = e.data, s.customType = e.customType, s.mentionType = e.mentionType, s.mentionedUserIds = e.requestedMentionUserIds, s.metaArrays = e.metaArrays, s.thumbnailSizes = e.thumbnails.map(function (e) {\n              return {\n                maxWidth: e.width,\n                maxHeight: e.height\n              };\n            }), s.appleCriticalAlertOptions = e.appleCriticalAlertOptions, r.sendFileMessage(s, n);\n          }\n        }, n);\n      }\n    }, {\n      key: \"updateFileMessage\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = x.get(this._iid),\n            a = s.Command,\n            o = s.FileMessage,\n            u = s.FileMessageParams,\n            c = arguments,\n            d = null,\n            h = null;\n        if (\"number\" == typeof e) switch (c.length) {\n          case 3:\n            var p = me.parse(c, [new me({\n              type: \"number\"\n            }), new me({\n              type: u\n            }), new me({\n              type: \"callback\"\n            })]),\n                f = C(p, 4);\n            d = f[0], e = f[1], h = f[2], r = f[3], h && (h._isUpdate = !0);\n            break;\n\n          case 4:\n            h = new u();\n\n            var _ = me.parse(c, [new me({\n              type: \"number\"\n            }), new me({\n              type: \"string\",\n              nullable: !0\n            }), new me({\n              type: \"string\",\n              nullable: !0\n            }), new me({\n              type: \"callback\"\n            })]),\n                g = C(_, 5);\n\n            d = g[0], e = g[1], t = g[2], n = g[3], r = g[4], h.data = t, h.customType = n, h._isUpdate = !0;\n        }\n        return oe(this._iid, function (t) {\n          if (!d && h && h._validate()) {\n            var n = a.bUpdateFileMessage(l(l({\n              channelUrl: i.url,\n              messageId: e\n            }, h), {}, {\n              mentionType: h._mentionType,\n              mentionedUserIds: h._mentionedUserIds\n            })),\n                r = ji.getInstance(i._iid);\n            r.sendCommand(n, function (e, n) {\n              if (r.getErrorFirstCallback()) {\n                var s = [e, n];\n                n = s[0], e = s[1];\n              }\n\n              var a = null;\n\n              if (!n && (a = new o(l(l({}, e.getJsonElement()), {}, {\n                messageParams: h\n              })), i.isGroupChannel())) {\n                var u = !1;\n                i.lastMessage ? (i.lastMessage.createdAt < a.createdAt || i.lastMessage.createdAt === a.createdAt && i.lastMessage.messageId === a.messageId && i.lastMessage.updatedAt < a.updatedAt) && (i.lastMessage = a, u = !0) : (i.lastMessage = a, u = !0);\n                var c = ge.of(i._iid);\n                if (!a.silent && u) Object.keys(r.channelHandlers).forEach(function (e) {\n                  r.channelHandlers[e].onChannelChanged(i);\n                }), bt.of(i._iid).upsert([i]).then(function () {\n                  c.send({\n                    source: de.EVENT_CHANNEL_CHANGED,\n                    payload: {\n                      channel: i\n                    }\n                  });\n                }).catch(function (e) {\n                  J.error(e);\n                });\n                Ge.of(i._iid).upsert([a], fe.SUCCEEDED).then(function () {\n                  c.send({\n                    source: de.EVENT_MESSAGE_UPDATED,\n                    payload: {\n                      channel: i,\n                      message: a\n                    }\n                  });\n                }).catch(function (e) {\n                  J.error(e);\n                });\n              }\n\n              t(n, a);\n            });\n          } else t(me.error, null);\n        }, r);\n      }\n    }, {\n      key: \"cancelUploadingFileMessage\",\n      value: function value(e, t) {\n        var n = null,\n            r = me.parse(arguments, [new me({\n          type: [\"number\", \"string\"]\n        }), new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 3);\n        n = i[0], e = i[1], t = i[2];\n        var s = U.get(this._iid),\n            a = s.container.isErrorFirstInCallback;\n        if (n) return a ? t(n, null) : t(null, n), !1;\n        var o = x.get(this._iid),\n            l = o.FileMessageQueue,\n            u = l.create(this);\n        return u.cancelUploadItemByRequestId(e, function (e, n) {\n          return a ? t(e, n) : t(n, e);\n        });\n      }\n    }, {\n      key: \"addReaction\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = ji.getInstance(this._iid),\n            s = x.get(this._iid),\n            a = s.ReactionEvent,\n            o = null,\n            u = me.parse(arguments, [new me({\n          type: Tt\n        }), new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            c = C(u, 4);\n        return o = c[0], e = c[1], t = c[2], n = c[3], oe(this._iid, function (n) {\n          o ? n(o, null) : e.sendingStatus === i.MessageSendingStatus.SUCCEEDED ? U.get(r._iid).container.apiClient.addReaction({\n            isGroupChannel: e.isGroupChannel(),\n            channelUrl: e.channelUrl,\n            messageId: e.messageId,\n            key: t\n          }, function (t, r) {\n            var i = null;\n            t || (i = a.createFromJson(l(l({}, r), {}, {\n              msg_id: e.messageId\n            }))), n(t, i);\n          }) : n(new H(\"Cannot add reaction to a non-succeeded message.\", H.REQUEST_FAILED), null);\n        }, n);\n      }\n    }, {\n      key: \"deleteReaction\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = ji.getInstance(this._iid),\n            s = x.get(this._iid),\n            a = s.ReactionEvent,\n            o = null,\n            u = me.parse(arguments, [new me({\n          type: Tt\n        }), new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            c = C(u, 4);\n        return o = c[0], e = c[1], t = c[2], n = c[3], oe(this._iid, function (n) {\n          o ? n(o, null) : e.sendingStatus === i.MessageSendingStatus.SUCCEEDED ? U.get(r._iid).container.apiClient.deleteReaction({\n            isGroupChannel: e.isGroupChannel(),\n            channelUrl: e.channelUrl,\n            messageId: e.messageId,\n            key: t\n          }, function (t, r) {\n            var i = null;\n            t || (i = a.createFromJson(l(l({}, r), {}, {\n              msg_id: e.messageId\n            }))), n(t, i);\n          }) : n(new H(\"Cannot remove reaction to a non-succeeded message.\", H.REQUEST_FAILED), null);\n        }, n);\n      }\n    }, {\n      key: \"deleteMessage\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return !Array.isArray(e) && null !== e && e.hasOwnProperty(\"messageId\");\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.deleteMessage({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            messageId: e.messageId\n          }, function (r, i) {\n            if (!r && n.isGroupChannel()) {\n              var s = Ge.of(n._iid),\n                  a = ge.of(n._iid);\n              s.remove([e.messageId], fe.SUCCEEDED).then(function () {\n                a.send({\n                  source: de.EVENT_MESSAGE_DELETED,\n                  payload: {\n                    channel: n,\n                    message: e\n                  }\n                });\n              }).catch(function (e) {\n                return J.error(e);\n              });\n            }\n\n            t(r, null);\n          });\n        }, t);\n      }\n    }, {\n      key: \"copyUserMessage\",\n      value: function value(t, n, r) {\n        var i = x.get(this._iid);\n        i.Command;\n        var s = i.UserMessage,\n            a = i.BaseMessageParams,\n            o = null,\n            u = me.parse(arguments, [new me({\n          type: e\n        }), new me({\n          type: s\n        }), new me({\n          type: \"callback\"\n        })]),\n            c = C(u, 4);\n        o = c[0], t = c[1], n = c[2], r = c[3];\n        var d = U.get(this._iid),\n            h = d.container.isErrorFirstInCallback;\n        if (o) return h ? r(me.error, null) : r(null, me.error), null;\n\n        if (this.url !== n.channelUrl) {\n          var p = new H(\"The message does not belong to this channel\", H.INVALID_PARAMETER);\n          return h ? r(p, null) : r(null, p), null;\n        }\n\n        var f = Object.keys(n.translations);\n        f.forEach(function (e) {\n          return \"\";\n        });\n        var _ = a.PushNotificationDeliveryOption.DEFAULT;\n        return t._sendUserMessage(l(l({}, n), {}, {\n          reqId: null,\n          pushNotificationDeliveryOption: _,\n          translationTargetLanguages: f,\n          rootMessageId: null,\n          parentMessageId: null,\n          parentMessageText: null,\n          messageParams: n._messageParams,\n          callback: r\n        }));\n      }\n    }, {\n      key: \"copyFileMessage\",\n      value: function value(t, n, r) {\n        var i = this,\n            s = x.get(this._iid),\n            a = s.Command;\n        s.GroupChannel;\n        var o = s.FileMessage,\n            l = s.BaseMessageParams;\n        s.FileMessageParams;\n        var u = s.User,\n            c = null,\n            d = me.parse(arguments, [new me({\n          type: e\n        }), new me({\n          type: o\n        }), new me({\n          type: \"callback\"\n        })]),\n            h = C(d, 4);\n        c = h[0], t = h[1], n = h[2], r = h[3];\n        var p = U.get(this._iid),\n            f = p.container.isErrorFirstInCallback;\n        if (c) return f ? r(me.error, null) : r(null, me.error), null;\n\n        if (this.url !== n.channelUrl) {\n          var _ = new H(\"The message does not belong to this channel\");\n\n          return f ? r(_, null) : r(null, _), null;\n        }\n\n        var g = ji.getInstance(this._iid),\n            y = n,\n            m = y.url,\n            E = y.name,\n            v = y.type,\n            b = y.size,\n            A = y.data,\n            N = y.customType,\n            S = y.mentionType,\n            I = y.mentionedUserIds,\n            T = y.mentionedUsers,\n            O = y.metaArrays,\n            M = y.thumbnails,\n            k = y.requireAuth,\n            R = y.messageSurvivalSeconds,\n            L = y.silent,\n            P = y.appleCriticalAlertOptions,\n            w = a.generateRequestId(),\n            D = g.currentUser || {},\n            F = t.url,\n            G = t.isOpenChannel(),\n            j = T.filter(function (e) {\n          return new u(u.objectify(e));\n        }),\n            B = l.PushNotificationDeliveryOption.DEFAULT,\n            V = o.objectify({\n          messageId: 0,\n          reqId: w,\n          user: D,\n          channel: t,\n          plainUrl: m,\n          name: E,\n          type: v,\n          size: b,\n          data: A,\n          customType: N,\n          mentionType: S,\n          mentionedUserIds: I,\n          mentionedUsers: j,\n          requestedMentionUserIds: I,\n          metaArrays: O,\n          thumbnails: M,\n          requireAuth: k,\n          messageSurvivalSeconds: R,\n          silent: L,\n          createdAt: new Date().getTime(),\n          appleCriticalAlertOptions: P\n        }),\n            q = new o(V);\n\n        if (q.requestState = g.MessageRequestState.PENDING, q.sendingStatus = g.MessageSendingStatus.PENDING, !g.currentUser) {\n          var K = new H(\"Connection should be made first.\", H.CONNECTION_REQUIRED),\n              z = new o(V);\n          return z.requestState = g.MessageRequestState.FAILED, z.sendingStatus = g.MessageSendingStatus.FAILED, z.errorCode = K.code, f ? r(K, z) : r(z, K), q;\n        }\n\n        var Y = a.bFile({\n          requestId: w,\n          channelUrl: F,\n          url: m,\n          name: E,\n          type: v,\n          size: b,\n          data: A,\n          customType: N,\n          metaArrays: O,\n          mentionType: S,\n          mentionedUserIds: I,\n          thumbnailSizes: M,\n          requireAuth: k,\n          pushNotificationDeliveryOption: B,\n          silent: L,\n          appleCriticalAlertOptions: P\n        });\n        return g.getConnectionState() === g.ConnectionState.OPEN || g.connecting || g.reconnecting ? g.sendCommand(Y, function (e, n) {\n          if (g.getErrorFirstCallback()) {\n            var s = [e, n];\n            n = s[0], e = s[1];\n          }\n\n          if (n) {\n            if (n.code !== H.INVALID_PARAMETER) {\n              var a = new o(V);\n              a.requestState = g.MessageRequestState.FAILED, a.sendingStatus = g.MessageSendingStatus.FAILED, n.code !== H.FILE_UPLOAD_CANCEL_FAILED && n.code !== H.REQUEST_CANCELED || (a.sendingStatus = g.MessageSendingStatus.CANCELED), a.errorCode = n.code, f ? r(n, a) : r(a, n);\n            } else f ? r(n, null) : r(null, n);\n          } else {\n            var l = new o(e.getJsonElement()),\n                u = l._sender;\n\n            if (D && u && D.userId === u.userId && (D.nickname !== u.nickname && (D.nickname = u.nickname), D.plainProfileUrl !== u.plainProfileUrl && (D.plainProfileUrl = u.plainProfileUrl)), t.isGroupChannel()) {\n              t.lastMessage = l, Object.keys(g.channelHandlers).forEach(function (e) {\n                g.channelHandlers[e].onChannelChanged(t);\n              });\n              var c = ge.of(i._iid);\n              bt.of(i._iid).upsert([t]).then(function () {\n                c.send({\n                  source: de.EVENT_CHANNEL_CHANGED,\n                  payload: {\n                    channel: t\n                  }\n                });\n              }).catch(function (e) {\n                J.error(e);\n              }), Ge.of(i._iid).upsert([l]).then(function () {\n                c.send({\n                  source: de.EVENT_MESSAGE_SENT,\n                  payload: {\n                    channel: i,\n                    message: l\n                  }\n                });\n              }).catch(function (e) {\n                J.error(e);\n              });\n            }\n\n            f ? r(null, l) : r(l, null);\n          }\n        }) : p.container.apiClient.sendFileMessage({\n          channelUrl: F,\n          isOpenChannel: G,\n          fileUrl: m,\n          fileName: E,\n          fileType: v,\n          fileSize: b,\n          data: A,\n          customType: N,\n          metaArrays: O,\n          mentionType: S,\n          mentionedUserIds: I,\n          thumbnailSizes: M,\n          requireAuth: k,\n          pushNotificationDeliveryOption: B,\n          appleCriticalAlertOptions: P\n        }, function (e, n) {\n          if (e) {\n            if (e.code !== H.INVALID_PARAMETER) {\n              var i = new o(commnad.getJsonElement());\n              i.requestState = g.MessageRequestState.FAILED, i.sendingStatus = g.MessageSendingStatus.FAILED, e.code !== H.FILE_UPLOAD_CANCEL_FAILED && e.code !== H.REQUEST_CANCELED || (i.sendingStatus = g.MessageSendingStatus.CANCELED), i.errorCode = e.code, f ? r(e, i) : r(i, e);\n            } else f ? r(e, null) : r(null, e);\n          } else {\n            var s = new o(n),\n                a = s._sender;\n            D && a && D.userId === a.userId && (D.nickname !== a.nickname && (D.nickname = a.nickname), D.plainProfileUrl !== a.plainProfileUrl && (D.plainProfileUrl = a.plainProfileUrl)), t.isGroupChannel() && (t.lastMessage = s, Object.keys(g.channelHandlers).forEach(function (e) {\n              g.channelHandlers[e].onChannelChanged(t);\n            })), f ? r(null, s) : r(s, null);\n          }\n        }), q;\n      }\n    }, {\n      key: \"addOperators\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return Object.keys(e).map(function (t) {\n              return e[t];\n            }).every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.addOperators({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            operatorUserIds: e\n          }, function (e, n) {\n            return t(e, n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"removeOperators\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return Object.keys(e).map(function (t) {\n              return e[t];\n            }).every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.removeOperators({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            operatorUserIds: e\n          }, function (e, n) {\n            return t(e, n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"getMetaCounters\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return Object.keys(e).map(function (t) {\n              return e[t];\n            }).every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.getMetaCounters({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            keys: e\n          }, function (e, n) {\n            return t(e, n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"getAllMetaCounters\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.getMetaCounters({\n            channelUrl: t.url,\n            isOpenChannel: t.isOpenChannel(),\n            keys: []\n          }, function (t, n) {\n            return e(t, n);\n          });\n        }, e);\n      }\n    }, {\n      key: \"createMetaCounters\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return e && !Array.isArray(e) && Object.keys(e).length > 0 && Object.keys(e).map(function (t) {\n              return e[t];\n            }).every(function (e) {\n              return \"number\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.createMetaCounters({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            metaCounter: e\n          }, function (e, n) {\n            return t(e, n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"updateMetaCounters\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return e && !Array.isArray(e) && Object.keys(e).length > 0 && Object.keys(e).map(function (t) {\n              return e[t];\n            }).every(function (e) {\n              return \"number\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"boolean\",\n          optional: !0,\n          defaultValue: !1\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return i = a[0], e = a[1], t = a[2], n = a[3], oe(this._iid, function (n) {\n          i ? n(i, null) : U.get(r._iid).container.apiClient.updateMetaCounters({\n            channelUrl: r.url,\n            isOpenChannel: r.isOpenChannel(),\n            metaCounter: e,\n            upsert: t,\n            mode: \"set\"\n          }, function (e, t) {\n            return n(e, t);\n          });\n        }, n);\n      }\n    }, {\n      key: \"increaseMetaCounters\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return e && !Array.isArray(e) && Object.keys(e).length > 0 && Object.keys(e).map(function (t) {\n              return e[t];\n            }).every(function (e) {\n              return \"number\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.updateMetaCounters({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            metaCounter: e,\n            upsert: !1,\n            mode: \"increase\"\n          }, function (e, n) {\n            return t(e, n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"decreaseMetaCounters\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return e && !Array.isArray(e) && Object.keys(e).length > 0 && Object.keys(e).map(function (t) {\n              return e[t];\n            }).every(function (e) {\n              return \"number\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.updateMetaCounters({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            metaCounter: e,\n            upsert: !1,\n            mode: \"decrease\"\n          }, function (e, n) {\n            var r = null;\n            e || (r = {}, Object.keys(n).forEach(function (e) {\n              r[e] = n[e];\n            })), t(e, r);\n          });\n        }, t);\n      }\n    }, {\n      key: \"deleteMetaCounter\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.deleteMetaCounter({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            key: e\n          }, function (e, n) {\n            return t(e, n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"deleteAllMetaCounters\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.deleteAllMetaCounters({\n            channelUrl: t.url,\n            isOpenChannel: t.isOpenChannel()\n          }, function (t, n) {\n            return e(t, n);\n          });\n        }, e);\n      }\n    }, {\n      key: \"getCachedMetaData\",\n      value: function value() {\n        var e = Mt.get(this),\n            t = {};\n        return Object.keys(e).forEach(function (n) {\n          var r = e[n];\n          r.isRemoved || (t[n] = r.value);\n        }), t;\n      }\n    }, {\n      key: \"getMetaData\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return Object.keys(e).map(function (t) {\n              return e[t];\n            }).every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.getMetaData({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            keys: e\n          }, function (e, r) {\n            if (r && r.ts) {\n              var i = r.metadata;\n              n._addOrUpdateCachedMetaData(i, r.ts), t(e, i);\n            } else t(e, r);\n          });\n        }, t);\n      }\n    }, {\n      key: \"getAllMetaData\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.getMetaData({\n            channelUrl: t.url,\n            isOpenChannel: t.isOpenChannel(),\n            keys: []\n          }, function (n, r) {\n            if (r && r.ts) {\n              var i = r.metadata;\n              t._refreshMetaData(i, r.ts), e(n, i);\n            } else e(n, r);\n          });\n        }, e);\n      }\n    }, {\n      key: \"createMetaData\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return e && !Array.isArray(e) && Object.keys(e).length > 0;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.createMetaData({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            metaData: e\n          }, function (e, n) {\n            t(e, n && n.ts ? n.metadata : n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"updateMetaData\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return e && !Array.isArray(e) && Object.keys(e).length > 0;\n          }\n        }), new me({\n          type: \"boolean\",\n          optional: !0,\n          defaultValue: !1\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return i = a[0], e = a[1], t = a[2], n = a[3], oe(this._iid, function (n) {\n          i ? n(i, null) : U.get(r._iid).container.apiClient.updateMetaData({\n            channelUrl: r.url,\n            isOpenChannel: r.isOpenChannel(),\n            metaData: e,\n            upsert: t\n          }, function (e, t) {\n            n(e, t && t.ts ? t.metadata : t);\n          });\n        }, n);\n      }\n    }, {\n      key: \"deleteMetaData\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.deleteMetaData({\n            channelUrl: n.url,\n            isOpenChannel: n.isOpenChannel(),\n            key: e\n          }, function (e, n) {\n            t(e, n && n.ts ? {} : n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"deleteAllMetaData\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.deleteAllMetaData({\n            channelUrl: t.url,\n            isOpenChannel: t.isOpenChannel()\n          }, function (t, n) {\n            return e(t, n && n.ts ? {} : n);\n          });\n        }, e);\n      }\n    }, {\n      key: \"_updateMessageMetaArray\",\n      value: function value(e, t, n, r) {\n        var i = this;\n        return oe(this._iid, function (r) {\n          var s = x.get(i._iid),\n              a = s.Command,\n              o = s.UserMessage,\n              l = s.FileMessage,\n              u = s.AdminMessage,\n              c = null;\n\n          if (t.isUserMessage() ? c = a.bUpdateUserMessage({\n            channelUrl: e,\n            messageId: t.messageId,\n            metaArrayParams: n\n          }) : t.isFileMessage() && (c = a.bUpdateFileMessage({\n            channelUrl: e,\n            messageId: t.messageId,\n            metaArrayParams: n\n          })), c) {\n            var d = ji.getInstance(i._iid);\n            d.sendCommand(c, function (e, n) {\n              if (d.getErrorFirstCallback()) {\n                var i = [e, n];\n                n = i[0], e = i[1];\n              }\n\n              var s = null;\n              n || (t.isUserMessage() ? s = new o(e.getJsonElement()) : t.isFileMessage() ? s = new l(e.getJsonElement()) : t.isAdminMessage() && (s = new u(e.getJsonElement()))), r(n, s);\n            });\n          } else r(me.error, null);\n        }, r);\n      }\n    }, {\n      key: \"createMessageMetaArrayKeys\",\n      value: function value(e, t, n) {\n        var r = x.get(this._iid),\n            i = r.MessageMetaArray,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: Tt\n        }), new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return \"string\" == typeof e && \"\" !== e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 4);\n        if (s = o[0], e = o[1], t = o[2], n = o[3], s) return oe(this._iid, function (e) {\n          e(s, null);\n        }, n);\n        var l = [];\n        if (Array.isArray(t)) for (var u = 0; u < t.length; u++) {\n          var c = t[u];\n          l.push(new i(c, []));\n        }\n        return this._updateMessageMetaArray(this.url, e, {\n          array: l.map(function (e) {\n            return e.encode();\n          }),\n          mode: \"add\",\n          upsert: !0\n        }, n);\n      }\n    }, {\n      key: \"deleteMessageMetaArrayKeys\",\n      value: function value(e, t, n) {\n        var r = x.get(this._iid),\n            i = r.MessageMetaArray,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: Tt\n        }), new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return \"string\" == typeof e && \"\" !== e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 4);\n        if (s = o[0], e = o[1], t = o[2], n = o[3], s) return oe(this._iid, function (e) {\n          e(s, null);\n        }, n);\n        var l = [];\n        if (Array.isArray(t)) for (var u = 0; u < t.length; u++) {\n          var c = t[u];\n          l.push(new i(c, []));\n        }\n        return this._updateMessageMetaArray(this.url, e, {\n          array: l.map(function (e) {\n            return e.encode();\n          }),\n          mode: \"remove\",\n          upsert: !0\n        }, n);\n      }\n    }, {\n      key: \"addMessageMetaArrayValues\",\n      value: function value(e, t, n) {\n        var r = x.get(this._iid),\n            i = r.MessageMetaArray,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: Tt\n        }), new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return e && (Array.isArray(e) && e.length > 0 && e.every(function (e) {\n              return e instanceof i;\n            }) || Object.keys(e).length > 0 && Object.keys(e).every(function (t) {\n              return Array.isArray(e[t]) && e[t].length > 0 && e[t].every(function (e) {\n                return \"string\" == typeof e && e.length > 0;\n              });\n            }));\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 4);\n        if (s = o[0], e = o[1], t = o[2], n = o[3], s) return oe(this._iid, function (e) {\n          e(s, null);\n        }, n);\n        var l = Array.isArray(t) ? t.map(function (e) {\n          return e.encode();\n        }) : Object.keys(t).map(function (e) {\n          return {\n            key: e,\n            value: t[e]\n          };\n        });\n        return this._updateMessageMetaArray(this.url, e, {\n          array: l,\n          mode: \"add\",\n          upsert: !0\n        }, n);\n      }\n    }, {\n      key: \"removeMessageMetaArrayValues\",\n      value: function value(e, t, n) {\n        var r = x.get(this._iid),\n            i = r.MessageMetaArray,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: Tt\n        }), new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return e && (Array.isArray(e) && e.length > 0 && e.every(function (e) {\n              return e instanceof i;\n            }) || Object.keys(e).length > 0 && Object.keys(e).every(function (t) {\n              return Array.isArray(e[t]) && e[t].length > 0 && e[t].every(function (e) {\n                return \"string\" == typeof e && e.length > 0;\n              });\n            }));\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 4);\n        if (s = o[0], e = o[1], t = o[2], n = o[3], s) return oe(this._iid, function (e) {\n          e(s, null);\n        }, n);\n        var l = Array.isArray(t) ? t.map(function (e) {\n          return e.encode();\n        }) : Object.keys(t).map(function (e) {\n          return {\n            key: e,\n            value: t[e]\n          };\n        });\n        return this._updateMessageMetaArray(this.url, e, {\n          array: l,\n          mode: \"remove\",\n          upsert: !0\n        }, n);\n      }\n    }, {\n      key: \"report\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = x.get(this._iid),\n            s = i.BaseChannel,\n            a = null,\n            o = me.parse(arguments, [new me({\n          type: s.ReportCategory\n        }), new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            l = C(o, 4);\n        return a = l[0], e = l[1], t = l[2], n = l[3], oe(this._iid, function (n) {\n          if (a) n(a, null);else {\n            var i = ji.getInstance(r._iid);\n            U.get(r._iid).container.apiClient.report({\n              channelUrl: r.url,\n              isOpenChannel: r.isOpenChannel(),\n              reportCategory: e,\n              reportingUserId: i.currentUser ? i.currentUser.userId : null,\n              reportDescription: t\n            }, function (e, t) {\n              n(e, null);\n            });\n          }\n        }, n);\n      }\n    }, {\n      key: \"reportUser\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = x.get(this._iid),\n            a = s.BaseChannel,\n            o = null,\n            l = me.parse(arguments, [new me({\n          type: Ot\n        }), new me({\n          type: a.ReportCategory\n        }), new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            u = C(l, 5);\n        return o = u[0], e = u[1], t = u[2], n = u[3], r = u[4], oe(this._iid, function (r) {\n          if (o) r(o, null);else {\n            var s = ji.getInstance(i._iid);\n            U.get(i._iid).container.apiClient.reportUser({\n              channelUrl: i.url,\n              isOpenChannel: i.isOpenChannel(),\n              reportCategory: t,\n              offendingUserId: e.userId,\n              reportingUserId: s.currentUser ? s.currentUser.userId : null,\n              reportDescription: n\n            }, function (e, t) {\n              r(e, null);\n            });\n          }\n        }, r);\n      }\n    }, {\n      key: \"reportMessage\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = x.get(this._iid),\n            a = s.BaseChannel,\n            o = null,\n            l = me.parse(arguments, [new me({\n          type: Tt\n        }), new me({\n          type: a.ReportCategory\n        }), new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            u = C(l, 5);\n        return o = u[0], e = u[1], t = u[2], n = u[3], r = u[4], oe(this._iid, function (r) {\n          if (o) r(o, null);else {\n            var s = ji.getInstance(i._iid);\n            U.get(i._iid).container.apiClient.reportMessage({\n              messageId: e.messageId,\n              channelUrl: i.url,\n              isOpenChannel: i.isOpenChannel(),\n              reportCategory: t,\n              offendingUserId: e.sender.userId,\n              reportingUserId: s.currentUser ? s.currentUser.userId : null,\n              reportDescription: n\n            }, function (e, t) {\n              r(e, null);\n            });\n          }\n        }, r);\n      }\n    }], [{\n      key: \"CHANNEL_TYPE_OPEN\",\n      get: function get() {\n        return \"open\";\n      }\n    }, {\n      key: \"CHANNEL_TYPE_GROUP\",\n      get: function get() {\n        return \"group\";\n      }\n    }, {\n      key: \"CHANNEL_TYPE_BASE\",\n      get: function get() {\n        return \"base\";\n      }\n    }, {\n      key: \"MessageTypeFilter\",\n      get: function get() {\n        return {\n          ALL: \"\",\n          USER: \"MESG\",\n          FILE: \"FILE\",\n          ADMIN: \"ADMM\"\n        };\n      }\n    }, {\n      key: \"ReportCategory\",\n      get: function get() {\n        return {\n          SPAM: \"spam\",\n          HARASSING: \"harassing\",\n          SUSPICIOUS: \"suspicious\",\n          INAPPROPRIATE: \"inappropriate\"\n        };\n      }\n    }, {\n      key: \"buildMessage\",\n      value: function value(e, t) {\n        var n = x.get(this._iid),\n            r = n.UserMessage,\n            i = n.FileMessage,\n            s = n.AdminMessage;\n        if (e) switch (e.hasOwnProperty(\"channel_type\") || (e.channel_type = t.channelType), e.type) {\n          case \"MESG\":\n            return new r(e);\n\n          case \"FILE\":\n            var a = e.file;\n            return new i(l(l({}, e), {}, {\n              url: String(a.url),\n              name: String(a.name),\n              type: String(a.type),\n              size: parseInt(a.size),\n              data: String(a.data)\n            }));\n\n          case \"BRDM\":\n          case \"ADMM\":\n            return new s(e);\n        }\n        return null;\n      }\n    }]), e;\n  }(),\n      Lt = function () {\n    function e(t) {\n      c(this, e), t && (this.category = t.hasOwnProperty(\"cat\") ? parseInt(t.cat) : 0, this.data = t.hasOwnProperty(\"data\") ? t.data : null, this.channelUrl = t.hasOwnProperty(\"channel_url\") ? String(t.channel_url) : \"\", this.channelType = t.hasOwnProperty(\"channel_type\") ? String(t.channel_type) : Rt.CHANNEL_TYPE_GROUP, this.channel = t.hasOwnProperty(\"channel\") ? t.channel : null);\n    }\n\n    return h(e, [{\n      key: \"isGroupChannel\",\n      value: function value() {\n        return this.channelType === Rt.CHANNEL_TYPE_GROUP;\n      }\n    }, {\n      key: \"isOpenChannel\",\n      value: function value() {\n        return this.channelType === Rt.CHANNEL_TYPE_OPEN;\n      }\n    }]), e;\n  }();\n\n  Lt.CATEGORY_NONE = 0, Lt.CATEGORY_CHANNEL_ENTER = 10102, Lt.CATEGORY_CHANNEL_EXIT = 10103, Lt.CATEGORY_USER_CHANNEL_MUTE = 10201, Lt.CATEGORY_USER_CHANNEL_UNMUTE = 10200, Lt.CATEGORY_USER_CHANNEL_BAN = 10601, Lt.CATEGORY_USER_CHANNEL_UNBAN = 10600, Lt.CATEGORY_CHANNEL_FREEZE = 10701, Lt.CATEGORY_CHANNEL_UNFREEZE = 10700, Lt.CATEGORY_TYPING_START = 10900, Lt.CATEGORY_TYPING_END = 10901, Lt.CATEGORY_CHANNEL_JOIN = 1e4, Lt.CATEGORY_CHANNEL_LEAVE = 10001, Lt.CATEGORY_CHANNEL_OPERATOR_UPDATE = 10002, Lt.CATEGORY_CHANNEL_INVITE = 10020, Lt.CATEGORY_CHANNEL_DECLINE_INVITE = 10022, Lt.CATEGORY_CHANNEL_PROP_CHANGED = 11e3, Lt.CATEGORY_CHANNEL_DELETED = 12e3, Lt.CATEGORY_CHANNEL_META_DATA_CHANGED = 11100, Lt.CATEGORY_CHANNEL_META_COUNTERS_CHANGED = 11200, Lt.CATEGORY_CHANNEL_HIDE = 13e3, Lt.CATEGORY_CHANNEL_UNHIDE = 13001;\n  var Pt = h(function e(t) {\n    c(this, e), t && (this.category = t.hasOwnProperty(\"cat\") ? parseInt(t.cat) : 0);\n  });\n  Pt.CATEGORY_USER_BLOCK = 20001, Pt.CATEGORY_USER_UNBLOCK = 2e4, Pt.CATEGORY_FRIEND_DISCOVERED = 20900;\n\n  var wt = function () {\n    function e(t) {\n      c(this, e), this.sb = t, this.cls = x.get(this.sb._iid);\n    }\n\n    return h(e, [{\n      key: \"onRawCommandReceived\",\n      value: function value(e) {\n        var t = this,\n            n = this.cls,\n            r = n.Command,\n            i = n.User,\n            s = n.Member,\n            a = n.RestrictedUser,\n            o = n.BaseChannel,\n            c = n.GroupChannel,\n            d = n.OpenChannel,\n            h = n.UserMessage,\n            p = n.FileMessage,\n            f = n.AdminMessage,\n            _ = n.BaseMessageParams,\n            g = n.ReactionEvent,\n            y = n.ReadStatus,\n            m = n.ThreadInfoUpdateEvent,\n            E = n.PollUpdateEvent,\n            v = n.PollVoteEvent,\n            b = n.RestrictionInfo,\n            C = U.get(this.sb._iid),\n            A = C.container,\n            N = A.pinger,\n            S = A.auth,\n            O = A.subscribedUnreadMessageCount,\n            M = A.sessionManager,\n            k = A.ackStateMap,\n            R = new r(e),\n            L = R.getJsonElement();\n\n        if (L.hasOwnProperty(\"unread_cnt\") && \"object\" === u(L.unread_cnt)) {\n          var P = !1,\n              w = L.unread_cnt.ts;\n          \"number\" == typeof w && w > O.ts && (O.all !== L.unread_cnt.all && (P = !0), O.all = L.unread_cnt.all >= 0 ? L.unread_cnt.all : 0, L.unread_cnt.custom_types && Object.keys(L.unread_cnt.custom_types).forEach(function (e) {\n            O.custom_types[e] !== L.unread_cnt.custom_types[e] && (P = !0), O.custom_types[e] = L.unread_cnt.custom_types[e];\n          }), P = P && O.ts > 0, O.ts = w), P && Object.keys(this.sb.userEventHandlers).forEach(function (e) {\n            t.sb.userEventHandlers[e].onTotalUnreadMessageCountUpdated(O.all, O.custom_types);\n          });\n        }\n\n        var D = R.requestId;\n\n        if (D) {\n          var F = k[D];\n\n          if (F) {\n            clearTimeout(F.timer);\n            var G = F.handler;\n            G && (\"EROR\" === R.command ? G(new H(L.message, L.code), null) : G(null, R)), k.hasOwnProperty(D) && delete k[D];\n          }\n        } else {\n          N && \"LOGI\" !== R.command && N.refreshTimer();\n          var x,\n              j = bt.of(this.sb._iid),\n              B = Ge.of(this.sb._iid),\n              V = ge.of(this.sb._iid);\n\n          switch (R.command) {\n            case \"LOGI\":\n              if (this.sb.loginTimer) if (clearTimeout(this.sb.loginTimer), this.sb.loginTimer = null, this.sb.onLoginTimerCancel = null, L.hasOwnProperty(\"error\")) this.sb.isSessionOpened = !1, this.sb.loginHandler(new H(L.message, L.code), null);else {\n                if (this.sb.isSessionOpened = !0, L.hasOwnProperty(\"key\") && (S.sessionKey = L.key), L.hasOwnProperty(\"ekey\") && (S.eKey = L.ekey), L.hasOwnProperty(\"user_id\") && (this.sb.currentUser = new i(L)), \"number\" == typeof L.ping_interval && L.ping_interval > 0 && C.set(\"pingInterval\", 1e3 * L.ping_interval), \"number\" == typeof L.pong_timeout && L.pong_timeout > 0 && C.set(\"pongTimeout\", 1e3 * L.pong_timeout), \"number\" == typeof L.login_ts) {\n                  var q = 1e3 * L.login_ts;\n                  C.set(\"connectedAt\", q);\n                  var K = C.container,\n                      z = K.firstConnectedAt,\n                      Y = K.localCacheEnabled,\n                      Q = K.store;\n\n                  if (!z) {\n                    var W = q;\n\n                    if (Y) {\n                      var X = (x = this.sb.currentUser.userId, \"sendbird:\".concat(x, \"@firstConnectedAt\"));\n                      Q.get(X).then(function (e) {\n                        e && (W = e.ts);\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      }).finally(function () {\n                        C.set(\"firstConnectedAt\", W);\n                      });\n                    } else C.set(\"firstConnectedAt\", W);\n                  }\n                }\n\n                if (L.hasOwnProperty(\"reconnect\") && \"object\" === u(L.reconnect)) {\n                  var Z = L.reconnect,\n                      $ = C.container.wsAdapter;\n                  Z.hasOwnProperty(\"interval\") && \"number\" == typeof Z.interval && ($.reconnectParams.interval = Z.interval), Z.hasOwnProperty(\"max_interval\") && \"number\" == typeof Z.max_interval && ($.reconnectParams.maxInterval = Z.max_interval), Z.hasOwnProperty(\"mul\") && \"number\" == typeof Z.mul && ($.reconnectParams.multiplier = Z.mul), Z.hasOwnProperty(\"retry_cnt\") && \"number\" == typeof Z.retry_cnt && ($.reconnectParams.retryCount = Z.retry_cnt);\n                }\n\n                \"number\" == typeof L.max_unread_cnt_on_super_group ? C.set(\"maxUnreadCountOfSuperGroupChannel\", L.max_unread_cnt_on_super_group) : C.set(\"maxUnreadCountOfSuperGroupChannel\", T.DEFAULT_MAX_UNREAD_COUNT_OF_SUPER_GROUP_CHANNEL), L.profile_image_encryption && C.set(\"profileImageEncryption\", !0), N && N.start(), L.hasOwnProperty(\"file_upload_size_limit\") && L.hasOwnProperty(\"premium_feature_list\") && L.hasOwnProperty(\"emoji_hash\") && C.set(\"appInfo\", new Ie(L)), L.hasOwnProperty(\"concurrent_call_limit\") && L.hasOwnProperty(\"back_off_delay\") && (C.set(\"concurrentCallLimit\", L.concurrent_call_limit), C.set(\"backOffDelay\", L.back_off_delay)), this.sb.loginHandler(null, this.sb.currentUser);\n              }\n              break;\n\n            case \"EXPR\":\n              var ee = new H(\"The session would be expired.\", L.reason || H.SESSION_KEY_EXPIRED);\n              M.refreshSessionIfExpiredError(ee).then(function () {}).catch(function () {});\n              break;\n\n            case \"MESG\":\n            case \"FILE\":\n            case \"BRDM\":\n            case \"ADMM\":\n              var te = null;\n\n              if (\"MESG\" === R.command ? te = new h(L) : \"FILE\" === R.command ? te = new p(L) : \"BRDM\" !== R.command && \"ADMM\" !== R.command || (te = new f(L)), te) {\n                var ne = this.sb.currentUser ? this.sb.currentUser.userId : null,\n                    re = te.silent,\n                    ie = !!L.force_update_last_message,\n                    ae = te._sender && te._sender.userId === ne;\n\n                if (te.isGroupChannel()) {\n                  var oe = c.cachedChannels.hasOwnProperty(te.channelUrl);\n                  c.getChannel(te.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var i = [e, n];\n                      n = i[0], e = i[1];\n                    }\n\n                    if (!n) {\n                      if (!C.container.appInfo.isSupergroupMackDisabled || !e.isSuper || e.isBroadcast) {\n                        var s = r.bMessageAck({\n                          channelUrl: te.channelUrl,\n                          messageId: te.messageId\n                        });\n                        t.sb.sendCommand(s);\n                      }\n\n                      if (e.isHidden = !1, e.hiddenState = c.HiddenState.UNHIDDEN, c.cachedChannels[e.url] = e, te._sender && e.memberMap.hasOwnProperty(te._sender.userId)) {\n                        var a = e.memberMap[te._sender.userId];\n                        a.nickname !== te._sender.nickname && (a.nickname = te._sender.nickname), a.plainProfileUrl !== te._sender.plainProfileUrl && (a.plainProfileUrl = te._sender.plainProfileUrl), se.deepEqual(a.metaData, te._sender.metaData) || (a.metaData = te._sender.metaData), a.isBlockedByMe !== te._sender.isBlockedByMe && (a.isBlockedByMe = te._sender.isBlockedByMe);\n                      }\n\n                      var o = t.sb.currentUser;\n                      o && ae && (o.nickname !== te._sender.nickname && (o.nickname = te._sender.nickname), o.plainProfileUrl !== te._sender.plainProfileUrl && (o.plainProfileUrl = te._sender.plainProfileUrl), se.deepEqual(o.metaData, te._sender.metaData) || (o.metaData = te._sender.metaData));\n                      var l = !1;\n                      if (te.mentionType === _.MentionType.CHANNEL) ae || (l = !0);else if (te.mentionType === _.MentionType.USERS) for (var u = 0; u < te.mentionedUsers.length; u++) {\n                        if (!ae && te.mentionedUsers[u].userId === ne) {\n                          l = !0;\n                          break;\n                        }\n                      }\n                      re && !ae || (e.isEphemeral || oe) && ((!e.lastMessage || e.lastMessage.createdAt < te.createdAt) && (e.lastMessage = te), ae || e._setGroupChannelUnreadCount(e.unreadMessageCount + 1, e.unreadMentionCount + (l ? 1 : 0))), ie && (!e.lastMessage || e.lastMessage.createdAt < te.createdAt) && (e.lastMessage = te), re && !ae || (j.upsert([e]).then(function () {\n                        V.send({\n                          source: de.EVENT_CHANNEL_CHANGED,\n                          payload: {\n                            channel: e\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      }), Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        t.sb.channelHandlers[n].onChannelChanged(e);\n                      })), Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        var r = t.sb.channelHandlers[n];\n                        r.onMessageReceived(e, te), l && r.onMentionReceived(e, te);\n                      }), B.upsert([te]).then(function () {\n                        V.send({\n                          source: de.EVENT_MESSAGE_RECEIVED,\n                          payload: {\n                            channel: e,\n                            message: te\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      });\n                    }\n                  });\n                } else te.isOpenChannel() && d.getChannel(te.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                  if (t.sb.getErrorFirstCallback()) {\n                    var r = [e, n];\n                    n = r[0], e = r[1];\n                  }\n\n                  if (!n) {\n                    var i = !1;\n                    if (te.mentionType === _.MentionType.CHANNEL) i = !0;else if (te.mentionType === _.MentionType.USERS) for (var s = 0; s < te.mentionedUsers.length; s++) {\n                      if (te.mentionedUsers[s].userId === ne) {\n                        i = !0;\n                        break;\n                      }\n                    }\n                    Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      var r = t.sb.channelHandlers[n];\n                      d.enteredChannels[e.url] && r.onMessageReceived(e, te), i && r.onMentionReceived(e, te);\n                    }), d.enteredChannels[e.url] && V.send({\n                      source: de.EVENT_MESSAGE_RECEIVED,\n                      payload: {\n                        channel: e,\n                        message: te\n                      }\n                    });\n                  }\n                });\n              }\n\n              break;\n\n            case \"MEDI\":\n            case \"FEDI\":\n            case \"AEDI\":\n              var le = null;\n\n              if (\"MEDI\" === R.command ? le = new h(L) : \"FEDI\" === R.command ? le = new p(L) : \"AEDI\" === R.command && (le = new f(L)), le) {\n                var ue = this.sb.currentUser ? this.sb.currentUser.userId : null,\n                    ce = le.silent,\n                    he = le.sender && le.sender.userId === ue;\n\n                if (le.isGroupChannel()) {\n                  var pe = c.cachedChannels.hasOwnProperty(le.channelUrl);\n                  c.getChannel(le.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    if (!n) {\n                      var i = e.cachedReadReceiptStatus[ue],\n                          s = i && i >= le.createAt,\n                          a = t.sb.currentUser;\n                      a && he && (a.nickname !== le._sender.nickname && (a.nickname = le._sender.nickname), a.plainProfileUrl !== le._sender.plainProfileUrl && (a.plainProfileUrl = le._sender.plainProfileUrl), se.deepEqual(a.metaData, le._sender.metaData) || (a.metaData = le._sender.metaData));\n                      var o = !1,\n                          l = !1;\n\n                      if (!he && !s && L && L.hasOwnProperty(\"old_values\")) {\n                        var u = L.old_values.mention_type || le.mentionType,\n                            c = L.old_values.mentioned_user_ids || le.mentionedUsers.map(function (e) {\n                          return e.userId;\n                        });\n\n                        if (u === _.MentionType.USERS && le.mentionType === _.MentionType.USERS) {\n                          for (var d = !1, h = !1, p = 0; p < c.length; p++) {\n                            if (c[p] === ue) {\n                              d = !0;\n                              break;\n                            }\n                          }\n\n                          for (var f = 0; f < le.mentionedUsers.length; f++) {\n                            if (le.mentionedUsers[f].userId === ue) {\n                              h = !0;\n                              break;\n                            }\n                          }\n\n                          !d && h && (l = !0, !ce && pe && (e._setGroupChannelUnreadCount(e.unreadMessageCount, e.unreadMentionCount + 1), o = !0));\n                        } else if (u === _.MentionType.USERS && le.mentionType === _.MentionType.CHANNEL) {\n                          for (var g = !1, y = 0; y < c.length; y++) {\n                            if (c[y] === ue) {\n                              g = !0;\n                              break;\n                            }\n                          }\n\n                          g || (l = !0, !ce && pe && (e._setGroupChannelUnreadCount(e.unreadMessageCount, e.unreadMentionCount + 1), o = !0));\n                        }\n                      }\n\n                      e.lastMessage ? e.lastMessage.createdAt < le.createdAt ? (e.lastMessage = le, o = !0) : e.lastMessage.createdAt === le.createdAt && e.lastMessage.messageId === le.messageId && (pe ? e.lastMessage.updatedAt < le.updatedAt && (e.lastMessage = le, o = !0) : o = !0) : (e.lastMessage = le, o = !0), ce && !he || !o || (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        t.sb.channelHandlers[n].onChannelChanged(e);\n                      }), j.upsert([e]).then(function () {\n                        V.send({\n                          source: de.EVENT_CHANNEL_CHANGED,\n                          payload: {\n                            channel: e\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      })), Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        var r = t.sb.channelHandlers[n];\n                        r.onMessageUpdated(e, le), l && r.onMentionReceived(e, le);\n                      }), B.upsert([le]).then(function () {\n                        V.send({\n                          source: de.EVENT_MESSAGE_UPDATED,\n                          payload: {\n                            channel: e,\n                            message: le\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      });\n                    }\n                  });\n                } else le.isOpenChannel() && d.getChannel(le.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                  if (t.sb.getErrorFirstCallback()) {\n                    var r = [e, n];\n                    n = r[0], e = r[1];\n                  }\n\n                  n || (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                    t.sb.channelHandlers[n].onMessageUpdated(e, le);\n                  }), V.send({\n                    source: de.EVENT_MESSAGE_UPDATED,\n                    payload: {\n                      channel: e,\n                      message: le\n                    }\n                  }));\n                });\n              }\n\n              break;\n\n            case \"DELM\":\n              var fe = String(L.channel_type),\n                  _e = String(L.channel_url),\n                  ye = parseInt(L.msg_id);\n\n              switch (fe) {\n                case o.CHANNEL_TYPE_GROUP:\n                  c.getChannel(_e, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\")) : (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onMessageDeleted(e, ye);\n                    }), B.remove([\"\".concat(ye)]).then(function () {\n                      V.send({\n                        source: de.EVENT_MESSAGE_DELETED,\n                        payload: {\n                          channel: e,\n                          messageId: ye\n                        }\n                      });\n                    }).catch(function (e) {\n                      t.handleCacheError(e);\n                    }));\n                  });\n                  break;\n\n                case o.CHANNEL_TYPE_OPEN:\n                  d.getChannel(_e, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\")) : (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onMessageDeleted(e, ye);\n                    }), V.send({\n                      source: de.EVENT_MESSAGE_DELETED,\n                      payload: {\n                        channel: e,\n                        messageId: ye\n                      }\n                    }));\n                  });\n              }\n\n              break;\n\n            case \"READ\":\n              var me = new y(L),\n                  Ee = c.cachedChannels.hasOwnProperty(me.channelUrl);\n              c.getChannel(me.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                if (t.sb.getErrorFirstCallback()) {\n                  var r = [e, n];\n                  n = r[0], e = r[1];\n                }\n\n                n || (Ee && e.updateReadReceipt(me.reader.userId, me.timestamp), t.sb.currentUser && (me.reader.userId === t.sb.currentUser.userId ? Ee ? (e.unreadMessageCount > 0 || e.unreadMentionCount > 0) && (e._setGroupChannelUnreadCount(0, 0), Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                  t.sb.channelHandlers[n].onChannelChanged(e);\n                }), j.upsert([e]).then(function () {\n                  V.send({\n                    source: de.EVENT_CHANNEL_CHANGED,\n                    payload: {\n                      channel: e\n                    }\n                  });\n                }).catch(function (e) {\n                  t.handleCacheError(e);\n                })) : 0 !== e.unreadMessageCount && 0 !== e.unreadMentionCount || (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                  t.sb.channelHandlers[n].onChannelChanged(e);\n                }), j.upsert([e]).then(function () {\n                  V.send({\n                    source: de.EVENT_CHANNEL_CHANGED,\n                    payload: {\n                      channel: e\n                    }\n                  });\n                }).catch(function (e) {\n                  t.handleCacheError(e);\n                })) : Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                  t.sb.channelHandlers[n].onReadReceiptUpdated(e);\n                }), V.send({\n                  source: de.EVENT_READ_RECEIPT_UPDATED,\n                  payload: {\n                    channel: e,\n                    user: me.reader\n                  }\n                })));\n              });\n              break;\n\n            case \"MRCT\":\n              var ve = String(L.channel_type),\n                  be = String(L.channel_url),\n                  Ce = g.createFromJson(L);\n\n              switch (ve) {\n                case o.CHANNEL_TYPE_GROUP:\n                  c.getChannel(be, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\")) : (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onReactionUpdated(e, Ce);\n                    }), B.get(\"\".concat(Ce.messageId)).then(function (n) {\n                      n && (n.applyReactionEvent(Ce), B.upsert([n]).then(function () {\n                        V.send({\n                          source: de.EVENT_REACTION_UPDATED,\n                          payload: {\n                            channel: e,\n                            reactionEvent: Ce\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      }));\n                    }).catch(function (e) {\n                      t.handleCacheError(e);\n                    }));\n                  });\n                  break;\n\n                case o.CHANNEL_TYPE_OPEN:\n                  d.getChannel(be, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\")) : (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onReactionUpdated(e, Ce);\n                    }), V.send({\n                      source: de.EVENT_REACTION_UPDATED,\n                      payload: {\n                        channel: e,\n                        reactionEvent: Ce\n                      }\n                    }));\n                  });\n              }\n\n              break;\n\n            case \"DLVR\":\n              var Ae = String(L.channel_url),\n                  Ne = L.hasOwnProperty(\"updated\") ? L.updated : null,\n                  Se = c.cachedChannels.hasOwnProperty(Ae);\n              c.getChannel(Ae, T.INTERNAL_CALL, function (e, n) {\n                if (t.sb.getErrorFirstCallback()) {\n                  var r = [e, n];\n                  n = r[0], e = r[1];\n                }\n\n                if (!n) {\n                  var i = !1;\n                  Object.keys(Ne).forEach(function (n) {\n                    t.sb.currentUser && n === t.sb.currentUser.userId && (i = !0), Se && e.updateDeliveryReceipt(n, parseInt(Ne[n]));\n                  }), c.cachedChannels[e.url] = e, i && 1 === Object.keys(Ne).length || (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                    t.sb.channelHandlers[n].onDeliveryReceiptUpdated(e);\n                  }), V.send({\n                    source: de.EVENT_DELIVERY_RECEIPT_UPDATED,\n                    payload: {\n                      channel: e\n                    }\n                  }));\n                }\n              });\n              break;\n\n            case \"MTHD\":\n              var Te = String(L.channel_url),\n                  Oe = String(L.channel_type),\n                  Ue = m.createFromJson(L);\n\n              switch (Oe) {\n                case o.CHANNEL_TYPE_GROUP:\n                  c.getChannel(Te, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n || (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onThreadInfoUpdated(e, Ue);\n                    }), B.get(\"\".concat(Ue.targetMessageId)).then(function (n) {\n                      n && (n.applyThreadInfoUpdateEvent(Ue), B.upsert([n]).then(function () {\n                        V.send({\n                          source: de.EVENT_THREAD_INFO_UPDATED,\n                          payload: {\n                            channel: e,\n                            threadInfoUpdateEvent: Ue\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      }));\n                    }).catch(function (e) {\n                      t.handleCacheError(e);\n                    }));\n                  });\n                  break;\n\n                case o.CHANNEL_TYPE_OPEN:\n                  d.getChannel(Te, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n || (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onThreadInfoUpdated(e, Ue);\n                    }), V.send({\n                      source: de.EVENT_THREAD_INFO_UPDATED,\n                      payload: {\n                        channel: e,\n                        threadInfoUpdateEvent: Ue\n                      }\n                    }));\n                  });\n              }\n\n              break;\n\n            case \"MCNT\":\n              if (L.hasOwnProperty(\"group_channels\") && Array.isArray(L.group_channels)) {\n                var Me,\n                    ke = [],\n                    Re = I(L.group_channels);\n\n                try {\n                  for (Re.s(); !(Me = Re.n()).done;) {\n                    var Le = Me.value;\n\n                    if (Le) {\n                      var Pe = c.cachedChannels[Le.channel_url];\n                      if (Pe && Pe.isBroadcast) Pe.setLatestMemberCount(Le.member_count, Le.joined_member_count, Le.ts) && ke.push(Pe);\n                    }\n                  }\n                } catch (e) {\n                  Re.e(e);\n                } finally {\n                  Re.f();\n                }\n\n                ke.length > 0 && (Object.keys(this.sb.channelHandlers).forEach(function (e) {\n                  t.sb.channelHandlers[e].onChannelMemberCountChanged(ke);\n                }), j.upsert(ke).then(function () {\n                  var e,\n                      t = I(ke);\n\n                  try {\n                    for (t.s(); !(e = t.n()).done;) {\n                      var n = e.value;\n                      V.send({\n                        source: de.EVENT_CHANNEL_CHANGED,\n                        payload: {\n                          channel: n\n                        }\n                      });\n                    }\n                  } catch (e) {\n                    t.e(e);\n                  } finally {\n                    t.f();\n                  }\n                }).catch(function (e) {\n                  t.handleCacheError(e);\n                }));\n              }\n\n              if (L.hasOwnProperty(\"open_channels\") && Array.isArray(L.open_channels)) {\n                var we,\n                    De = [],\n                    He = I(L.open_channels);\n\n                try {\n                  for (He.s(); !(we = He.n()).done;) {\n                    var Fe = we.value;\n\n                    if (Fe) {\n                      var xe = d.cachedChannels[Fe.channel_url];\n                      if (xe) xe.setLatestParticipantCount(Fe.participant_count, Fe.ts) && De.push(xe);\n                    }\n                  }\n                } catch (e) {\n                  He.e(e);\n                } finally {\n                  He.f();\n                }\n\n                if (De.length > 0) {\n                  Object.keys(this.sb.channelHandlers).forEach(function (e) {\n                    t.sb.channelHandlers[e].onChannelParticipantCountChanged(De);\n                  });\n                  var je,\n                      Be = I(De);\n\n                  try {\n                    for (Be.s(); !(je = Be.n()).done;) {\n                      var Ve = je.value;\n                      V.send({\n                        source: de.EVENT_CHANNEL_CHANGED,\n                        payload: {\n                          channel: Ve\n                        }\n                      });\n                    }\n                  } catch (e) {\n                    Be.e(e);\n                  } finally {\n                    Be.f();\n                  }\n                }\n              }\n\n              break;\n\n            case \"PEDI\":\n              var qe = E.createFromJson(L);\n              Object.keys(this.sb.channelHandlers).forEach(function (e) {\n                t.sb.channelHandlers[e].onPollUpdated(qe);\n              });\n              break;\n\n            case \"VOTE\":\n              var Ke = v.createFromJson(L);\n              Object.keys(this.sb.channelHandlers).forEach(function (e) {\n                t.sb.channelHandlers[e].onPollVoted(Ke);\n              });\n              break;\n\n            case \"SYEV\":\n              var ze = new Lt(L),\n                  Ye = L.ts;\n\n              switch (ze.category) {\n                case Lt.CATEGORY_CHANNEL_JOIN:\n                case Lt.CATEGORY_CHANNEL_LEAVE:\n                  c.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    if (n) J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category);else {\n                      var a = ze.data.hasOwnProperty(\"member_count\") ? ze.data.member_count : null,\n                          o = ze.data.hasOwnProperty(\"joined_member_count\") ? ze.data.joined_member_count : null,\n                          l = !1;\n\n                      if (ze.category === Lt.CATEGORY_CHANNEL_JOIN) {\n                        (ze.data.hasOwnProperty(\"users\") ? ze.data.users : [ze.data]).forEach(function (n) {\n                          e.isSuper || e.isBroadcast ? l = e.setLatestMemberCount(a, o, L.ts) : (n.state = s.JOINED, e.addMember(new s(n), Ye), e.updateJoinedMemberCount());\n                          var r = new i(n);\n                          t.sb.currentUser && r.userId === t.sb.currentUser.userId && (e.myMemberState = \"joined\", c.cachedChannels[e.url] = e), Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                            var i = t.sb.channelHandlers[n];\n                            i.onUserJoined(e, r), e.isBroadcast && l && i.onChannelMemberCountChanged([e]);\n                          }), j.upsert([e]).then(function () {\n                            V.send({\n                              source: de.EVENT_USER_JOINED,\n                              payload: {\n                                channel: e,\n                                user: r\n                              }\n                            });\n                          }).catch(function (e) {\n                            t.handleCacheError(e);\n                          });\n                        });\n                      } else {\n                        var u = new i(ze.data);\n                        if (t.sb.currentUser && u.userId === t.sb.currentUser.userId ? (e.isPublic || c.removeCachedChannel(ze.channelUrl), e.myMemberState = \"none\", e.invitedAt = 0, e.joinedAt = 0, e._setGroupChannelUnreadCount(0, 0)) : c.cachedChannels[e.url] = e, e.isSuper || e.isBroadcast) l = e.setLatestMemberCount(a, o, L.ts);else C.container.appInfo.enabledChannelMemberShipHistory ? (e.memberMap[u.userId].state = c.MemberStateFilter.LEFT, e.memberCount = ze.data.member_count) : e.removeMember(u), e.updateJoinedMemberCount();\n                        Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                          var r = t.sb.channelHandlers[n];\n                          r.onUserLeft(e, u), e.isBroadcast && l && r.onChannelMemberCountChanged([e]);\n                        }), j.upsert([e]).then(function () {\n                          V.send({\n                            source: de.EVENT_USER_LEFT,\n                            payload: {\n                              channel: e,\n                              user: u\n                            }\n                          });\n                        }).catch(function (e) {\n                          t.handleCacheError(e);\n                        });\n                      }\n                    }\n                  });\n                  break;\n\n                case Lt.CATEGORY_CHANNEL_OPERATOR_UPDATE:\n                  ze.isGroupChannel() ? c.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    if (n) J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category);else {\n                      for (var s = ze.data.operators.map(function (e) {\n                        return new i(e);\n                      }), a = s.map(function (e) {\n                        return e.userId;\n                      }), o = 0; o < e.members.length; o++) {\n                        e.members[o].role = a.indexOf(e.members[o].userId) >= 0 ? c.Role.OPERATOR : c.Role.NONE;\n                      }\n\n                      e.myRole = t.sb.currentUser && a.indexOf(t.sb.currentUser.userId) >= 0 ? c.Role.OPERATOR : c.Role.NONE, Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        t.sb.channelHandlers[n].onOperatorUpdated(e, s);\n                      }), j.upsert([e]).then(function () {\n                        V.send({\n                          source: de.EVENT_OPERATOR_UPDATED,\n                          payload: {\n                            channel: e,\n                            operators: s\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      });\n                    }\n                  }) : ze.isOpenChannel() && d.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category) : (e.operators = ze.data.operators.map(function (e) {\n                      return new i(e);\n                    }), Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onOperatorUpdated(e, e.operators);\n                    }));\n                  });\n                  break;\n\n                case Lt.CATEGORY_CHANNEL_INVITE:\n                  c.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    if (n) J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category);else {\n                      var a = null;\n                      ze.data && ze.data.inviter && Object.keys(ze.data.inviter).length > 0 && (a = new i(ze.data.inviter));\n\n                      for (var o = [], l = 0; l < ze.data.invitees.length; l++) {\n                        var u = new i(ze.data.invitees[l]);\n                        o.push(u), ze.data.invitees[l].state = s.INVITED;\n                        var d = new s(ze.data.invitees[l]);\n\n                        if (e.isSuper || e.isBroadcast) {\n                          var h = ze.data.hasOwnProperty(\"member_count\") ? ze.data.member_count : null,\n                              p = ze.data.hasOwnProperty(\"joined_member_count\") ? ze.data.joined_member_count : null;\n                          e.setLatestMemberCount(h, p, L.ts);\n                        } else e.addMember(d, Ye);\n\n                        t.sb.currentUser && d.userId === t.sb.currentUser.userId && (e.isHidden = !1, \"joined\" !== e.myMemberState && (e.myMemberState = \"invited\"), e.invitedAt = L.ts, c.cachedChannels[e.url] = e);\n                      }\n\n                      Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        t.sb.channelHandlers[n].onUserReceivedInvitation(e, a, o);\n                      }), j.upsert([e]).then(function () {\n                        V.send({\n                          source: de.EVENT_USER_RECEIVED_INVITATION,\n                          payload: {\n                            channel: e,\n                            inviter: a,\n                            invitees: o\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      });\n                    }\n                  });\n                  break;\n\n                case Lt.CATEGORY_CHANNEL_DECLINE_INVITE:\n                  c.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    if (n) J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category);else {\n                      var s = null;\n                      ze.data && ze.data.inviter && Object.keys(ze.data.inviter).length > 0 && (s = new i(ze.data.inviter));\n                      var a = new i(ze.data.invitee);\n\n                      if (t.sb.currentUser && a.userId === t.sb.currentUser.userId && (e.invitedAt = 0, e.myMemberState = \"none\", e.isPublic || c.removeCachedChannel(ze.channelUrl)), e.isSuper || e.isBroadcast) {\n                        var o = ze.data.hasOwnProperty(\"member_count\") ? ze.data.member_count : null,\n                            l = ze.data.hasOwnProperty(\"joined_member_count\") ? ze.data.joined_member_count : null;\n                        e.setLatestMemberCount(o, l, L.ts);\n                      } else e.removeMember(a);\n\n                      t.sb.currentUser && a.userId !== t.sb.currentUser.userId && (c.cachedChannels[e.url] = e), Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        t.sb.channelHandlers[n].onUserDeclinedInvitation(e, s, a);\n                      }), j.upsert([e]).then(function () {\n                        V.send({\n                          source: de.EVENT_USER_DECLINED_INVITATION,\n                          payload: {\n                            channel: e,\n                            inviter: s,\n                            invitee: a\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      });\n                    }\n                  });\n                  break;\n\n                case Lt.CATEGORY_TYPING_START:\n                case Lt.CATEGORY_TYPING_END:\n                  c.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    if (n) J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category);else {\n                      var s = new i(ze.data);\n                      ze.category === Lt.CATEGORY_TYPING_START ? e.updateTypingStatus(s, !0) : e.updateTypingStatus(s, !1), Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        t.sb.channelHandlers[n].onTypingStatusUpdated(e);\n                      }), j.upsert([e]).then(function () {\n                        V.send({\n                          source: de.EVENT_TYPING_STATUS_UPDATED,\n                          payload: {\n                            channel: e\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      });\n                    }\n                  });\n                  break;\n\n                case Lt.CATEGORY_CHANNEL_ENTER:\n                case Lt.CATEGORY_CHANNEL_EXIT:\n                  d.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    if (n) J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category);else {\n                      var s = ze.data.hasOwnProperty(\"participant_count\") ? ze.data.participant_count : null,\n                          a = e.setLatestParticipantCount(s, L.ts),\n                          o = new i(ze.data);\n                      ze.category === Lt.CATEGORY_CHANNEL_ENTER ? (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        var r = t.sb.channelHandlers[n];\n                        r.onUserEntered(e, o), a && r.onChannelParticipantCountChanged([e]);\n                      }), V.send({\n                        source: de.EVENT_CHANNEL_ENTER,\n                        payload: {\n                          channel: e,\n                          user: o\n                        }\n                      })) : (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        var r = t.sb.channelHandlers[n];\n                        r.onUserExited(e, o), a && r.onChannelParticipantCountChanged([e]);\n                      }), V.send({\n                        source: de.EVENT_CHANNEL_EXIT,\n                        payload: {\n                          channel: e,\n                          user: o\n                        }\n                      }));\n                    }\n                  });\n                  break;\n\n                case Lt.CATEGORY_USER_CHANNEL_MUTE:\n                case Lt.CATEGORY_USER_CHANNEL_UNMUTE:\n                  var Qe = ze.category === Lt.CATEGORY_USER_CHANNEL_MUTE,\n                      We = l({}, ze.data);\n                  Qe && (We.restriction_type = a.RestrictionType.MUTED);\n                  var Je = Qe ? new a(We) : new i(ze.data),\n                      Xe = Qe ? \"muted\" : \"unmuted\";\n                  ze.isOpenChannel() ? d.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category) : Qe ? (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onUserMuted(e, Je);\n                    }), V.send({\n                      source: de.EVENT_USER_MUTED,\n                      payload: {\n                        channel: e,\n                        user: Je\n                      }\n                    })) : (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onUserUnmuted(e, Je);\n                    }), V.send({\n                      source: de.EVENT_USER_UNMUTED,\n                      payload: {\n                        channel: e,\n                        user: Je\n                      }\n                    }));\n                  }) : c.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category) : (t.sb.currentUser && Je.userId === t.sb.currentUser.userId && (e.myMutedState = Xe), Array.isArray(e.members) && e.members.filter(function (e) {\n                      return e && e.userId === Je.userId;\n                    }).forEach(function (e) {\n                      e.isMuted = Qe, e.restrictionInfo = new b(We);\n                    }), Qe ? (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onUserMuted(e, Je);\n                    }), j.upsert([e]).then(function () {\n                      V.send({\n                        source: de.EVENT_USER_MUTED,\n                        payload: {\n                          channel: e,\n                          user: Je\n                        }\n                      });\n                    }).catch(function (e) {\n                      t.handleCacheError(e);\n                    })) : (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onUserUnmuted(e, Je);\n                    }), j.upsert([e]).then(function () {\n                      V.send({\n                        source: de.EVENT_USER_UNMUTED,\n                        payload: {\n                          channel: e,\n                          user: Je\n                        }\n                      });\n                    }).catch(function (e) {\n                      t.handleCacheError(e);\n                    })));\n                  });\n                  break;\n\n                case Lt.CATEGORY_USER_CHANNEL_BAN:\n                case Lt.CATEGORY_USER_CHANNEL_UNBAN:\n                  var Ze = ze.category === Lt.CATEGORY_USER_CHANNEL_BAN,\n                      $e = l({}, ze.data);\n                  Ze && ($e.restriction_type = a.RestrictionType.BANNED);\n                  var et = Ze ? new a($e) : new i(ze.data);\n                  ze.isOpenChannel() ? d.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    if (n) J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category);else if (Ze) {\n                      if (t.sb.currentUser && et.userId === t.sb.currentUser.userId) delete d.enteredChannels[ze.channelUrl], t.cls.FileMessageQueue.delete(ze.channelUrl);\n                      Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        t.sb.channelHandlers[n].onUserBanned(e, et);\n                      }), V.send({\n                        source: de.EVENT_USER_BANNED,\n                        payload: {\n                          channel: e,\n                          user: et\n                        }\n                      });\n                    } else Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onUserUnbanned(e, et);\n                    }), V.send({\n                      source: de.EVENT_USER_UNBANNED,\n                      payload: {\n                        channel: e,\n                        user: et\n                      }\n                    });\n                  }) : c.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    if (n) J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category);else if (Ze) {\n                      if (t.sb.currentUser && et.userId === t.sb.currentUser.userId && (e.isPublic || c.removeCachedChannel(ze.channelUrl), e.myMemberState = \"none\", e.invitedAt = 0, e.joinedAt = 0, e._setGroupChannelUnreadCount(0, 0)), e.isSuper || e.isBroadcast) {\n                        var i = ze.data.hasOwnProperty(\"member_count\") ? ze.data.member_count : null,\n                            s = ze.data.hasOwnProperty(\"joined_member_count\") ? ze.data.joined_member_count : null;\n                        e.setLatestMemberCount(i, s, L.ts);\n                      } else e.removeMember(et), e.updateJoinedMemberCount();\n\n                      Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        t.sb.channelHandlers[n].onUserBanned(e, et);\n                      }), V.send({\n                        source: de.EVENT_USER_BANNED,\n                        payload: {\n                          channel: e,\n                          user: et\n                        }\n                      });\n                    } else Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onUserUnbanned(e, et);\n                    }), V.send({\n                      source: de.EVENT_USER_UNBANNED,\n                      payload: {\n                        channel: e,\n                        user: et\n                      }\n                    });\n                  });\n                  break;\n\n                case Lt.CATEGORY_CHANNEL_FREEZE:\n                case Lt.CATEGORY_CHANNEL_UNFREEZE:\n                  ze.isOpenChannel() ? d.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category) : (e.isFrozen = ze.data.freeze, d.cachedChannels[e.url] = e, ze.category === Lt.CATEGORY_CHANNEL_FREEZE ? (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onChannelFrozen(e);\n                    }), V.send({\n                      source: de.EVENT_CHANNEL_FROZEN,\n                      payload: {\n                        channel: e\n                      }\n                    })) : (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onChannelUnfrozen(e);\n                    }), V.send({\n                      source: de.EVENT_CHANNEL_UNFROZEN,\n                      payload: {\n                        channel: e\n                      }\n                    })));\n                  }) : c.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category) : (e.isFrozen = ze.data.freeze, c.cachedChannels[e.url] = e, ze.category === Lt.CATEGORY_CHANNEL_FREEZE ? (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onChannelFrozen(e);\n                    }), j.upsert([e]).then(function () {\n                      V.send({\n                        source: de.EVENT_CHANNEL_FROZEN,\n                        payload: {\n                          channel: e\n                        }\n                      });\n                    }).catch(function (e) {\n                      t.handleCacheError(e);\n                    })) : (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onChannelUnfrozen(e);\n                    }), j.upsert([e]).then(function () {\n                      V.send({\n                        source: de.EVENT_CHANNEL_UNFROZEN,\n                        payload: {\n                          channel: e\n                        }\n                      });\n                    }).catch(function (e) {\n                      t.handleCacheError(e);\n                    })));\n                  });\n                  break;\n\n                case Lt.CATEGORY_CHANNEL_DELETED:\n                  ze.isGroupChannel() ? c.removeCachedChannel(ze.channelUrl) : d.removeCachedChannel(ze.channelUrl);\n                  var tt = ze.channelUrl,\n                      nt = ze.isGroupChannel() ? \"group\" : \"open\";\n                  Object.keys(this.sb.channelHandlers).forEach(function (e) {\n                    t.sb.channelHandlers[e].onChannelDeleted(tt, nt);\n                  }), j.remove([tt]).then(function () {\n                    V.send({\n                      source: de.EVENT_CHANNEL_DELETED,\n                      payload: {\n                        channelUrl: tt,\n                        channelType: nt\n                      }\n                    });\n                  }).catch(function (e) {\n                    t.handleCacheError(e);\n                  });\n                  break;\n\n                case Lt.CATEGORY_CHANNEL_PROP_CHANGED:\n                  ze.isOpenChannel() ? d.getChannelWithoutCache(ze.channelUrl, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category) : (Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onChannelChanged(e);\n                    }), V.send({\n                      source: de.EVENT_CHANNEL_CHANGED,\n                      payload: {\n                        channel: e\n                      }\n                    }));\n                  }) : c.getChannelWithoutCache(ze.channelUrl, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    if (n) J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category);else {\n                      var i = e.unreadMessageCount,\n                          s = e.unreadMentionCount;\n                      e.myCountPreference !== c.CountPreference.ALL && (e.myCountPreference === c.CountPreference.UNREAD_MESSAGE_COUNT_ONLY ? s = 0 : e.myCountPreference === c.CountPreference.UNREAD_MENTION_COUNT_ONLY ? i = 0 : (i = 0, s = 0)), e._setGroupChannelUnreadCount(i, s), Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                        t.sb.channelHandlers[n].onChannelChanged(e);\n                      }), j.upsert([e]).then(function () {\n                        V.send({\n                          source: de.EVENT_CHANNEL_CHANGED,\n                          payload: {\n                            channel: e\n                          }\n                        });\n                      }).catch(function (e) {\n                        t.handleCacheError(e);\n                      });\n                    }\n                  });\n                  break;\n\n                case Lt.CATEGORY_CHANNEL_META_DATA_CHANGED:\n                case Lt.CATEGORY_CHANNEL_META_COUNTERS_CHANGED:\n                  var rt = ze.data.hasOwnProperty(\"created\"),\n                      it = ze.data.hasOwnProperty(\"updated\"),\n                      st = ze.data.hasOwnProperty(\"deleted\");\n                  (ze.isOpenChannel() ? d.getChannel(ze.channelUrl, T.INTERNAL_CALL) : c.getChannel(ze.channelUrl, T.INTERNAL_CALL)).then(function (e) {\n                    var n = ze.data.created,\n                        r = ze.data.updated,\n                        i = ze.data.deleted;\n                    Object.keys(t.sb.channelHandlers).forEach(function (s) {\n                      var a = t.sb.channelHandlers[s];\n\n                      if (ze.category === Lt.CATEGORY_CHANNEL_META_DATA_CHANGED) {\n                        var o = L.ts;\n                        rt && e._addOrUpdateCachedMetaData(n, o), it && e._addOrUpdateCachedMetaData(r, o), st && e._markAsDeletedCachedMetaData(i, o), rt && a.onMetaDataCreated(e, n), it && a.onMetaDataUpdated(e, r), st && a.onMetaDataDeleted(e, i), (rt || it) && V.send({\n                          source: de.EVENT_CHANNEL_METADATA_UPDATED,\n                          payload: {\n                            channel: e,\n                            metaData: l(l({}, n), r)\n                          }\n                        }), st && V.send({\n                          source: de.EVENT_CHANNEL_METADATA_DELETED,\n                          payload: {\n                            channel: e,\n                            metaData: l({}, i)\n                          }\n                        });\n                      } else rt && a.onMetaCountersCreated(e, n), it && a.onMetaCountersUpdated(e, r), st && a.onMetaCountersDeleted(e, i), (rt || it) && V.send({\n                        source: de.EVENT_CHANNEL_METACOUNTER_UPDATED,\n                        payload: {\n                          channel: e,\n                          metaData: l(l({}, n), r)\n                        }\n                      }), st && V.send({\n                        source: de.EVENT_CHANNEL_METACOUNTER_DELETED,\n                        payload: {\n                          channel: e,\n                          metaData: l({}, i)\n                        }\n                      });\n                    });\n                  }).catch(function (e) {\n                    return J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category);\n                  });\n                  break;\n\n                case Lt.CATEGORY_CHANNEL_HIDE:\n                case Lt.CATEGORY_CHANNEL_UNHIDE:\n                  c.getChannel(ze.channelUrl, T.INTERNAL_CALL, function (e, n) {\n                    if (t.sb.getErrorFirstCallback()) {\n                      var r = [e, n];\n                      n = r[0], e = r[1];\n                    }\n\n                    n ? J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"), ze.category) : ze.category === Lt.CATEGORY_CHANNEL_HIDE ? (e.isHidden = !0, ze.data && (ze.data.hasOwnProperty(\"allow_auto_unhide\") && (e.hiddenState = ze.data.allow_auto_unhide ? c.HiddenState.HIDDEN_ALLOW_AUTO_UNHIDE : c.HiddenState.HIDDEN_PREVENT_AUTO_UNHIDE), ze.data.hasOwnProperty(\"hide_previous_messages\") && ze.data.hide_previous_messages && e._setGroupChannelUnreadCount(0, 0)), L.hasOwnProperty(\"ts_message_offset\") && (e._messageOffsetTimestamp = L.ts_message_offset), c.cachedChannels[e.url] = e, Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onChannelHidden(e);\n                    }), j.upsert([e]).then(function () {\n                      V.send({\n                        source: de.EVENT_CHANNEL_HIDDEN,\n                        payload: {\n                          channel: e\n                        }\n                      });\n                    }).catch(function (e) {\n                      t.handleCacheError(e);\n                    })) : (e.isHidden = !1, e.hiddenState = c.HiddenState.UNHIDDEN, c.cachedChannels[e.url] = e, Object.keys(t.sb.channelHandlers).forEach(function (n) {\n                      t.sb.channelHandlers[n].onChannelChanged(e);\n                    }), j.upsert([e]).then(function () {\n                      V.send({\n                        source: de.EVENT_CHANNEL_UNHIDDEN,\n                        payload: {\n                          channel: e\n                        }\n                      });\n                    }).catch(function (e) {\n                      t.handleCacheError(e);\n                    }));\n                  });\n              }\n\n              break;\n\n            case \"USEV\":\n              var at = new Lt(L);\n\n              switch (at.category) {\n                case Pt.CATEGORY_USER_BLOCK:\n                case Pt.CATEGORY_USER_UNBLOCK:\n                  var ot = at.data.blocker.user_id,\n                      lt = at.data.blockee.user_id;\n                  Object.keys(c.cachedChannels).forEach(function (e) {\n                    var n = c.cachedChannels[e];\n\n                    try {\n                      t.sb.currentUser && (t.sb.currentUser.userId === ot ? n.memberMap[lt].isBlockedByMe = at.category === Pt.CATEGORY_USER_BLOCK : t.sb.currentUser.userId === lt && (n.memberMap[ot].isBlockingMe = at.category === Pt.CATEGORY_USER_BLOCK));\n                    } catch (e) {}\n                  });\n                  break;\n\n                case Pt.CATEGORY_FRIEND_DISCOVERED:\n                  var ut = at.data.friend_discoveries.map(function (e) {\n                    return new i(e);\n                  });\n                  Object.keys(this.sb.userEventHandlers).forEach(function (e) {\n                    t.sb.userEventHandlers[e].onFriendsDiscovered(ut);\n                  });\n              }\n\n              break;\n\n            case \"LEAV\":\n            case \"JOIN\":\n            case \"PONG\":\n            case \"MTIO\":\n            case \"TPST\":\n            case \"TPEN\":\n              break;\n\n            default:\n              J.debug(\"Discard command:\", \"`\".concat(R.command, \"`\"));\n          }\n        }\n      }\n    }, {\n      key: \"handleCacheError\",\n      value: function value(e) {\n        J.error(e);\n      }\n    }]), e;\n  }(),\n      Dt = 200,\n      Ht = {},\n      Ft = {},\n      Gt = function () {\n    function e(t) {\n      c(this, e), this.channel = t, this.uploadQueue = [], this.messageQueue = [], this.latestTimestampToSendMessage = 0, x.get(this._iid).FileMessageQueue.queueMap[t.url] = this;\n    }\n\n    return h(e, [{\n      key: \"_handleMessageQueueUpdated\",\n      value: function value(e) {\n        var t = this;\n\n        switch (J.debug(\"`fileMessageQueue` message queue updated:\", this.messageQueue), e) {\n          case \"add\":\n            this.uploadQueue.length < 6 && this._moveFirstPendingMessageToUploadQueue();\n            break;\n\n          case \"update\":\n          case \"remove\":\n            if (this.messageQueue.length > 0) {\n              var n = x.get(this._iid).FileMessageQueue,\n                  r = this.messageQueue[0];\n              if (r) if (r.state === n.State.UPLOADED) {\n                if (r.state = n.State.SENDING, navigator && \"boolean\" == typeof navigator.onLine) {\n                  if (navigator.onLine) {\n                    for (0 === this.latestTimestampToSendMessage && (this.latestTimestampToSendMessage = new Date().getTime() - Dt); new Date().getTime() - this.latestTimestampToSendMessage < Dt;) {\n                      ;\n                    }\n\n                    this.latestTimestampToSendMessage = new Date().getTime(), this._sendUploadedMessage(r, function (e, i) {\n                      r.state = n.State.SENT, r.error = e || null, r.response = i || null, t._handleMessageQueueUpdated(\"update\");\n                    });\n                  } else r.state = n.State.SENT, r.error = new H(\"Connection is not valid. Please reconnect.\", H.WEBSOCKET_CONNECTION_CLOSED), r.response = null, this._finalizeMessage();\n                } else Je.ready().then(function (e) {\n                  if (e) {\n                    for (0 === t.latestTimestampToSendMessage && (t.latestTimestampToSendMessage = new Date().getTime() - Dt); new Date().getTime() - t.latestTimestampToSendMessage < Dt;) {\n                      ;\n                    }\n\n                    t.latestTimestampToSendMessage = new Date().getTime(), t._sendUploadedMessage(r, function (e, i) {\n                      r.state = n.State.SENT, r.error = e || null, r.response = i || null, t._handleMessageQueueUpdated(\"update\");\n                    });\n                  } else r.state = n.State.SENT, r.error = new H(\"Connection is not valid. Please reconnect.\", H.WEBSOCKET_CONNECTION_CLOSED), r.response = null, t._finalizeMessage();\n                });\n              } else r.state === n.State.SENT && this._finalizeMessage();\n            }\n\n        }\n      }\n    }, {\n      key: \"_handleUploadQueueUpdated\",\n      value: function value(e, t) {\n        var n = this;\n\n        switch (J.debug(\"`fileMessageQueue` upload queue updated:\", this.uploadQueue), e) {\n          case \"add\":\n            var r = x.get(this._iid).FileMessageQueue;\n\n            if (t.state = r.State.UPLOADING, t.error) {\n              var i = this.messageQueue.map(function (e) {\n                return e.requestId;\n              }).indexOf(t.requestId);\n              i > -1 && (t.state = r.State.SENT, this._handleMessageQueueUpdated(\"update\")), this._finalizeUpload(t.requestId);\n            } else navigator && \"boolean\" == typeof navigator.onLine ? navigator.onLine ? this._uploadFile(t, function (e) {\n              t.error && t.error.code === H.REQUEST_FAILED && (t.error = new H(\"Failed to upload a file.\", H.NETWORK_ERROR)), t.error && t.state === r.State.SENT || (t.state = r.State.UPLOADED), t.fileInfo = e, n._handleMessageQueueUpdated(\"update\"), n._finalizeUpload(t.requestId);\n            }) : (t.state = r.State.SENT, t.error = new H(\"Connection is not valid. Please reconnect.\", H.WEBSOCKET_CONNECTION_CLOSED), t.response = null, this._handleMessageQueueUpdated(\"update\"), this._finalizeUpload(t.requestId)) : Je.ready().then(function (e) {\n              e ? n._uploadFile(t, function (e) {\n                t.error && t.error.code === H.REQUEST_FAILED && (t.error = new H(\"Failed to upload a file.\", H.NETWORK_ERROR)), t.error && t.state === r.State.SENT || (t.state = r.State.UPLOADED), t.fileInfo = e, n._handleMessageQueueUpdated(\"update\"), n._finalizeUpload(t.requestId);\n              }) : (t.state = r.State.SENT, t.error = new H(\"Connection is not valid. Please reconnect.\", H.WEBSOCKET_CONNECTION_CLOSED), t.response = null, n._handleMessageQueueUpdated(\"update\"), n._finalizeUpload(t.requestId));\n            });\n\n            break;\n\n          case \"update\":\n            break;\n\n          case \"remove\":\n            this.uploadQueue.length < 6 && this._moveFirstPendingMessageToUploadQueue();\n        }\n      }\n    }, {\n      key: \"_moveFirstPendingMessageToUploadQueue\",\n      value: function value() {\n        var e = x.get(this._iid).FileMessageQueue,\n            t = this.messageQueue.filter(function (t) {\n          return t.state === e.State.PENDING;\n        });\n\n        if (t.length > 0) {\n          var n = t[0];\n          this.uploadQueue.push(n), this._handleUploadQueueUpdated(\"add\", n);\n        }\n      }\n    }, {\n      key: \"_sendUploadedMessage\",\n      value: function value(e, t) {\n        var n = x.get(this._iid),\n            r = n.Command,\n            i = n.FileMessage,\n            s = e.fileInfo,\n            a = r.bFile(l(l({}, s), {}, {\n          requestId: e.requestId,\n          channelUrl: this.channel.url,\n          url: s.file,\n          metaArrays: s.metaArrays\n        })),\n            o = ji.getInstance(this._iid),\n            u = U.get(this._iid);\n        o.getConnectionState() === o.ConnectionState.OPEN || !o.currentUser || o.connecting || o.reconnecting ? o.sendCommand(a, function (e, n) {\n          if (o.getErrorFirstCallback()) {\n            var r = [e, n];\n            n = r[0], e = r[1];\n          }\n\n          if (n) {\n            var l = new i(a.getJsonElement());\n            l.requestedMentionUserIds = s.mentionedUserIds, t(n, l);\n          } else {\n            var u = new i(e.getJsonElement());\n            t(null, u);\n          }\n        }) : u.container.apiClient.sendFileMessage(l(l({\n          reqId: e.requestId,\n          channelUrl: this.channel.url,\n          isOpenChannel: this.channel.isOpenChannel()\n        }, s), {}, {\n          fileUrl: s.file,\n          fileName: s.name,\n          fileSize: s.size,\n          fileType: s.type,\n          metaArrays: s.metaArrays\n        }), function (e, n) {\n          var r = new i(e ? a.getJsonElement() : n);\n          e && (r.requestedMentionUserIds = s.mentionedUserIds), t(e, r);\n        });\n      }\n    }, {\n      key: \"_uploadFile\",\n      value: function value(e, t) {\n        var n = e.fileInfo,\n            r = e.pendingMessage;\n\n        if (\"string\" != typeof n.file && n.file) {\n          var i = x.get(this._iid).FileMessageQueue;\n          U.get(this._iid).container.apiClient.uploadFile(l(l({}, n), {}, {\n            fileType: n.type,\n            channelUrl: this.channel.url,\n            reqId: r ? r.reqId : null\n          }), function (r, s) {\n            if (r) e.state = i.State.SENT, e.error = r, e.response = null, t(n);else {\n              var a = \"object\" === u(s) ? s : JSON.parse(s);\n              n.file = a.url, n.thumbnailSizes = a.hasOwnProperty(\"thumbnails\") ? a.thumbnails : [], n.requireAuth = !!a.hasOwnProperty(\"require_auth\") && a.require_auth, n.size = a.hasOwnProperty(\"file_size\") ? a.file_size : n.size, t(n);\n            }\n          });\n        } else n.thumbnailSizes = [], n.requireAuth = !1, t(n);\n      }\n    }, {\n      key: \"_finalizeUpload\",\n      value: function value(e) {\n        var t = this.uploadQueue.map(function (e) {\n          return e.requestId;\n        }).indexOf(e);\n\n        if (t > -1) {\n          var n = this.uploadQueue.splice(t, 1);\n          n.length > 0 && this._handleUploadQueueUpdated(\"remove\", n[0]);\n        }\n      }\n    }, {\n      key: \"_finalizeMessage\",\n      value: function value() {\n        var e = this,\n            t = U.get(this._iid),\n            n = t.container.localCacheEnabled,\n            r = t.container.isErrorFirstInCallback,\n            i = ji.getInstance(this._iid),\n            s = bt.of(this._iid),\n            a = Ge.of(this._iid),\n            o = ge.of(this._iid),\n            l = x.get(this._iid).FileMessageQueue,\n            u = this.messageQueue[0],\n            c = u.pendingMessage;\n\n        if (u && u.state === l.State.SENT) {\n          u.state = l.State.DONE;\n          var d = u.response;\n          d && c && (d._isAutoResendRegistered = c._isAutoResendRegistered);\n          var h = u.error,\n              p = h ? new H(h.message, h.code) : null,\n              f = u.fileInfo.callback;\n\n          if (d && !h) {\n            d.reqId = c.reqId, d.requestState = i.MessageRequestState.SUCCEEDED, d.sendingStatus = i.MessageSendingStatus.SUCCEEDED;\n            var _ = i.currentUser;\n            if (_ && d._sender && _.userId === d._sender.userId && (_.nickname !== d._sender.nickname && (_.nickname = d._sender.nickname), _.plainProfileUrl !== d._sender.plainProfileUrl && (_.plainProfileUrl = d._sender.plainProfileUrl)), this.channel.isGroupChannel()) return this.channel.lastMessage = d, Object.keys(i.channelHandlers).forEach(function (t) {\n              i.channelHandlers[t].onChannelChanged(e.channel);\n            }), void s.upsert([this.channel]).then(function () {\n              o.send({\n                source: de.EVENT_CHANNEL_CHANGED,\n                payload: {\n                  channel: e.channel\n                }\n              });\n            }).then(function () {\n              return a.removeUnsentMessages({\n                channelUrl: e.channel.url,\n                sendingStatus: i.MessageSendingStatus.PENDING,\n                reqIds: [d.reqId]\n              });\n            }).then(function () {\n              return a.upsert([d], fe.SUCCEEDED);\n            }).then(function () {\n              nt._completeCurrentAndProcessNextAutoResend(i, d), o.send({\n                source: de.EVENT_MESSAGE_SENT,\n                payload: {\n                  channel: e.channel,\n                  message: d\n                }\n              });\n            }).catch(function (e) {\n              return J.error(e);\n            }).finally(function () {\n              f && (f.isPromisifyCallback || r ? f(null, d) : f(d, null)), e.messageQueue.shift(), e._handleMessageQueueUpdated(\"remove\");\n            });\n          }\n\n          if (h) {\n            if (d && d._isAutoResendRegistered && se.isAutoResendableError(h.code)) return this.messageQueue.shift(), void this._handleMessageQueueUpdated(\"remove\");\n            if (u.pendingMessage && (d = u.pendingMessage._clone()), d && h.code !== H.INVALID_PARAMETER) if (d.requestState = i.MessageRequestState.FAILED, h.code === H.FILE_UPLOAD_CANCEL_FAILED || h.code === H.REQUEST_CANCELED) {\n              if (d.sendingStatus = i.MessageSendingStatus.CANCELED, this.channel.isGroupChannel()) return void a.removeUnsentMessages({\n                channelUrl: this.channel.url,\n                sendingStatus: i.MessageSendingStatus.PENDING,\n                reqIds: [d.reqId]\n              }).then(function () {\n                o.send({\n                  source: de.LOCAL_MESSAGE_CANCELED,\n                  payload: {\n                    channel: e.channel,\n                    message: d\n                  }\n                });\n              }).catch(function (e) {\n                return J.error(e);\n              }).finally(function () {\n                f && (f.isPromisifyCallback || r ? f(p, d) : f(d, p)), e.messageQueue.shift(), e._handleMessageQueueUpdated(\"remove\");\n              });\n            } else if (d.sendingStatus = i.MessageSendingStatus.FAILED, d.errorCode = h.code, d.requestedMentionUserIds = u.fileInfo.mentionedUserIds, h.code === H.FILE_SIZE_LIMIT_EXCEEDED && d._messageParams && d._messageParams.file && (d._messageParams.file = null), this.channel.isGroupChannel()) return void (h.code === H.USER_NOT_MEMBER || h.code === H.CHANNEL_NOT_FOUND ? s.remove([this.channel.url]).then(function () {\n              return a.removeUnsentMessages({\n                channelUrl: e.channel.url,\n                sendingStatus: i.MessageSendingStatus.PENDING,\n                reqIds: [d.reqId]\n              });\n            }).then(function () {\n              o.send({\n                source: de.LOCAL_MESSAGE_FAILED,\n                payload: {\n                  channel: e.channel,\n                  message: d\n                }\n              });\n            }).catch(function (e) {\n              return J.error(e);\n            }).finally(function () {\n              f && (f.isPromisifyCallback || r ? f(p, d) : f(d, p)), e.messageQueue.shift(), e._handleMessageQueueUpdated(\"remove\");\n            }) : (n && se.isAutoResendableError(h.code) && (d.sendingStatus = i.MessageSendingStatus.PENDING, d.errorCode = 0, d._isAutoResendRegistered = !0), a.upsert([d], fe.UNSENT).then(function () {\n              nt._completeCurrentAndProcessNextAutoResend(i, d), o.send({\n                source: de.LOCAL_MESSAGE_FAILED,\n                payload: {\n                  channel: e.channel,\n                  message: d\n                }\n              });\n            }).catch(function (e) {\n              return J.error(e);\n            }).finally(function () {\n              var t = d._clone();\n\n              t.sendingStatus = i.MessageSendingStatus.FAILED, t.errorCode = h.code, t._isAutoResendRegistered = !1, f && (f.isPromisifyCallback || r ? f(p, t) : f(t, p)), e.messageQueue.shift(), e._handleMessageQueueUpdated(\"remove\");\n            })));\n          }\n\n          f && (f.isPromisifyCallback || r ? f(p, d) : f(d, p)), this.messageQueue.shift(), this._handleMessageQueueUpdated(\"remove\");\n        }\n      }\n    }, {\n      key: \"addJob\",\n      value: function value(e) {\n        this.messageQueue.push(e), this._handleMessageQueueUpdated(\"add\");\n      }\n    }, {\n      key: \"cancelUploadItemByRequestId\",\n      value: function value(e, t) {\n        this._finalizeUpload(e);\n\n        var n = this.messageQueue.map(function (e) {\n          return e.requestId;\n        }).indexOf(e);\n\n        if (n > -1) {\n          var r = x.get(this._iid).FileMessageQueue,\n              i = this.messageQueue[n];\n          !i || i.state !== r.State.UPLOADING && i.state !== r.State.PENDING || (i.state = r.State.SENT, i.response = null, i.error = new H(\"Uploading has been completed or canceled.\", H.FILE_UPLOAD_CANCEL_FAILED), this._handleMessageQueueUpdated(\"update\"));\n          var s = r.uploadRequest[e];\n          if (s) return \"function\" == typeof s.abort ? s.abort() : \"function\" == typeof s.cancel && s.cancel(\"Upload has been canceled.\"), t(null, !0), !0;\n          t(new H(\"Uploading has been completed or canceled.\", H.FILE_UPLOAD_CANCEL_FAILED), !1);\n        } else t(new H(\"Uploading has been completed or canceled.\", H.FILE_UPLOAD_CANCEL_FAILED), !1);\n\n        return !1;\n      }\n    }], [{\n      key: \"State\",\n      get: function get() {\n        return {\n          PENDING: \"pending\",\n          UPLOADING: \"uploading\",\n          UPLOADED: \"uploaded\",\n          SENDING: \"sending\",\n          SENT: \"sent\",\n          DONE: \"done\"\n        };\n      }\n    }, {\n      key: \"getByChannelUrl\",\n      value: function value(e) {\n        return x.get(this._iid).FileMessageQueue.queueMap[e];\n      }\n    }, {\n      key: \"create\",\n      value: function value(e) {\n        var t = x.get(this._iid).FileMessageQueue;\n        return t.queueMap.hasOwnProperty(e.url) || (t.queueMap[e.url] = new t(e)), t.queueMap[e.url];\n      }\n    }, {\n      key: \"delete\",\n      value: function value(e) {\n        var t = x.get(this._iid).FileMessageQueue;\n        t.queueMap.hasOwnProperty(e) && delete t.queueMap[e];\n      }\n    }, {\n      key: \"clear\",\n      value: function value() {\n        Ft[this._iid] = {};\n      }\n    }, {\n      key: \"queueMap\",\n      get: function get() {\n        return Ft[this._iid] || (Ft[this._iid] = {}), Ft[this._iid];\n      }\n    }, {\n      key: \"uploadRequest\",\n      get: function get() {\n        return Ht[this._iid] || (Ht[this._iid] = {}), Ht[this._iid];\n      }\n    }]), e;\n  }();\n\n  Gt.Job = function () {\n    return h(function e(t) {\n      var n = t.fileInfo,\n          r = t.requestId,\n          i = t.pendingMessage,\n          s = t.state,\n          a = t.error,\n          o = void 0 === a ? null : a,\n          l = t.response,\n          u = void 0 === l ? null : l;\n      c(this, e), this.fileInfo = n, this.requestId = r, this.pendingMessage = i, this.state = s || Gt.State.PENDING, this.error = o, this.response = u;\n    });\n  }();\n\n  var xt,\n      jt = {},\n      Bt = function () {\n    function e(e) {\n      var t = e.dbname,\n          n = e.itemSizeLimit,\n          r = void 0 === n ? 1048576 : n,\n          i = e.cacheLimit,\n          s = void 0 === i ? 256 : i,\n          a = e.blockHashBase,\n          o = void 0 === a ? 2 : a,\n          l = e.blockHashMultiplier,\n          u = void 0 === l ? 10 : l,\n          c = e.blockHashConstant,\n          d = void 0 === c ? 11 : c,\n          h = e.transactionApplyDelay,\n          p = void 0 === h ? 200 : h,\n          f = e.disableLogger,\n          _ = void 0 !== f && f;\n\n      return jt[t] || (this.itemSizeLimit = r, this.cacheLimit = s, this.blockHashBase = o, this.blockHashMultiplier = u, this.blockHashConstant = d, this.transactionApplyDelay = p, this.disableLogger = _, jt[t] = this), jt[t];\n    }\n\n    return e.get = function (e) {\n      return jt[e];\n    }, e;\n  }();\n\n  !function (e) {\n    e[e.UNKNOWN_ERROR = 6e7] = \"UNKNOWN_ERROR\", e[e.STORE_NOT_DEFINED = 61001e3] = \"STORE_NOT_DEFINED\", e[e.STORE_NOT_AVAILABLE = 61001001] = \"STORE_NOT_AVAILABLE\", e[e.STORE_NOT_AVAILABLE_IN_PRIVATE_BROWSING = 61001002] = \"STORE_NOT_AVAILABLE_IN_PRIVATE_BROWSING\", e[e.STORE_IS_FULL = 61001003] = \"STORE_IS_FULL\", e[e.STORE_INVALID_KEY_TYPE = 61002e3] = \"STORE_INVALID_KEY_TYPE\", e[e.STORE_BROKEN_INTEGRITY = 61002001] = \"STORE_BROKEN_INTEGRITY\", e[e.STORE_BROKEN_BLOB = 61002002] = \"STORE_BROKEN_BLOB\", e[e.STORE_ENCRYPTION_INVALID = 61002003] = \"STORE_ENCRYPTION_INVALID\", e[e.STORE_ITEM_SIZE_LIMIT_EXCEEDED = 61017e3] = \"STORE_ITEM_SIZE_LIMIT_EXCEEDED\", e[e.STORE_READ_FAILED = 61017001] = \"STORE_READ_FAILED\", e[e.STORE_WRITE_FAILED = 61017002] = \"STORE_WRITE_FAILED\", e[e.DATABASE_SCHEMA_NOT_ON_UPGRADE = 62002e3] = \"DATABASE_SCHEMA_NOT_ON_UPGRADE\", e[e.COLLECTION_NOT_READY = 63001e3] = \"COLLECTION_NOT_READY\", e[e.COLLECTION_KEY_NOT_MATCH = 63002e3] = \"COLLECTION_KEY_NOT_MATCH\", e[e.COLLECTION_QUERY_NOT_VALID = 63002001] = \"COLLECTION_QUERY_NOT_VALID\", e[e.COLLECTION_KEY_NOT_FOUND = 63004e3] = \"COLLECTION_KEY_NOT_FOUND\", e[e.COLLECTION_KEY_NOT_GIVEN = 63004001] = \"COLLECTION_KEY_NOT_GIVEN\", e[e.COLLECTION_INSERT_DUPLICATE = 63009e3] = \"COLLECTION_INSERT_DUPLICATE\", e[e.COLLECTION_WRITE_FAILED = 63017e3] = \"COLLECTION_WRITE_FAILED\", e[e.COLLECTION_ITEM_SIZE_LIMIT_EXCEEDED = 63017001] = \"COLLECTION_ITEM_SIZE_LIMIT_EXCEEDED\", e[e.INDEX_TABLE_IS_REQUIRED = 65001e3] = \"INDEX_TABLE_IS_REQUIRED\", e[e.INDEX_TYPE_NOT_MATCH = 65002e3] = \"INDEX_TYPE_NOT_MATCH\", e[e.COMPARE_TYPE_NOT_MATCH = 69002001] = \"COMPARE_TYPE_NOT_MATCH\", e[e.CIRCULAR_REFERENCE_FOUND = 69002002] = \"CIRCULAR_REFERENCE_FOUND\";\n  }(xt || (xt = {}));\n\n  var Vt,\n      qt = function (e) {\n    function t(n) {\n      var r = n.code,\n          i = void 0 === r ? xt.UNKNOWN_ERROR : r,\n          s = n.message,\n          a = void 0 === s ? \"Unknown error occurred.\" : s,\n          o = e.call(this, a) || this;\n      return o.code = i, Object.setPrototypeOf(o, t.prototype), o;\n    }\n\n    return k(t, e), Object.defineProperty(t, \"storeNotDefined\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_NOT_DEFINED,\n          message: \"Store is not defined. Specify the store on NestDB()\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"storeNotAvailable\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_NOT_AVAILABLE,\n          message: \"Store is not available. Check your environment settings.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"storeNotAvailableInPrivateBrowsing\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_NOT_AVAILABLE_IN_PRIVATE_BROWSING,\n          message: \"Store is not available because it is in private browsing.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"storeIsFull\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_IS_FULL,\n          message: \"Store is full.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"storeKeyTypeIsInvalid\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_INVALID_KEY_TYPE,\n          message: \"Store key should be string type.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"storeBrokenIntegrity\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_BROKEN_INTEGRITY,\n          message: \"Data should be in a store but it does not. Integrity is broken.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"storeBrokenBlob\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_BROKEN_BLOB,\n          message: \"Data should be in a store but it does not. Blob data is broken.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"storeEncryptionInvalid\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_ENCRYPTION_INVALID,\n          message: \"Encryption algorithm has changed. All the store should reset.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"storeItemSizeExceeded\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_ITEM_SIZE_LIMIT_EXCEEDED,\n          message: \"The size of the item exceeds the limit that the store allows.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"storeReadFailed\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_READ_FAILED,\n          message: \"Failed to read from store.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"storeWriteFailed\", {\n      get: function get() {\n        return new t({\n          code: xt.STORE_WRITE_FAILED,\n          message: \"Failed to write to store.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"databaseSchemaNotOnUpgrade\", {\n      get: function get() {\n        return new t({\n          code: xt.DATABASE_SCHEMA_NOT_ON_UPGRADE,\n          message: \"Committing schema is not allowed when upgrade is not running.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"collectionNotReady\", {\n      get: function get() {\n        return new t({\n          code: xt.COLLECTION_NOT_READY,\n          message: \"Collection is not ready due to an error during initialization.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"collectionKeyNotMatch\", {\n      get: function get() {\n        return new t({\n          code: xt.COLLECTION_KEY_NOT_MATCH,\n          message: \"keyName of collection could not change.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"collectionQueryNotValid\", {\n      get: function get() {\n        return new t({\n          code: xt.COLLECTION_QUERY_NOT_VALID,\n          message: \"Query parameter is not a valid format.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"collectionInsertDuplicate\", {\n      get: function get() {\n        return new t({\n          code: xt.COLLECTION_INSERT_DUPLICATE,\n          message: \"The key already exists.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"collectionKeyNotFound\", {\n      get: function get() {\n        return new t({\n          code: xt.COLLECTION_KEY_NOT_FOUND,\n          message: \"The key is not found.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"collectionKeyNotGiven\", {\n      get: function get() {\n        return new t({\n          code: xt.COLLECTION_KEY_NOT_GIVEN,\n          message: \"The item should contain [keyName] property.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"collectionWriteFailed\", {\n      get: function get() {\n        return new t({\n          code: xt.COLLECTION_WRITE_FAILED,\n          message: \"Failed to write an item.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"collectionItemSizeExceeded\", {\n      get: function get() {\n        return new t({\n          code: xt.COLLECTION_ITEM_SIZE_LIMIT_EXCEEDED,\n          message: \"The size of the item exceeds the limit that a collection allows.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"indexTableIsRequired\", {\n      get: function get() {\n        return new t({\n          code: xt.INDEX_TABLE_IS_REQUIRED,\n          message: \"Index table is required.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"indexTypesNotMatch\", {\n      get: function get() {\n        return new t({\n          code: xt.INDEX_TYPE_NOT_MATCH,\n          message: \"Indexed column should have primitive type.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"compareTypesNotMatch\", {\n      get: function get() {\n        return new t({\n          code: xt.COMPARE_TYPE_NOT_MATCH,\n          message: \"Values to compare have different types.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"circularReferenceFound\", {\n      get: function get() {\n        return new t({\n          code: xt.CIRCULAR_REFERENCE_FOUND,\n          message: \"Cannot handle circular referenced object.\"\n        });\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(Error);\n\n  !function (e) {\n    e.INIT = \"init\", e.READY = \"ready\", e.CLOSED = \"closed\";\n  }(Vt || (Vt = {}));\n\n  var Kt,\n      zt = function zt(e, t) {\n    if (void 0 === t && (t = new WeakMap()), \"object\" == typeof e && null !== e) {\n      if (t.has(e)) throw qt.circularReferenceFound;\n      t.set(e, !0);\n      var n = null;\n      if (Array.isArray(e)) n = e.map(function (e) {\n        return zt(e, t);\n      });else if (e instanceof RegExp) n = e;else if (e instanceof Date) n = e;else for (var r in n = {}, e) {\n        n[r] = zt(e[r], t);\n      }\n      return t.delete(e), n;\n    }\n\n    return e;\n  },\n      Yt = function Yt(e, t) {\n    if (null == t) return 1;\n    if (null == e) return -1;\n    if (typeof e != typeof t) throw qt.compareTypesNotMatch;\n    var n = 0;\n\n    switch (typeof e) {\n      case \"boolean\":\n      case \"number\":\n        n = e - t;\n        break;\n\n      case \"string\":\n        n = e.localeCompare(t);\n    }\n\n    return n;\n  },\n      Qt = function Qt(e, t) {\n    for (var n = 0, r = 0; r < e.length; r++) {\n      n = e.charCodeAt(r) + (n << 6) + (n << 16) - n;\n    }\n\n    return (n >>> 0) % t;\n  },\n      Wt = function Wt(e) {\n    return new Promise(function (t) {\n      setTimeout(function () {\n        return t();\n      }, e);\n    });\n  },\n      Jt = function Jt(e, t) {\n    if (!t) return !1;\n\n    if (\"function\" != typeof e) {\n      for (var n in e) {\n        if ([\"/and\", \"&&\"].includes(n)) {\n          if (e[n].some(function (e) {\n            return !Jt(e, t);\n          })) return !1;\n        } else if ([\"/or\", \"||\"].includes(n)) {\n          if (e[n].every(function (e) {\n            return !Jt(e, t);\n          })) return !1;\n        } else if (\"/where\" === n) {\n          if (!(0, e[n])(t)) return !1;\n        } else {\n          var r = n;\n\n          if (\"object\" == typeof e[r]) {\n            var i = e[r];\n\n            for (var s in i) {\n              switch (s) {\n                case \"/eq\":\n                case \"=\":\n                  if ((a = t[r]) !== (o = i[s])) return !1;\n                  break;\n\n                case \"/neq\":\n                case \"!=\":\n                  if ((a = t[r]) === (o = i[s])) return !1;\n                  break;\n\n                case \"/gt\":\n                case \">\":\n                  var a = t[r],\n                      o = i[s];\n                  if (!(Yt(a, o) > 0)) return !1;\n                  break;\n\n                case \"/gte\":\n                case \">=\":\n                  a = t[r], o = i[s];\n                  if (!(Yt(a, o) >= 0)) return !1;\n                  break;\n\n                case \"/lt\":\n                case \"<\":\n                  a = t[r], o = i[s];\n                  if (!(Yt(a, o) < 0)) return !1;\n                  break;\n\n                case \"/lte\":\n                case \"<=\":\n                  a = t[r], o = i[s];\n                  if (!(Yt(a, o) <= 0)) return !1;\n                  break;\n\n                case \"/in\":\n                  a = t[r];\n                  if (!(o = i[s]).includes(a)) return !1;\n                  break;\n\n                case \"/nin\":\n                  a = t[r];\n                  if ((o = i[s]).includes(a)) return !1;\n                  break;\n\n                case \"/contain\":\n                  a = t[r], o = i[s];\n                  if (!a.includes(o)) return !1;\n                  break;\n\n                case \"/regex\":\n                  a = t[r];\n                  if (!(o = i[s]).test(a)) return !1;\n                  break;\n\n                case \"/where\":\n                  a = t[r];\n                  if (!(0, i[s])(a)) return !1;\n              }\n            }\n          } else if (\"function\" == typeof e[r]) {\n            if (!e[r](t[r])) return !1;\n          } else if (e[r] !== t[r]) return !1;\n        }\n      }\n\n      return !0;\n    }\n\n    return e(t);\n  },\n      Xt = function Xt() {},\n      Zt = function Zt() {\n    return Promise.resolve();\n  },\n      $t = function $t(e) {\n    return e;\n  },\n      en = function en(e, t) {\n    t(null);\n  };\n\n  !function (e) {\n    e[e.FORWARD = 0] = \"FORWARD\", e[e.BACKWARD = 1] = \"BACKWARD\";\n  }(Kt || (Kt = {}));\n\n  var tn,\n      nn,\n      rn,\n      sn = function () {\n    function e(e) {\n      var t = e.initialPrevValue,\n          n = void 0 === t ? null : t,\n          r = e.initialNextValue,\n          i = void 0 === r ? null : r,\n          s = e.iterator,\n          a = e.map,\n          o = void 0 === a ? $t : a,\n          l = e.backward,\n          u = void 0 === l ? Zt : l,\n          c = e.forward,\n          d = void 0 === c ? Zt : c,\n          h = e.complete,\n          p = void 0 === h ? Xt : h;\n      this._prevValue = n, this._nextValue = i, this._error = null, this._map = o, this._backward = u, this._forward = d, this._iterator = s, this._complete = p;\n    }\n\n    return Object.defineProperty(e.prototype, \"prevValue\", {\n      get: function get() {\n        return this._map(this._prevValue);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"nextValue\", {\n      get: function get() {\n        return this._map(this._nextValue);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"error\", {\n      get: function get() {\n        return this._error;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"hasPrevious\", {\n      get: function get() {\n        return !!this._prevValue;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"hasNext\", {\n      get: function get() {\n        return !!this._nextValue;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.prev = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t, n;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              if (!this.hasPrevious) return [3, 6];\n              r.label = 1;\n\n            case 1:\n              return r.trys.push([1, 3,, 4]), e = this._prevValue, t = this, [4, this._backward()];\n\n            case 2:\n              return t._prevValue = r.sent() || null, this._nextValue = e, [3, 4];\n\n            case 3:\n              return n = r.sent(), this._error = n, [3, 4];\n\n            case 4:\n              return [4, this._iterator(this)];\n\n            case 5:\n              return [2, r.sent()];\n\n            case 6:\n              this._complete(), r.label = 7;\n\n            case 7:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.next = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t, n;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              if (!this.hasNext) return [3, 6];\n              r.label = 1;\n\n            case 1:\n              return r.trys.push([1, 3,, 4]), e = this._nextValue, t = this, [4, this._forward()];\n\n            case 2:\n              return t._nextValue = r.sent() || null, this._prevValue = e, [3, 4];\n\n            case 3:\n              return n = r.sent(), this._error = n, [3, 4];\n\n            case 4:\n              return [4, this._iterator(this)];\n\n            case 5:\n              return [2, r.sent()];\n\n            case 6:\n              this._complete(), r.label = 7;\n\n            case 7:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.stop = function () {\n      this._prevValue = null, this._nextValue = null, this._complete();\n    }, e;\n  }(),\n      an = function () {\n    function e(e) {\n      var t = e.condition,\n          n = void 0 === t ? {} : t,\n          r = e.backward,\n          i = void 0 !== r && r,\n          s = e.blockManager,\n          a = e.indexer;\n      this.condition = n, this.backward = i, this._blockManager = s, this._indexer = a;\n    }\n\n    return e.prototype.findOptimizedStartPosition = function () {\n      var e = this,\n          t = [\"=\", \"/eq\", \">\", \">=\", \"/gt\", \"/gte\"],\n          n = [\"=\", \"/eq\", \"<\", \"<=\", \"/lt\", \"/lte\"];\n\n      if (this.backward) {\n        var r = this._indexer.origin.length - 1;\n        if (\"function\" != typeof this.condition) for (var i in this._indexer.fields) {\n          var s = this._indexer.fields[i],\n              a = 1;\n          if (\"-\" === s[0] && (s = s.slice(1), a = -1), this.condition[s]) if (\"object\" == typeof this.condition[s]) {\n            var o = a > 0 ? n : t;\n\n            for (var l in this.condition[s]) {\n              if (o.includes(l)) for (var u = r; u >= 0; u--) {\n                if (a * Yt(this._indexer.origin[u].columnValues[i], this.condition[s][l]) <= 0) {\n                  r = u;\n                  break;\n                }\n              }\n            }\n          } else for (u = r; u >= 0; u--) {\n            if (a * Yt(this._indexer.origin[u].columnValues[i], this.condition[s]) <= 0) {\n              r = u;\n              break;\n            }\n          }\n        }\n        return Math.min(r + 1, this._indexer.origin.length - 1);\n      }\n\n      var c = 0;\n      if (\"function\" != typeof this.condition) for (var d = function d(r) {\n        var i = h._indexer.fields[r],\n            s = 1;\n        if (\"-\" === i[0] && (i = i.slice(1), s = -1), h.condition[i]) if (\"object\" == typeof h.condition[i]) Object.keys(h.condition[i]).forEach(function (a) {\n          if ((s > 0 ? t : n).includes(a)) for (var o = c; o < e._indexer.origin.length; o++) {\n            if (s * Yt(e._indexer.origin[o].columnValues[r], e.condition[i][a]) >= 0) {\n              c = o;\n              break;\n            }\n          }\n        });else for (var a = c; a < h._indexer.origin.length; a++) {\n          if (s * Yt(h._indexer.origin[a].columnValues[r], h.condition[i]) >= 0) {\n            c = a;\n            break;\n          }\n        }\n      }, h = this, i = 0; i < this._indexer.fields.length; i++) {\n        d(i);\n      }\n      return Math.max(c - 1, 0);\n    }, e.prototype.each = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t,\n            n,\n            r,\n            i,\n            s,\n            a,\n            o,\n            l = this;\n        return P(this, function (u) {\n          switch (u.label) {\n            case 0:\n              if (t = this.findOptimizedStartPosition(), n = 0, this.backward && this._indexer.origin[t] && (n = this._indexer.origin[t].keys.length - 1), r = function r() {\n                if (l._indexer.origin[t]) {\n                  if (!l._indexer.origin[t].keys[++n]) {\n                    if (!l._indexer.origin[++t]) return !1;\n                    n = 0;\n                  }\n\n                  return !0;\n                }\n\n                return !1;\n              }, i = function i() {\n                if (l._indexer.origin[t]) {\n                  if (!l._indexer.origin[t].keys[--n]) {\n                    if (!l._indexer.origin[--t]) return !1;\n                    n = l._indexer.origin[t].keys.length - 1;\n                  }\n\n                  return !0;\n                }\n\n                return !1;\n              }, s = null, !this._indexer.origin[t]) return [3, 4];\n              a = this.backward ? i : r, u.label = 1;\n\n            case 1:\n              return [4, this._blockManager.getFromBlock(this._indexer.origin[t].keys[n])];\n\n            case 2:\n              if (o = u.sent(), Jt(this.condition, o)) return s = o, [3, 4];\n              u.label = 3;\n\n            case 3:\n              if (a()) return [3, 1];\n              u.label = 4;\n\n            case 4:\n              return [4, new Promise(function (a) {\n                var o = new sn({\n                  initialNextValue: zt(s),\n                  iterator: e,\n                  forward: function forward() {\n                    return L(l, void 0, void 0, function () {\n                      var e, s;\n                      return P(this, function (a) {\n                        switch (a.label) {\n                          case 0:\n                            e = this.backward ? i : r, a.label = 1;\n\n                          case 1:\n                            return e() ? [4, this._blockManager.getFromBlock(this._indexer.origin[t].keys[n])] : [3, 3];\n\n                          case 2:\n                            return s = a.sent(), Jt(this.condition, s) ? [2, zt(s)] : [3, 1];\n\n                          case 3:\n                            return [2, null];\n                        }\n                      });\n                    });\n                  },\n                  backward: function backward() {\n                    return L(l, void 0, void 0, function () {\n                      var e, s;\n                      return P(this, function (a) {\n                        switch (a.label) {\n                          case 0:\n                            e = this.backward ? r : i, a.label = 1;\n\n                          case 1:\n                            return e() ? [4, this._blockManager.getFromBlock(this._indexer.origin[t].keys[n])] : [3, 3];\n\n                          case 2:\n                            return s = a.sent(), Jt(this.condition, s) ? [2, zt(s)] : [3, 1];\n\n                          case 3:\n                            return [2, null];\n                        }\n                      });\n                    });\n                  },\n                  complete: a\n                });\n                e(o);\n              })];\n\n            case 5:\n              return [2, u.sent()];\n          }\n        });\n      });\n    }, e;\n  }(),\n      on = function () {\n    function e(e) {\n      var t = e.condition,\n          n = void 0 === t ? {} : t,\n          r = e.backward,\n          i = void 0 !== r && r,\n          s = e.mutex,\n          a = e.blockManager,\n          o = e.indexer;\n      this._mutex = s, this._iterator = new an({\n        condition: n,\n        backward: i,\n        blockManager: a,\n        indexer: o\n      });\n    }\n\n    return e.prototype.fetch = function (e) {\n      return void 0 === e && (e = {}), L(this, void 0, void 0, function () {\n        var t,\n            n,\n            r,\n            i,\n            s = this;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              if (t = Math.max(e.offset || 0, 0), 0 === (n = \"number\" == typeof e.limit ? e.limit : Number.MAX_SAFE_INTEGER)) return [2, []];\n              if (n < 0) throw qt.collectionQueryNotValid;\n              a.label = 1;\n\n            case 1:\n              return a.trys.push([1, 4,, 5]), r = [], [4, this._mutex.lock()];\n\n            case 2:\n              return a.sent(), [4, this._iterator.each(function (e) {\n                return L(s, void 0, void 0, function () {\n                  return P(this, function (i) {\n                    return e.error ? e.stop() : e.hasNext ? 0 === t ? (r.push(e.nextValue), 0 < n && n <= r.length ? e.stop() : e.next()) : (t--, e.next()) : e.stop(), [2];\n                  });\n                });\n              })];\n\n            case 3:\n              return a.sent(), this._mutex.unlock(), [2, r];\n\n            case 4:\n              throw i = a.sent(), this._mutex.unlock(), i;\n\n            case 5:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.count = function () {\n      return L(this, void 0, void 0, function () {\n        var e,\n            t,\n            n = this;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return r.trys.push([0, 3,, 4]), e = 0, [4, this._mutex.lock()];\n\n            case 1:\n              return r.sent(), [4, this._iterator.each(function (t) {\n                return L(n, void 0, void 0, function () {\n                  return P(this, function (n) {\n                    return t.error ? t.stop() : t.hasNext ? (e++, t.next()) : t.stop(), [2];\n                  });\n                });\n              })];\n\n            case 2:\n              return r.sent(), this._mutex.unlock(), [2, e];\n\n            case 3:\n              throw t = r.sent(), this._mutex.unlock(), t;\n\n            case 4:\n              return [2];\n          }\n        });\n      });\n    }, e;\n  }(),\n      ln = function ln(e) {\n    return \"\".concat(\"nest\", \"@\").concat(e);\n  },\n      un = function un(e, t) {\n    return \"\".concat(ln(e), \"/\").concat(t);\n  },\n      cn = function cn(e, t) {\n    return \"\".concat(un(e, t), \".metadata\");\n  },\n      dn = function dn(e, t) {\n    return \"\".concat(un(e, t), \"/block.\");\n  },\n      hn = function hn(e, t) {\n    return \"\".concat(un(e, t), \"/blob.\");\n  },\n      pn = function pn(e, t, n, r) {\n    return void 0 === r && (r = 0), \"\".concat(hn(e, t)).concat(n, \".\").concat(r);\n  },\n      fn = function () {\n    function e(e) {\n      var t = e.dbname,\n          n = e.collectionName,\n          r = e.store;\n      this.dbname = t, this.collectionName = n, this._store = r;\n    }\n\n    return e.prototype._makeShards = function (e, t) {\n      var n = Math.max(this._store.itemSizeLimit - 1024, 0);\n\n      if (n > 0) {\n        for (var r = Math.ceil(e.data.length / n), i = \"\".concat(r, \".\").concat(e.type, \".\").concat(t), s = [], a = 0; a < e.data.length; a += n) {\n          var o = e.data.slice(a, a + n);\n          s.push(o);\n        }\n\n        return {\n          blobId: i,\n          shards: s\n        };\n      }\n\n      return {\n        blobId: null,\n        shards: null\n      };\n    }, e.prototype._encode = function (e) {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, new Promise(function (t) {\n                var n = new FileReader();\n                n.onload = function () {\n                  t({\n                    data: n.result,\n                    type: e.type\n                  });\n                }, n.readAsDataURL(e);\n              })];\n\n            case 1:\n              return [2, t.sent()];\n          }\n        });\n      });\n    }, e.prototype._decode = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s, a;\n        return P(this, function (o) {\n          switch (o.label) {\n            case 0:\n              return \"undefined\" == typeof fetch ? [3, 3] : [4, fetch(e.data)];\n\n            case 1:\n              return [4, o.sent().blob()];\n\n            case 2:\n              return [2, o.sent()];\n\n            case 3:\n              for (512, t = [], n = atob(e.data.split(\",\")[1]), r = 0; r < n.length; r += 512) {\n                for (i = n.slice(r, r + 512), s = new Array(i.length), a = 0; a < i.length; a++) {\n                  s[a] = i.charCodeAt(a);\n                }\n\n                t.push(new Uint8Array(s));\n              }\n\n              return [2, new Blob(t, {\n                type: e.type\n              })];\n          }\n        });\n      });\n    }, e.prototype.get = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s, a, o, l;\n        return P(this, function (u) {\n          switch (u.label) {\n            case 0:\n              if (t = [], n = e.split(\".\"), r = n[0], i = n[1], !((s = parseInt(r)) > 0)) return [3, 6];\n              a = 0, u.label = 1;\n\n            case 1:\n              return a < s ? (o = pn(this.dbname, this.collectionName, e, a), [4, this._store.get(o)]) : [3, 4];\n\n            case 2:\n              if (!(l = u.sent()) || !l.d) throw qt.storeBrokenBlob;\n              t.push(l.d), u.label = 3;\n\n            case 3:\n              return a++, [3, 1];\n\n            case 4:\n              return [4, this._decode({\n                data: t.join(\"\"),\n                type: i\n              })];\n\n            case 5:\n              return [2, u.sent()];\n\n            case 6:\n              return [2, null];\n          }\n        });\n      });\n    }, e.prototype.save = function (e, t) {\n      return void 0 === t && (t = \"\".concat(Date.now())), L(this, void 0, void 0, function () {\n        var n, r, i, s, a, o, l;\n        return P(this, function (u) {\n          switch (u.label) {\n            case 0:\n              return n = [], [4, this._encode(e)];\n\n            case 1:\n              if (r = u.sent(), i = this._makeShards(r, t), s = i.blobId, a = i.shards, !s) return [3, 3];\n\n              for (o = 0; o < a.length; o++) {\n                l = pn(this.dbname, this.collectionName, s, o), n.push({\n                  key: l,\n                  value: {\n                    d: a[o]\n                  },\n                  generation: 1\n                });\n              }\n\n              return [4, this._store.setMany(n)];\n\n            case 2:\n              if (u.sent().some(function (e) {\n                return e instanceof Error;\n              })) throw qt.storeWriteFailed;\n              return [2, s];\n\n            case 3:\n              return [2, null];\n          }\n        });\n      });\n    }, e.prototype.remove = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i;\n        return P(this, function (s) {\n          switch (s.label) {\n            case 0:\n              if (t = [], n = e.split(\".\")[0], !((r = parseInt(n)) > 0)) return [3, 2];\n\n              for (i = 0; i < r; i++) {\n                t.push(pn(this.dbname, this.collectionName, e, i));\n              }\n\n              return [4, this._store.removeMany(t)];\n\n            case 1:\n              s.sent(), s.label = 2;\n\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.clear = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t, n, r, i, s;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return e = hn(this.dbname, this.collectionName), t = [], [4, this._store.getAllKeys()];\n\n            case 1:\n              for (n = a.sent(), r = 0, i = n; r < i.length; r++) {\n                (s = i[r]).startsWith(e) && t.push(s);\n              }\n\n              return [4, this._store.removeMany(n)];\n\n            case 2:\n              return a.sent(), [2];\n          }\n        });\n      });\n    }, e;\n  }();\n\n  !function (e) {\n    e[e.COMMIT = 0] = \"COMMIT\", e[e.WRITE = 1] = \"WRITE\", e[e.ERROR = 2] = \"ERROR\";\n  }(tn || (tn = {})), function (e) {\n    e.PENDING = \"pending\", e.PERSISTENT = \"persistent\", e.VOLATILE = \"volatile\";\n  }(nn || (nn = {})), function (e) {\n    e[e.NO_CACHE = 0] = \"NO_CACHE\", e[e.DEFAULT = 1] = \"DEFAULT\", e[e.PERSISTENT = 2] = \"PERSISTENT\";\n  }(rn || (rn = {}));\n\n  var _n = [nn.PENDING, nn.VOLATILE],\n      gn = {},\n      yn = function () {\n    function e(e) {\n      var t = e.dbname,\n          n = e.limit,\n          r = void 0 === n ? 256 : n;\n      return gn[t] || (this.dbname = t, this._items = [], this._limit = r, gn[t] = this), gn[t];\n    }\n\n    return e.get = function (e) {\n      return gn[e];\n    }, Object.defineProperty(e.prototype, \"items\", {\n      get: function get() {\n        return this._items;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.find = function (e, t, n) {\n      return void 0 === n && (n = rn.DEFAULT), L(this, void 0, void 0, function () {\n        var r, i;\n        return P(this, function (s) {\n          switch (s.label) {\n            case 0:\n              return (r = this.get(t)) ? [3, 2] : [4, e.get(t)];\n\n            case 1:\n              return (i = s.sent()) && (r = {\n                key: t,\n                value: i,\n                generation: 1,\n                state: n === rn.PERSISTENT ? nn.PERSISTENT : nn.VOLATILE\n              }, this.put(r)), [3, 3];\n\n            case 2:\n              n === rn.PERSISTENT && (r.state = nn.PERSISTENT), s.label = 3;\n\n            case 3:\n              return [2, r];\n          }\n        });\n      });\n    }, e.prototype.get = function (e, t) {\n      void 0 === t && (t = rn.DEFAULT);\n\n      var n = this._items.map(function (e) {\n        return e.key;\n      }).indexOf(e);\n\n      if (n > -1) {\n        var r = this._items[n];\n        return t === rn.PERSISTENT && (r.state = nn.PERSISTENT), t !== rn.NO_CACHE && this.put(r), r;\n      }\n\n      return null;\n    }, e.prototype.put = function (e) {\n      if (this._limit > 0) {\n        var t = this._items.map(function (e) {\n          return e.key;\n        }).indexOf(e.key);\n\n        if (t > -1) _n.includes(this._items[t].state) && _n.includes(e.state) ? (this._items.splice(t, 1), this._items.push(e)) : (this._items[t].state = e.state, this._items[t].generation = e.generation, this._items[t].value = e.value);else {\n          this._items.push(e);\n\n          var n = this._items.filter(function (e) {\n            return e.state === nn.VOLATILE;\n          }),\n              r = n.length - this._limit;\n\n          if (r > 0) {\n            for (var i = [], s = 0, a = this._items; s < a.length; s++) {\n              var o = a[s];\n              o.state === nn.VOLATILE && r > 0 ? r-- : i.push(o);\n            }\n\n            this._items = i;\n          }\n        }\n      }\n    }, e.prototype.remove = function (e) {\n      var t = this._items.map(function (e) {\n        return e.key;\n      }).indexOf(e);\n\n      t > -1 && this._items.splice(t, 1);\n    }, e.prototype.clearByCondition = function (e) {\n      this._items = this._items.filter(function (t) {\n        return !e(t);\n      });\n    }, e.prototype.clear = function (e) {\n      void 0 === e && (e = !1), this._items = e ? [] : this._items.filter(function (e) {\n        return e.state !== nn.VOLATILE;\n      });\n    }, e;\n  }(),\n      mn = function () {\n    function e(e) {\n      var t = e.dbname,\n          n = e.collectionName,\n          r = e.store;\n      this._metadata = null, this._requests = [], this._onCommit = new Map(), this._onWrite = new Map(), this._onError = new Map(), this.dbname = t, this.collectionName = n, this.metadataKey = function (e, t) {\n        return \"\".concat(un(e, t), \"/trans.metadata\");\n      }(t, n), this.recordsetKey = function (e, t) {\n        return \"\".concat(un(e, t), \"/trans.recordset\");\n      }(t, n), this._store = r;\n    }\n\n    return Object.defineProperty(e.prototype, \"generation\", {\n      get: function get() {\n        return this._metadata ? this._metadata.generation : 0;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"requestCount\", {\n      get: function get() {\n        return this._requests.length;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype._getReducedRecordset = function (e) {\n      return void 0 === e && (e = []), L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, this._store.get(this.recordsetKey)];\n\n            case 1:\n              return (t = n.sent() || []).push.apply(t, e), [2, this._reduceRecordSet(t)];\n          }\n        });\n      });\n    }, e.prototype._reduceRecordSet = function (e) {\n      for (var t = [], n = {}, r = e.length - 1; r >= 0; r--) {\n        for (var i = e[r], s = [], a = i.requests.length - 1; a >= 0; a--) {\n          var o = i.requests[a],\n              l = o.data;\n          n[l.key] || (s.unshift(o), n[l.key] = !0);\n        }\n\n        s.length > 0 && (i.requests = s, t.unshift(i));\n      }\n\n      return t;\n    }, e.prototype._applyRecord = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n, r, i, s, a, o, l, u, c;\n        return P(this, function (d) {\n          switch (d.label) {\n            case 0:\n              n = yn.get(this.dbname), r = t.generation, i = t.requests, s = null, d.label = 1;\n\n            case 1:\n              return d.trys.push([1, 3,, 4]), [4, this._store.setMany(i.map(function (e) {\n                return _R(_R({}, e.data), {\n                  generation: r\n                });\n              }))];\n\n            case 2:\n              for (a = d.sent(), o = 0; o < i.length; o++) {\n                a[o] instanceof Error && (s || (s = a[o]), l = i[o].data, n.put(_R(_R({}, l), {\n                  generation: r,\n                  state: nn.PERSISTENT\n                })));\n              }\n\n              return [3, 4];\n\n            case 3:\n              return u = d.sent(), s = u, [3, 4];\n\n            case 4:\n              return s ? [3, 6] : (c = e.filter(function (e) {\n                return e.generation !== r;\n              }), [4, this._store.set({\n                key: this.recordsetKey,\n                value: c,\n                generation: r\n              })]);\n\n            case 5:\n              return d.sent(), this._onWrite.forEach(function (e) {\n                e(i.map(function (e) {\n                  return e.data;\n                }));\n              }), [3, 7];\n\n            case 6:\n              this._onError.forEach(function (e) {\n                return e(s);\n              }), d.label = 7;\n\n            case 7:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.init = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t, n, r, i;\n        return P(this, function (s) {\n          switch (s.label) {\n            case 0:\n              return e = this, [4, this._store.get(this.metadataKey)];\n\n            case 1:\n              return e._metadata = s.sent() || {\n                generation: 1\n              }, [4, this._getReducedRecordset()];\n\n            case 2:\n              t = s.sent(), n = 0, r = t, s.label = 3;\n\n            case 3:\n              return n < r.length ? (i = r[n], [4, this._applyRecord(t, i)]) : [3, 6];\n\n            case 4:\n              s.sent(), s.label = 5;\n\n            case 5:\n              return n++, [3, 3];\n\n            case 6:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.on = function (e, t, n) {\n      switch (e) {\n        case tn.COMMIT:\n          this._onCommit.set(t, n);\n\n          break;\n\n        case tn.WRITE:\n          this._onWrite.set(t, n);\n\n          break;\n\n        case tn.ERROR:\n          this._onError.set(t, n);\n\n      }\n    }, e.prototype.requestWrite = function (e, t) {\n      void 0 === t && (t = null), this._requests.push({\n        data: e,\n        options: t\n      }), yn.get(this.dbname).put(_R({\n        state: nn.PENDING,\n        generation: this.generation\n      }, e));\n    }, e.prototype.requestMultipleWrite = function (e, t) {\n      void 0 === t && (t = null);\n\n      for (var n = yn.get(this.dbname), r = 0, i = e; r < i.length; r++) {\n        var s = i[r];\n        this._requests.push({\n          data: s,\n          options: t\n        }), n.put(_R({\n          state: nn.PENDING,\n          generation: this.generation\n        }, s));\n      }\n    }, e.prototype.clear = function () {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (e) {\n          return yn.get(this.dbname).clearByCondition(function (e) {\n            return e.state === nn.PENDING;\n          }), this._requests = [], [2];\n        });\n      });\n    }, e.prototype.commit = function () {\n      return L(this, void 0, void 0, function () {\n        var e,\n            t,\n            n,\n            r,\n            i,\n            s,\n            a,\n            o,\n            l,\n            u,\n            c,\n            d,\n            h = this;\n        return P(this, function (p) {\n          switch (p.label) {\n            case 0:\n              if (!((e = this._requests).length > 0)) return [3, 4];\n\n              for (t = [], n = {}, o = e.length - 1; o >= 0; o--) {\n                r = e[o], u = r.data, n[u.key] || (n[u.key] = !0, t.unshift(r));\n              }\n\n              return i = {\n                generation: this.generation,\n                requests: t\n              }, [4, this._getReducedRecordset([i])];\n\n            case 1:\n              return s = p.sent(), [4, this._store.set({\n                key: this.recordsetKey,\n                value: s,\n                generation: this.generation\n              })];\n\n            case 2:\n              return p.sent(), this._metadata.generation++, [4, this._store.set({\n                key: this.metadataKey,\n                value: this._metadata,\n                generation: 1\n              })];\n\n            case 3:\n              for (p.sent(), a = yn.get(this.dbname), o = 0; o < t.length; o++) {\n                l = t[o], u = l.data, c = l.options, a.put(_R(_R({}, u), {\n                  generation: i.generation,\n                  state: c && c.persistent ? nn.PERSISTENT : nn.VOLATILE\n                }));\n              }\n\n              this._requests = [], this._onCommit.forEach(function (t) {\n                t(e.map(function (e) {\n                  return e.data;\n                }));\n              }), d = Bt.get(this.dbname), setTimeout(function () {\n                try {\n                  h._applyRecord(s, i);\n                } catch (e) {\n                  h._onError.forEach(function (t) {\n                    return t(e);\n                  });\n                }\n              }, d.transactionApplyDelay), p.label = 4;\n\n            case 4:\n              return [2];\n          }\n        });\n      });\n    }, e;\n  }(),\n      En = function () {\n    function e(e) {\n      var t = e.blockId,\n          n = e.keyName,\n          r = e.items,\n          i = void 0 === r ? [] : r,\n          s = e.limit;\n      this.blockId = t, this.keyName = n, this.limit = s, this._items = w([], i, !0);\n    }\n\n    return e.createFromCacheItem = function (t) {\n      return t ? new e(t.value) : null;\n    }, Object.defineProperty(e.prototype, \"isEmpty\", {\n      get: function get() {\n        return 0 === this._items.length;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"items\", {\n      get: function get() {\n        return this._items;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.serialize = function () {\n      return {\n        blockId: this.blockId,\n        keyName: this.keyName,\n        limit: this.limit,\n        items: this._items\n      };\n    }, e.prototype.getItemByKey = function (e) {\n      var t = this;\n      return this._items.find(function (n) {\n        var r = n[t.keyName];\n        return e === r;\n      });\n    }, e.prototype.has = function (e) {\n      var t = this;\n      return this._items.map(function (e) {\n        return e[t.keyName];\n      }).includes(e);\n    }, e.prototype.add = function (e) {\n      var t = this,\n          n = this._items.map(function (e) {\n        return e[t.keyName];\n      }).indexOf(e[this.keyName]);\n\n      return n < 0 ? this._items.length < this.limit && (this._items.push(e), !0) : (this._items[n] = e, !0);\n    }, e.prototype.remove = function (e) {\n      for (var t in this._items) {\n        if (this._items[t][this.keyName] === e) return this._items.splice(parseInt(t), 1), !0;\n      }\n\n      return !1;\n    }, e.prototype.clear = function () {\n      this._items = [];\n    }, e;\n  }(),\n      vn = function () {\n    function e(e) {\n      var t = e.dbname,\n          n = e.collectionName,\n          r = e.metadata,\n          i = e.hashFunction,\n          s = void 0 === i ? Qt : i,\n          a = e.transaction,\n          o = e.store;\n      this.dbname = t, this.collectionName = n, this.hashFunction = s, this.metadata = r, this._transaction = a, this._store = o;\n    }\n\n    return Object.defineProperty(e.prototype, \"keyName\", {\n      get: function get() {\n        return this.metadata.keyName;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.createBlockId = function (e, t) {\n      return void 0 === t && (t = this.metadata.blockLevel), n = this.dbname, r = this.collectionName, i = t, s = \"\".concat(function (e, t, n) {\n        var r = n.base * Math.pow(n.multiplier, t) + n.constant;\n        return (n.hashFunction || Qt)(e, r);\n      }(e, t, {\n        hashFunction: this.hashFunction,\n        base: this.metadata.blockHashBase,\n        multiplier: this.metadata.blockHashMultiplier,\n        constant: this.metadata.blockHashConstant\n      })), \"\".concat(dn(n, r)).concat(i, \".\").concat(s);\n      var n, r, i, s;\n    }, e.prototype._findBlock = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              t = yn.get(this.dbname), n = this.metadata.blockLevel, a.label = 1;\n\n            case 1:\n              return n > 0 ? (r = this.createBlockId(e, n), [4, t.find(this._store, r)]) : [3, 4];\n\n            case 2:\n              if ((i = a.sent()) && (s = En.createFromCacheItem(i), s.getItemByKey(e))) return [2, s];\n              a.label = 3;\n\n            case 3:\n              return n--, [3, 1];\n\n            case 4:\n              return [2, null];\n          }\n        });\n      });\n    }, e.prototype.getFromBlock = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, this._findBlock(e)];\n\n            case 1:\n              return [2, (t = n.sent()) ? t.getItemByKey(e) : null];\n          }\n        });\n      });\n    }, e.prototype.putToBlock = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n, r, i, s, a;\n        return P(this, function (o) {\n          switch (o.label) {\n            case 0:\n              return n = Bt.get(this.dbname), r = this.createBlockId(e), i = Math.floor(this._store.itemSizeLimit / n.itemSizeLimit), [4, yn.get(this.dbname).find(this._store, r)];\n\n            case 1:\n              return s = o.sent(), (a = s ? En.createFromCacheItem(s) : new En({\n                blockId: r,\n                keyName: this.keyName,\n                items: [],\n                limit: i\n              })).add(t) ? (this._transaction.requestWrite({\n                key: a.blockId,\n                value: a.serialize()\n              }), [2, !0]) : [2, !1];\n          }\n        });\n      });\n    }, e.prototype.removeFromBlock = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, this._findBlock(e)];\n\n            case 1:\n              return (t = n.sent()) && t.remove(e) ? (this._transaction.requestWrite({\n                key: t.blockId,\n                value: t.serialize()\n              }), [2, !0]) : [2, !1];\n          }\n        });\n      });\n    }, e.prototype.clearAllBlocks = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t, n, r, i, s, a;\n        return P(this, function (o) {\n          switch (o.label) {\n            case 0:\n              return e = dn(this.dbname, this.collectionName), [4, this._store.getAllKeys()];\n\n            case 1:\n              return t = o.sent(), n = t.filter(function (t) {\n                return t.startsWith(e);\n              }), [4, this._store.removeMany(n)];\n\n            case 2:\n              for (o.sent(), r = yn.get(this.dbname), i = 0, s = n; i < s.length; i++) {\n                a = s[i], r.remove(a);\n              }\n\n              return [2];\n          }\n        });\n      });\n    }, e;\n  }(),\n      bn = function () {\n    function e(e) {\n      var t = e.dbname,\n          n = e.collectionName,\n          r = e.keyName,\n          i = e.fields,\n          s = e.transaction,\n          a = e.store,\n          o = this;\n      this._origin = [], this._table = [], this.dbname = t, this.collectionName = n, this.keyName = r, this.fields = i, this.indexerKey = function (e, t, n) {\n        return \"\".concat(un(e, t), \"/index.\").concat(n);\n      }(this.dbname, this.collectionName, this.fields.join(\">\")), this._transaction = s, this._store = a, this._transaction.on(tn.COMMIT, this.indexerKey, function () {\n        return o.commit();\n      }), this._transaction.on(tn.ERROR, this.indexerKey, function () {\n        return o.abort();\n      });\n    }\n\n    return e.createKey = function (e) {\n      return e.join(\">\");\n    }, e.parseKey = function (e) {\n      return e.split(\">\");\n    }, e.prototype._addItem = function (e) {\n      var t = e[this.keyName],\n          n = this.getColumnValues(e),\n          r = this.indexOf(n),\n          i = r[0];\n      return r[1] ? !this._table[i].keys.includes(t) && (this._table[i].keys.push(t), !0) : (this._table.splice(i, 0, {\n        columnValues: n,\n        keys: [t]\n      }), !0);\n    }, e.prototype._removeItem = function (e) {\n      var t = e[this.keyName],\n          n = this.getColumnValues(e),\n          r = this.indexOf(n),\n          i = r[0];\n\n      if (r[1]) {\n        var s = this._table[i].keys.indexOf(t);\n\n        if (s > -1) return this._table[i].keys.splice(s, 1), 0 === this._table[i].keys.length && this._table.splice(i, 1), !0;\n      }\n\n      return !1;\n    }, Object.defineProperty(e.prototype, \"origin\", {\n      get: function get() {\n        return this._origin;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"table\", {\n      get: function get() {\n        return this._table;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.getColumnValues = function (e) {\n      for (var t, n, r = [], i = 0, s = this.fields; i < s.length; i++) {\n        var a = s[i];\n        if (\"-\" === a[0] && (a = a.slice(1)), t = e[a], n = void 0, n = typeof t, null !== t && \"undefined\" !== n && \"boolean\" !== n && \"number\" !== n && \"string\" !== n) throw qt.indexTypesNotMatch;\n        r.push(e[a]);\n      }\n\n      return r;\n    }, e.prototype.diff = function (e, t) {\n      for (var n in this.fields) {\n        var r = \"-\" === this.fields[n][0] ? -1 : 1,\n            i = Yt(e[n], t[n]);\n        if (0 !== i) return r * i;\n      }\n\n      return 0;\n    }, e.prototype.indexOf = function (e) {\n      if (this._table.length > 0) {\n        for (var t = 0, n = this._table.length - 1; t <= n;) {\n          var r = Math.floor((t + n) / 2),\n              i = this.diff(e, this._table[r].columnValues);\n          if (i > 0) t = r + 1;else {\n            if (!(i < 0)) return [r, !0];\n            n = r - 1;\n          }\n        }\n\n        return [t, !1];\n      }\n\n      return [0, !1];\n    }, e.prototype.ensure = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t, n, r, i, s, a, o, l, u, c, d;\n        return P(this, function (h) {\n          switch (h.label) {\n            case 0:\n              return [4, (e = yn.get(this.dbname)).find(this._store, this.indexerKey, rn.PERSISTENT)];\n\n            case 1:\n              return (t = h.sent()) ? [3, 7] : (n = dn(this.dbname, this.collectionName), [4, this._store.getAllKeys()]);\n\n            case 2:\n              r = h.sent(), i = 0, s = r, h.label = 3;\n\n            case 3:\n              return i < s.length ? (a = s[i]).startsWith(n) ? [4, e.find(this._store, a, rn.NO_CACHE)] : [3, 5] : [3, 6];\n\n            case 4:\n              for (o = h.sent(), l = En.createFromCacheItem(o), u = 0, c = l.items; u < c.length; u++) {\n                d = c[u], this._addItem(d);\n              }\n\n              h.label = 5;\n\n            case 5:\n              return i++, [3, 3];\n\n            case 6:\n              return this._transaction.requestWrite({\n                key: this.indexerKey,\n                value: this._table\n              }, {\n                persistent: !0\n              }), [3, 8];\n\n            case 7:\n              this._origin = t.value, this._table = zt(this._origin), h.label = 8;\n\n            case 8:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.drop = function () {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (e) {\n          switch (e.label) {\n            case 0:\n              return yn.get(this.dbname).remove(this.indexerKey), [4, this._store.remove(this.indexerKey)];\n\n            case 1:\n              return e.sent(), [2];\n          }\n        });\n      });\n    }, e.prototype.addItem = function (e) {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (t) {\n          return this._addItem(e) && this._transaction.requestWrite({\n            key: this.indexerKey,\n            value: this._table\n          }, {\n            persistent: !0\n          }), [2];\n        });\n      });\n    }, e.prototype.removeItem = function (e) {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (t) {\n          return this._removeItem(e) && this._transaction.requestWrite({\n            key: this.indexerKey,\n            value: this._table\n          }, {\n            persistent: !0\n          }), [2];\n        });\n      });\n    }, e.prototype.clear = function () {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (e) {\n          return this._table = [], this._transaction.requestWrite({\n            key: this.indexerKey,\n            value: this._table\n          }, {\n            persistent: !0\n          }), [2];\n        });\n      });\n    }, e.prototype.commit = function () {\n      this._origin = this._table, this._table = zt(this._origin);\n    }, e.prototype.abort = function () {\n      this._table = zt(this._origin);\n    }, e;\n  }(),\n      Cn = \"undefined\" != typeof document && \"undefined\" != typeof navigator;\n\n  Cn && navigator.userAgent && navigator.userAgent.includes(\"Chrome/\") && navigator.userAgent.includes(\"Chromium/\");\n  var An = Cn && navigator.userAgent && navigator.userAgent.includes(\"Firefox/\") && !navigator.userAgent.includes(\"Seamonkey/\");\n  Cn && navigator.userAgent && navigator.userAgent.includes(\"Safari/\") && !navigator.userAgent.includes(\"Chrome/\") && navigator.userAgent.includes(\"Chromium/\"), Cn && navigator.userAgent && (navigator.userAgent.includes(\"OPR/\") || navigator.userAgent.includes(\"Opera/\")), Cn && navigator.userAgent && navigator.userAgent.includes(\"Trident/7.0\");\n\n  var Nn,\n      Sn,\n      In = Cn && navigator.userAgent && navigator.userAgent.includes(\"Edge/\"),\n      Tn = function Tn() {\n    var e = new Date().getTime();\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (t) {\n      var n = (e + 16 * Math.random()) % 16 | 0;\n      return e = Math.floor(e / 16), (\"x\" === t ? n : 3 & n | 8).toString(16);\n    });\n  };\n\n  !function (e) {\n    e[e.PROCESSING = 0] = \"PROCESSING\", e[e.DONE = 1] = \"DONE\";\n  }(Nn || (Nn = {})), function (e) {\n    e.NEWNODE = \"newnode\", e.REMOVENODE = \"removenode\", e.CLAIM_HOST = \"claimhost\", e.SYNC_HOST = \"synchost\", e.REQUEST_LOCK = \"requestlock\", e.ACQUIRE_LOCK = \"acquirelock\", e.RELEASE_LOCK = \"releaselock\";\n  }(Sn || (Sn = {}));\n\n  var On,\n      Un = {},\n      Mn = function () {\n    function e(e, t) {\n      void 0 === t && (t = {});\n      var n = this;\n      return this._state = Nn.PROCESSING, this._hostId = null, this._queue = [], this._currentItem = null, this._activationTimeout = null, this._activationQueue = [], Un[e] && !t.forceCreate || (this.nodeId = Tn(), this.key = e, Cn && (t.startAsInvisible ? this.registerNode() : \"visible\" === document.visibilityState ? this.claimHost() : this.registerNode(), document.addEventListener(\"visibilitychange\", function () {\n        \"visible\" === document.visibilityState && n.claimHost();\n      }), window.addEventListener(\"message\", function (e) {\n        var t = e.data,\n            r = t.nodeId,\n            i = t.requestId,\n            s = t.key,\n            a = t.op,\n            o = t.data;\n        if (r !== n.nodeId && s === n.key) switch (a) {\n          case Sn.NEWNODE:\n            n._sendSync();\n\n            break;\n\n          case Sn.CLAIM_HOST:\n            n._sendSync(), n._hostId = r;\n            break;\n\n          case Sn.SYNC_HOST:\n            if (!n.isInSync) {\n              n._activationTimeout && clearTimeout(n._activationTimeout);\n\n              for (var l = o, u = l.currentItemRequestId, c = function c(e) {\n                var t = n._queue.findIndex(function (t) {\n                  return t.requestId === e.requestId;\n                });\n\n                t < 0 && n._requestLock({\n                  nodeId: e.nodeId,\n                  requestId: e.requestId,\n                  key: n.key,\n                  op: Sn.REQUEST_LOCK,\n                  ts: e.ts\n                });\n              }, d = 0, h = l.queue; d < h.length; d++) {\n                c(h[d]);\n              }\n\n              n._currentItem = n._queue.find(function (e) {\n                return e.requestId === u;\n              }), n._completeSync();\n            }\n\n            break;\n\n          case Sn.REMOVENODE:\n            n._queue = n._queue.filter(function (e) {\n              return e.nodeId !== t.nodeId;\n            }), n._currentItem && n._currentItem.nodeId === t.nodeId && (n._currentItem = null, n._acquire(n._queue[0]));\n            break;\n\n          case Sn.REQUEST_LOCK:\n            n._requestLock(t);\n\n            break;\n\n          case Sn.ACQUIRE_LOCK:\n            var p = n._queue.find(function (e) {\n              return e.requestId === i;\n            });\n\n            n._acquire(p);\n\n            break;\n\n          case Sn.RELEASE_LOCK:\n            n._release(i);\n\n        }\n      }), window.addEventListener(\"beforeunload\", function () {\n        n._send(Sn.REMOVENODE);\n      })), Un[e] = this), Un[e];\n    }\n\n    return Object.defineProperty(e.prototype, \"locked\", {\n      get: function get() {\n        return !!this._currentItem;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isHost\", {\n      get: function get() {\n        return this._hostId === this.nodeId;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isInSync\", {\n      get: function get() {\n        return this._state == Nn.DONE;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype._send = function (e, t) {\n      var n, r;\n      void 0 === t && (t = {});\n      var i = {\n        nodeId: this.nodeId,\n        requestId: null !== (n = null == t ? void 0 : t.requestId) && void 0 !== n ? n : Tn(),\n        key: this.key,\n        op: e,\n        data: null !== (r = t.data) && void 0 !== r ? r : null,\n        ts: Date.now()\n      };\n      return Cn && window.postMessage(i, \"*\"), i;\n    }, e.prototype._acquire = function (e) {\n      void 0 === e && (e = null), e ? (this._currentItem = e, this._currentItem.onAcquired(e.requestId)) : this._currentItem = null;\n    }, e.prototype._release = function (e) {\n      if (this._currentItem && this._currentItem.requestId === e) {\n        var t = this._currentItem;\n        this._currentItem = null, t.nodeId === this.nodeId && this._send(Sn.RELEASE_LOCK, {\n          requestId: t.requestId\n        });\n\n        var n = this._queue.findIndex(function (t) {\n          return t.requestId === e;\n        });\n\n        n > -1 && this._queue.splice(n, 1), t.onReleased(e);\n      }\n    }, e.prototype._requestLock = function (e) {\n      var t = this;\n      return new Promise(function (n) {\n        var r = {\n          nodeId: e.nodeId,\n          requestId: e.requestId,\n          ts: e.ts,\n          onAcquired: function onAcquired(e) {\n            t.isHost && t._send(Sn.ACQUIRE_LOCK, {\n              requestId: e\n            }), n();\n          },\n          onReleased: function onReleased() {\n            t._acquire(t._queue[0]);\n          }\n        },\n            i = !1;\n\n        for (var s in t._queue) {\n          if (t._queue[s].ts > r.ts) {\n            t._queue.splice(parseInt(s), 0, r), i = !0;\n            break;\n          }\n        }\n\n        i || t._queue.push(r), t._currentItem || t._acquire(t._queue[0]);\n      });\n    }, e.prototype._sendSync = function () {\n      var e;\n      this.isHost && this._send(Sn.SYNC_HOST, {\n        data: {\n          currentItemRequestId: null === (e = this._currentItem) || void 0 === e ? void 0 : e.requestId,\n          queue: this._queue.map(function (e) {\n            return {\n              nodeId: e.nodeId,\n              requestId: e.requestId,\n              ts: e.ts\n            };\n          })\n        }\n      });\n    }, e.prototype._waitUntilSyncCompleted = function () {\n      return L(this, void 0, void 0, function () {\n        var e = this;\n        return P(this, function (t) {\n          return this.isHost && !this.isInSync ? [2, new Promise(function (t) {\n            e._activationQueue.push(t);\n          })] : [2];\n        });\n      });\n    }, e.prototype._waitSync = function () {\n      var e = this;\n      this.isInSync || (this._activationTimeout = setTimeout(function () {\n        e._completeSync();\n      }, 8));\n    }, e.prototype._completeSync = function () {\n      this.isInSync || (this._state = Nn.DONE, this._activationQueue.forEach(function (e) {\n        return e();\n      }), this._activationQueue = []);\n    }, e.prototype.registerNode = function () {\n      this._send(Sn.NEWNODE), this._waitSync();\n    }, e.prototype.claimHost = function () {\n      this._hostId = this.nodeId, this._send(Sn.CLAIM_HOST), this._waitSync();\n    }, e.prototype.lock = function () {\n      return L(this, void 0, void 0, function () {\n        var e;\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, this._waitUntilSyncCompleted()];\n\n            case 1:\n              return t.sent(), e = this._send(Sn.REQUEST_LOCK), [4, this._requestLock(e)];\n\n            case 2:\n              return t.sent(), [2];\n          }\n        });\n      });\n    }, e.prototype.unlock = function () {\n      var e;\n\n      this._release(null === (e = this._currentItem) || void 0 === e ? void 0 : e.requestId);\n    }, e;\n  }(),\n      kn = function () {\n    function e(e) {\n      var t = e.dbname,\n          n = e.collectionName,\n          r = e.keyName,\n          i = e.keyHash,\n          s = e.indexes,\n          a = e.store,\n          o = this;\n      this._state = Vt.INIT, this._metadata = null, this._indexers = [], this.dbname = t, this.name = n, this.keyName = r, this.indexes = w([[r]], s.filter(function (e) {\n        return bn.createKey(e) !== o.keyName;\n      }), !0), this._keyHash = i, this._store = a, this._mutex = new Mn(function (e, t) {\n        return \"\".concat(un(e, t), \".lock\");\n      }(t, n)), this._blobContainer = new fn({\n        dbname: t,\n        collectionName: n,\n        store: a\n      }), this._transaction = new mn({\n        dbname: t,\n        collectionName: n,\n        store: a\n      });\n    }\n\n    return e.metadataOf = function (e, t, n) {\n      return L(this, void 0, void 0, function () {\n        var r;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return r = cn(e, t), [4, n.get(r)];\n\n            case 1:\n              return [2, i.sent()];\n          }\n        });\n      });\n    }, Object.defineProperty(e.prototype, \"state\", {\n      get: function get() {\n        return this._state;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.init = function () {\n      return L(this, void 0, void 0, function () {\n        var t,\n            n,\n            r,\n            i,\n            s,\n            a,\n            o,\n            l,\n            u,\n            c,\n            d,\n            h,\n            p = this;\n        return P(this, function (f) {\n          switch (f.label) {\n            case 0:\n              return [4, this._mutex.lock()];\n\n            case 1:\n              f.sent(), f.label = 2;\n\n            case 2:\n              return f.trys.push([2, 9,, 10]), t = Bt.get(this.dbname), [4, e.metadataOf(this.dbname, this.name, this._store)];\n\n            case 3:\n              return n = f.sent(), this._metadata = n || {\n                keyName: this.keyName,\n                blockLevel: 1,\n                blockHashBase: t.blockHashBase,\n                blockHashMultiplier: t.blockHashMultiplier,\n                blockHashConstant: t.blockHashConstant,\n                indexes: this.indexes\n              }, [4, this._transaction.init()];\n\n            case 4:\n              for (f.sent(), this._blockManager = new vn({\n                dbname: this.dbname,\n                collectionName: this.name,\n                hashFunction: this._keyHash,\n                metadata: this._metadata,\n                transaction: this._transaction,\n                store: this._store\n              }), r = w([], this.indexes, !0), i = [], s = r.map(function (e) {\n                return bn.createKey(e);\n              }), a = n ? n.indexes.map(function (e) {\n                return bn.createKey(e);\n              }) : [], o = 0, l = a; o < l.length; o++) {\n                u = l[o], s.includes(u) || i.push(bn.parseKey(u));\n              }\n\n              return (c = []).push.apply(c, r.map(function (e) {\n                var t = new bn({\n                  dbname: p.dbname,\n                  collectionName: p.name,\n                  keyName: p.keyName,\n                  fields: e,\n                  transaction: p._transaction,\n                  store: p._store\n                });\n                return p._indexers.push(t), t.ensure();\n              })), c.push.apply(c, i.map(function (e) {\n                return new bn({\n                  dbname: p.dbname,\n                  collectionName: p.name,\n                  keyName: p.keyName,\n                  fields: e,\n                  transaction: p._transaction,\n                  store: p._store\n                }).drop();\n              })), [4, Promise.all(c)];\n\n            case 5:\n              return f.sent(), [4, this._transaction.commit()];\n\n            case 6:\n              return f.sent(), s.sort().join(\",\") === a.sort().join(\",\") ? [3, 8] : (d = cn(this.dbname, this.name), this._metadata.indexes = r, [4, this._store.set({\n                key: d,\n                value: this._metadata,\n                generation: 1\n              })]);\n\n            case 7:\n              f.sent(), f.label = 8;\n\n            case 8:\n              return this._state = Vt.READY, this._mutex.unlock(), [3, 10];\n\n            case 9:\n              throw h = f.sent(), this._mutex.unlock(), h;\n\n            case 10:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.close = function () {\n      this._state = Vt.CLOSED;\n    }, e.prototype._hasPropertyOfKeyName = function (e) {\n      var t = e[this.keyName];\n      return \"string\" == typeof t && !!t;\n    }, e.prototype._getIndexerBy = function (e) {\n      void 0 === e && (e = null), e || (e = [this.keyName]);\n\n      for (var t = bn.createKey(e), n = 0, r = this._indexers; n < r.length; n++) {\n        var i = r[n];\n        if (t === bn.createKey(i.fields)) return i;\n      }\n\n      return null;\n    }, e.prototype._upgradeBlockLevel = function () {\n      return L(this, void 0, void 0, function () {\n        var e;\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return e = cn(this.dbname, this.name), this._metadata.blockLevel++, [4, this._store.set({\n                key: e,\n                value: this._metadata,\n                generation: 1\n              })];\n\n            case 1:\n              return t.sent(), [2];\n          }\n        });\n      });\n    }, e.prototype._requestInsert = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return t = e[this.keyName], [4, this._blockManager.getFromBlock(t)];\n\n            case 1:\n              return i.sent() ? [3, 10] : [4, this._blockManager.putToBlock(t, e)];\n\n            case 2:\n              return i.sent() ? [3, 5] : [4, this._upgradeBlockLevel()];\n\n            case 3:\n              return i.sent(), [4, this._blockManager.putToBlock(t, e)];\n\n            case 4:\n              i.sent(), i.label = 5;\n\n            case 5:\n              n = 0, r = this._indexers, i.label = 6;\n\n            case 6:\n              return n < r.length ? [4, r[n].addItem(e)] : [3, 9];\n\n            case 7:\n              i.sent(), i.label = 8;\n\n            case 8:\n              return n++, [3, 6];\n\n            case 9:\n              return [3, 11];\n\n            case 10:\n              throw qt.collectionInsertDuplicate;\n\n            case 11:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype._requestUpsert = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s, a, o;\n        return P(this, function (l) {\n          switch (l.label) {\n            case 0:\n              return t = e[this.keyName], [4, this._blockManager.getFromBlock(t)];\n\n            case 1:\n              return (n = l.sent()) ? [3, 10] : [4, this._blockManager.putToBlock(t, e)];\n\n            case 2:\n              return l.sent() ? [3, 5] : [4, this._upgradeBlockLevel()];\n\n            case 3:\n              return l.sent(), [4, this._blockManager.putToBlock(t, e)];\n\n            case 4:\n              l.sent(), l.label = 5;\n\n            case 5:\n              r = 0, i = this._indexers, l.label = 6;\n\n            case 6:\n              return r < i.length ? [4, (o = i[r]).addItem(e)] : [3, 9];\n\n            case 7:\n              l.sent(), l.label = 8;\n\n            case 8:\n              return r++, [3, 6];\n\n            case 9:\n              return [3, 16];\n\n            case 10:\n              return [4, this._blockManager.putToBlock(t, e)];\n\n            case 11:\n              l.sent(), s = 0, a = this._indexers, l.label = 12;\n\n            case 12:\n              return s < a.length ? 0 === (o = a[s]).diff(o.getColumnValues(n), o.getColumnValues(e)) ? [3, 15] : [4, o.removeItem(n)] : [3, 16];\n\n            case 13:\n              return l.sent(), [4, o.addItem(e)];\n\n            case 14:\n              l.sent(), l.label = 15;\n\n            case 15:\n              return s++, [3, 12];\n\n            case 16:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype._requestUpdate = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return t = e[this.keyName], [4, this._blockManager.getFromBlock(t)];\n\n            case 1:\n              return (n = a.sent()) ? [4, this._blockManager.putToBlock(t, e)] : [3, 7];\n\n            case 2:\n              a.sent(), r = 0, i = this._indexers, a.label = 3;\n\n            case 3:\n              return r < i.length ? 0 === (s = i[r]).diff(s.getColumnValues(n), s.getColumnValues(e)) ? [3, 6] : [4, s.removeItem(n)] : [3, 7];\n\n            case 4:\n              return a.sent(), [4, s.addItem(e)];\n\n            case 5:\n              a.sent(), a.label = 6;\n\n            case 6:\n              return r++, [3, 3];\n\n            case 7:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype._requestRemove = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return [4, this._blockManager.getFromBlock(e)];\n\n            case 1:\n              return (t = i.sent()) ? [4, this._blockManager.removeFromBlock(e)] : [3, 6];\n\n            case 2:\n              i.sent(), n = 0, r = this._indexers, i.label = 3;\n\n            case 3:\n              return n < r.length ? [4, r[n].removeItem(t)] : [3, 6];\n\n            case 4:\n              i.sent(), i.label = 5;\n\n            case 5:\n              return n++, [3, 3];\n\n            case 6:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype._requestClear = function () {\n      return L(this, void 0, void 0, function () {\n        var e, t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, this._blockManager.clearAllBlocks()];\n\n            case 1:\n              n.sent(), e = 0, t = this._indexers, n.label = 2;\n\n            case 2:\n              return e < t.length ? [4, t[e].clear()] : [3, 5];\n\n            case 3:\n              n.sent(), n.label = 4;\n\n            case 4:\n              return e++, [3, 2];\n\n            case 5:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.getByKey = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return this._state !== Vt.READY ? [3, 6] : [4, this._mutex.lock()];\n\n            case 1:\n              r.sent(), r.label = 2;\n\n            case 2:\n              return r.trys.push([2, 4,, 5]), [4, this._blockManager.getFromBlock(e)];\n\n            case 3:\n              return t = r.sent(), this._mutex.unlock(), [2, zt(t)];\n\n            case 4:\n              throw n = r.sent(), this._mutex.unlock(), n;\n\n            case 5:\n              return [3, 7];\n\n            case 6:\n              throw qt.collectionNotReady;\n\n            case 7:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.query = function (e) {\n      return void 0 === e && (e = {}), this._state === Vt.READY ? new on({\n        condition: e.where,\n        mutex: this._mutex,\n        blockManager: this._blockManager,\n        indexer: this._getIndexerBy(e.index),\n        backward: !!e.backward\n      }) : null;\n    }, e.prototype.insertOne = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return this._state !== Vt.READY ? [3, 8] : [4, this._mutex.lock()];\n\n            case 1:\n              n.sent(), n.label = 2;\n\n            case 2:\n              if (n.trys.push([2, 5,, 7]), !this._hasPropertyOfKeyName(e)) throw qt.collectionKeyNotGiven;\n              return [4, this._requestInsert(zt(e))];\n\n            case 3:\n              return n.sent(), [4, this._transaction.commit()];\n\n            case 4:\n              return n.sent(), this._mutex.unlock(), [2, e];\n\n            case 5:\n              return t = n.sent(), [4, this._transaction.clear()];\n\n            case 6:\n              throw n.sent(), this._mutex.unlock(), t;\n\n            case 7:\n              return [3, 9];\n\n            case 8:\n              throw qt.collectionNotReady;\n\n            case 9:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.insertMany = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t,\n            n,\n            r,\n            i,\n            s = this;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return this._state !== Vt.READY ? [3, 11] : [4, this._mutex.lock()];\n\n            case 1:\n              a.sent(), a.label = 2;\n\n            case 2:\n              if (a.trys.push([2, 8,, 10]), e.some(function (e) {\n                return !s._hasPropertyOfKeyName(e);\n              })) throw qt.collectionKeyNotGiven;\n              t = 0, n = e, a.label = 3;\n\n            case 3:\n              return t < n.length ? (r = n[t], [4, this._requestInsert(zt(r))]) : [3, 6];\n\n            case 4:\n              a.sent(), a.label = 5;\n\n            case 5:\n              return t++, [3, 3];\n\n            case 6:\n              return [4, this._transaction.commit()];\n\n            case 7:\n              return a.sent(), this._mutex.unlock(), [2, e];\n\n            case 8:\n              return i = a.sent(), [4, this._transaction.clear()];\n\n            case 9:\n              throw a.sent(), this._mutex.unlock(), i;\n\n            case 10:\n              return [3, 12];\n\n            case 11:\n              throw qt.collectionNotReady;\n\n            case 12:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.upsertOne = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return this._state !== Vt.READY ? [3, 8] : [4, this._mutex.lock()];\n\n            case 1:\n              n.sent(), n.label = 2;\n\n            case 2:\n              if (n.trys.push([2, 5,, 7]), !this._hasPropertyOfKeyName(e)) throw qt.collectionKeyNotGiven;\n              return [4, this._requestUpsert(zt(e))];\n\n            case 3:\n              return n.sent(), [4, this._transaction.commit()];\n\n            case 4:\n              return n.sent(), this._mutex.unlock(), [2, e];\n\n            case 5:\n              return t = n.sent(), [4, this._transaction.clear()];\n\n            case 6:\n              throw n.sent(), this._mutex.unlock(), t;\n\n            case 7:\n              return [3, 9];\n\n            case 8:\n              throw qt.collectionNotReady;\n\n            case 9:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.upsertMany = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t,\n            n,\n            r,\n            i,\n            s = this;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return this._state !== Vt.READY ? [3, 11] : [4, this._mutex.lock()];\n\n            case 1:\n              a.sent(), a.label = 2;\n\n            case 2:\n              if (a.trys.push([2, 8,, 10]), e.some(function (e) {\n                return !s._hasPropertyOfKeyName(e);\n              })) throw qt.collectionKeyNotGiven;\n              t = 0, n = e, a.label = 3;\n\n            case 3:\n              return t < n.length ? (r = n[t], [4, this._requestUpsert(zt(r))]) : [3, 6];\n\n            case 4:\n              a.sent(), a.label = 5;\n\n            case 5:\n              return t++, [3, 3];\n\n            case 6:\n              return [4, this._transaction.commit()];\n\n            case 7:\n              return a.sent(), this._mutex.unlock(), [2, e];\n\n            case 8:\n              return i = a.sent(), [4, this._transaction.clear()];\n\n            case 9:\n              throw a.sent(), this._mutex.unlock(), i;\n\n            case 10:\n              return [3, 12];\n\n            case 11:\n              throw qt.collectionNotReady;\n\n            case 12:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.update = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return this._state !== Vt.READY ? [3, 8] : [4, this._mutex.lock()];\n\n            case 1:\n              n.sent(), n.label = 2;\n\n            case 2:\n              if (n.trys.push([2, 5,, 7]), !this._hasPropertyOfKeyName(e)) throw qt.collectionKeyNotGiven;\n              return [4, this._requestUpdate(zt(e))];\n\n            case 3:\n              return n.sent(), [4, this._transaction.commit()];\n\n            case 4:\n              return n.sent(), this._mutex.unlock(), [2, e];\n\n            case 5:\n              return t = n.sent(), [4, this._transaction.clear()];\n\n            case 6:\n              throw n.sent(), this._mutex.unlock(), t;\n\n            case 7:\n              return [3, 9];\n\n            case 8:\n              throw qt.collectionNotReady;\n\n            case 9:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.updateIf = function (e, t) {\n      return L(this, void 0, void 0, function () {\n        var n,\n            r,\n            i,\n            s,\n            a,\n            o,\n            l,\n            u,\n            c,\n            d,\n            h,\n            p = this;\n        return P(this, function (f) {\n          switch (f.label) {\n            case 0:\n              return this._state !== Vt.READY ? [3, 12] : [4, this._mutex.lock()];\n\n            case 1:\n              f.sent(), f.label = 2;\n\n            case 2:\n              return f.trys.push([2, 9,, 11]), n = e.where, r = void 0 === n ? {} : n, i = e.index, s = void 0 === i ? null : i, a = e.backward, o = void 0 !== a && a, l = [], [4, new an({\n                condition: r,\n                blockManager: this._blockManager,\n                backward: o,\n                indexer: this._getIndexerBy(s)\n              }).each(function (e) {\n                return L(p, void 0, void 0, function () {\n                  var n, i;\n                  return P(this, function (s) {\n                    if (e.error) throw e.stop(), e.error;\n\n                    if (e.hasNext) {\n                      if (n = e.nextValue, Jt(r, n) && t.set) {\n                        if (\"function\" != typeof t.set) for (i in t.set) {\n                          n[i] = t.set[i];\n                        } else t.set(n);\n                        l.push(n);\n                      }\n\n                      e.next();\n                    } else e.stop();\n\n                    return [2];\n                  });\n                });\n              })];\n\n            case 3:\n              f.sent(), u = 0, c = l, f.label = 4;\n\n            case 4:\n              return u < c.length ? (d = c[u], [4, this._requestUpdate(zt(d))]) : [3, 7];\n\n            case 5:\n              f.sent(), f.label = 6;\n\n            case 6:\n              return u++, [3, 4];\n\n            case 7:\n              return [4, this._transaction.commit()];\n\n            case 8:\n              return f.sent(), this._mutex.unlock(), [2, l];\n\n            case 9:\n              return h = f.sent(), [4, this._transaction.clear()];\n\n            case 10:\n              throw f.sent(), this._mutex.unlock(), h;\n\n            case 11:\n              return [3, 13];\n\n            case 12:\n              throw this._transaction.clear(), qt.collectionNotReady;\n\n            case 13:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.remove = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return this._state !== Vt.READY ? [3, 8] : [4, this._mutex.lock()];\n\n            case 1:\n              n.sent(), n.label = 2;\n\n            case 2:\n              return n.trys.push([2, 5,, 7]), [4, this._requestRemove(e)];\n\n            case 3:\n              return n.sent(), [4, this._transaction.commit()];\n\n            case 4:\n              return n.sent(), this._mutex.unlock(), [3, 7];\n\n            case 5:\n              return t = n.sent(), [4, this._transaction.clear()];\n\n            case 6:\n              throw n.sent(), this._mutex.unlock(), t;\n\n            case 7:\n              return [3, 9];\n\n            case 8:\n              throw qt.collectionNotReady;\n\n            case 9:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.removeIf = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t,\n            n,\n            r,\n            i,\n            s,\n            a,\n            o,\n            l,\n            u,\n            c,\n            d,\n            h = this;\n        return P(this, function (p) {\n          switch (p.label) {\n            case 0:\n              return this._state !== Vt.READY ? [3, 11] : [4, this._mutex.lock()];\n\n            case 1:\n              p.sent(), p.label = 2;\n\n            case 2:\n              return p.trys.push([2, 9,, 10]), t = e.where, n = void 0 === t ? {} : t, r = e.index, i = void 0 === r ? null : r, s = e.backward, a = void 0 !== s && s, o = [], [4, new an({\n                condition: n,\n                blockManager: this._blockManager,\n                backward: a,\n                indexer: this._getIndexerBy(i)\n              }).each(function (e) {\n                return L(h, void 0, void 0, function () {\n                  var t, r;\n                  return P(this, function (i) {\n                    if (e.error) throw e.stop(), e.error;\n                    return e.hasNext ? (t = e.nextValue, Jt(n, t) && (r = t[this.keyName], o.push(r)), e.next()) : e.stop(), [2];\n                  });\n                });\n              })];\n\n            case 3:\n              p.sent(), l = 0, u = o, p.label = 4;\n\n            case 4:\n              return l < u.length ? (c = u[l], [4, this._requestRemove(c)]) : [3, 7];\n\n            case 5:\n              p.sent(), p.label = 6;\n\n            case 6:\n              return l++, [3, 4];\n\n            case 7:\n              return [4, this._transaction.commit()];\n\n            case 8:\n              return p.sent(), this._mutex.unlock(), [2, o];\n\n            case 9:\n              throw d = p.sent(), this._mutex.unlock(), d;\n\n            case 10:\n              return [3, 12];\n\n            case 11:\n              throw this._transaction.clear(), qt.collectionNotReady;\n\n            case 12:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.clear = function () {\n      return L(this, void 0, void 0, function () {\n        var e;\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return this._state !== Vt.READY ? [3, 8] : [4, this._mutex.lock()];\n\n            case 1:\n              t.sent(), t.label = 2;\n\n            case 2:\n              return t.trys.push([2, 5,, 7]), [4, this._requestClear()];\n\n            case 3:\n              return t.sent(), [4, this._transaction.commit()];\n\n            case 4:\n              return t.sent(), this._mutex.unlock(), [3, 7];\n\n            case 5:\n              return e = t.sent(), [4, this._transaction.clear()];\n\n            case 6:\n              throw t.sent(), this._mutex.unlock(), e;\n\n            case 7:\n              return [3, 9];\n\n            case 8:\n              throw qt.collectionNotReady;\n\n            case 9:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.getBlob = function (e) {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, this._blobContainer.get(e)];\n\n            case 1:\n              return [2, t.sent()];\n          }\n        });\n      });\n    }, e.prototype.saveBlob = function (e, t) {\n      return void 0 === t && (t = null), L(this, void 0, void 0, function () {\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, this._blobContainer.save(e, t)];\n\n            case 1:\n              return [2, n.sent()];\n          }\n        });\n      });\n    }, e.prototype.removeBlob = function (e) {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, this._blobContainer.remove(e)];\n\n            case 1:\n              return t.sent(), [2];\n          }\n        });\n      });\n    }, e.prototype.removeAllBlobs = function () {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (e) {\n          switch (e.label) {\n            case 0:\n              return [4, this._blobContainer.clear()];\n\n            case 1:\n              return e.sent(), [2];\n          }\n        });\n      });\n    }, e;\n  }(),\n      Rn = {\n    key: \"__ev\",\n    value: {\n      k: \"__ev\",\n      v: \"scs\"\n    },\n    generation: 1\n  },\n      Ln = {\n    encrypt: function encrypt(e) {\n      return e;\n    },\n    decrypt: function decrypt(e) {\n      return e;\n    }\n  },\n      Pn = {},\n      wn = function () {\n    function e(e) {\n      void 0 === e && (e = {});\n      var t = e.itemSizeLimit,\n          n = void 0 === t ? 4194304 : t,\n          r = e.delay,\n          i = void 0 === r ? 1 : r,\n          s = e.encryption,\n          a = void 0 === s ? Ln : s;\n      this._encryption = a, this.itemSizeLimit = n, this.delay = i, this.observer = {};\n    }\n\n    return Object.defineProperty(e.prototype, \"rawData\", {\n      get: function get() {\n        return Pn[this.dbname];\n      },\n      set: function set(e) {\n        Pn[this.dbname] = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.observe = function (e, t, n) {\n      var r = this;\n      this.observer[e] = {}, t.forEach(function (t) {\n        return r.observer[e][t] = n;\n      });\n    }, e.prototype.init = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              this.dbname = e, Pn[this.dbname] = {}, n.label = 1;\n\n            case 1:\n              return n.trys.push([1,, 3, 5]), [4, this.get(Rn.key)];\n\n            case 2:\n              if ((t = n.sent()) && JSON.stringify(t) !== JSON.stringify(Rn.value)) throw qt.storeEncryptionInvalid;\n              return [3, 5];\n\n            case 3:\n              return [4, this.set(Rn)];\n\n            case 4:\n              return n.sent(), [7];\n\n            case 5:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.getAllKeys = function () {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (e) {\n          return [2, Object.keys(Pn[this.dbname]).filter(function (e) {\n            return e !== Rn.key;\n          })];\n        });\n      });\n    }, e.prototype.get = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return [4, Wt(this.delay)];\n\n            case 1:\n              if (r.sent(), t = this.observer[e], n = t && t.get ? t.get(e) : null) throw n;\n              return [2, Pn[this.dbname][e] ? this._encryption.decrypt(Pn[this.dbname][e]) : null];\n          }\n        });\n      });\n    }, e.prototype.set = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s, a;\n        return P(this, function (o) {\n          switch (o.label) {\n            case 0:\n              return [4, Wt(this.delay)];\n\n            case 1:\n              if (o.sent(), t = e.key, n = e.value, r = this.observer[t], i = r && r.set ? r.set(t) : null) throw i;\n              if (s = this._encryption.encrypt(n), a = JSON.stringify(s), t === Rn.key || a.length < this.itemSizeLimit) return Pn[this.dbname][t] = s, [2, Pn[this.dbname][t]];\n              throw qt.storeItemSizeExceeded;\n          }\n        });\n      });\n    }, e.prototype.setMany = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t,\n            n = this;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return [4, Wt(this.delay)];\n\n            case 1:\n              return r.sent(), t = [], e.forEach(function (e) {\n                var r = e.key,\n                    i = e.value,\n                    s = n.observer[r];\n                if (s && s.set ? s.set(r) : null) t.push(qt.collectionWriteFailed);else {\n                  var a = n._encryption.encrypt(i),\n                      o = JSON.stringify(a);\n\n                  r === Rn.key || o.length < n.itemSizeLimit ? (Pn[n.dbname][r] = a, t.push(i)) : t.push(qt.storeItemSizeExceeded);\n                }\n              }), [2, t];\n          }\n        });\n      });\n    }, e.prototype.remove = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return [4, Wt(this.delay)];\n\n            case 1:\n              if (r.sent(), t = this.observer[e], n = t && t.remove ? t.remove(e) : null) throw n;\n              return Pn[this.dbname][e] && delete Pn[this.dbname][e], [2, e];\n          }\n        });\n      });\n    }, e.prototype.removeMany = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return [4, Wt(this.delay)];\n\n            case 1:\n              for (a.sent(), t = 0, n = e; t < n.length; t++) {\n                if (r = n[t], i = this.observer[r], s = i && i.remove ? i.remove(r) : null) throw s;\n                Pn[this.dbname][r] && delete Pn[this.dbname][r];\n              }\n\n              return [2, e];\n          }\n        });\n      });\n    }, e.prototype.clear = function () {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (e) {\n          switch (e.label) {\n            case 0:\n              return [4, Wt(this.delay)];\n\n            case 1:\n              return e.sent(), Pn[this.dbname] = {}, [2];\n          }\n        });\n      });\n    }, e;\n  }(),\n      Dn = \"NestDBStore\",\n      Hn = function () {\n    function e(e) {\n      void 0 === e && (e = {}), this.itemSizeLimit = 104857600;\n      var t = e.encryption,\n          n = void 0 === t ? Ln : t;\n      this._window = \"undefined\" != typeof window ? window : null, this._indexedDB = this._window ? this._window.indexedDB || this._window.mozIndexedDB || this._window.webkitIndexedDB || this._window.msIndexedDB : null, this._encryption = n;\n    }\n\n    return e.prototype.init = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t,\n            n,\n            r = this;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return this.dbname = e, [4, new Promise(function (e, t) {\n                if (r._window && Cn) {\n                  if (An) {\n                    var n = r._indexedDB.open(\"_testMozilla\");\n\n                    n.onerror = function () {\n                      return t(qt.storeNotAvailableInPrivateBrowsing);\n                    }, n.onsuccess = function () {\n                      return e();\n                    };\n                  } else In ? r._window.indexedDB || !r._window.PointerEvent && !r._window.MSPointerEvent || t(qt.storeNotAvailableInPrivateBrowsing) : e();\n                } else t(qt.storeNotAvailable);\n              })];\n\n            case 1:\n              return i.sent(), t = this, [4, new Promise(function (t, n) {\n                var i = r._indexedDB.open(e);\n\n                i.addEventListener(\"upgradeneeded\", function (e) {\n                  e.target.result.createObjectStore(Dn, {\n                    keyPath: \"key\"\n                  });\n                }), i.addEventListener(\"success\", function (e) {\n                  return t(e.target.result);\n                }), i.addEventListener(\"error\", function (e) {\n                  return n(e.target.error);\n                });\n              })];\n\n            case 2:\n              t._database = i.sent(), i.label = 3;\n\n            case 3:\n              return i.trys.push([3,, 5, 7]), [4, this.get(Rn.key)];\n\n            case 4:\n              if ((n = i.sent()) && JSON.stringify(n) !== JSON.stringify(Rn.value)) throw qt.storeEncryptionInvalid;\n              return [3, 7];\n\n            case 5:\n              return [4, this.set(Rn)];\n\n            case 6:\n              return i.sent(), [7];\n\n            case 7:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.getAllKeys = function () {\n      return L(this, void 0, void 0, function () {\n        var e = this;\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, new Promise(function (t, n) {\n                var r = e._database.transaction(Dn, \"readonly\").objectStore(Dn).getAllKeys();\n\n                r.addEventListener(\"success\", function (e) {\n                  t(e.target.result.filter(function (e) {\n                    return e !== Rn.key;\n                  }));\n                }), r.addEventListener(\"error\", function (e) {\n                  return n(e.target.error);\n                });\n              })];\n\n            case 1:\n              return [2, t.sent()];\n          }\n        });\n      });\n    }, e.prototype.get = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t = this;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, new Promise(function (n, r) {\n                var i = t._database.transaction(Dn, \"readonly\").objectStore(Dn).get(e);\n\n                i.addEventListener(\"success\", function (e) {\n                  return n(e.target.result ? t._encryption.decrypt(e.target.result.value) : null);\n                }), i.addEventListener(\"error\", function (e) {\n                  return r(e.target.error);\n                });\n              })];\n\n            case 1:\n              return [2, n.sent()];\n          }\n        });\n      });\n    }, e.prototype.set = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t,\n            n,\n            r = this;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return t = e.key, n = e.value, [4, new Promise(function (e, i) {\n                var s = r._database.transaction(Dn, \"readwrite\").objectStore(Dn).put({\n                  key: t,\n                  value: r._encryption.encrypt(n)\n                });\n\n                s.addEventListener(\"success\", function (t) {\n                  e(t.target.result);\n                }), s.addEventListener(\"error\", function (e) {\n                  return i(e.target.error);\n                });\n              })];\n\n            case 1:\n              return i.sent(), [2, n];\n          }\n        });\n      });\n    }, e.prototype.setMany = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t,\n            n,\n            r = this;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return t = [], n = this._database.transaction(Dn, \"readwrite\").objectStore(Dn), e.forEach(function (e) {\n                var i = e.key,\n                    s = e.value;\n                t.push(new Promise(function (e) {\n                  var t = n.put({\n                    key: i,\n                    value: r._encryption.encrypt(s)\n                  });\n                  t.addEventListener(\"success\", function (t) {\n                    e(t.target.result);\n                  }), t.addEventListener(\"error\", function () {\n                    e(qt.collectionWriteFailed);\n                  });\n                }));\n              }), [4, Promise.all(t)];\n\n            case 1:\n              return i.sent(), [2, e.map(function (e) {\n                return e.value;\n              })];\n          }\n        });\n      });\n    }, e.prototype.remove = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t = this;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, new Promise(function (n, r) {\n                var i = t._database.transaction(Dn, \"readwrite\").objectStore(Dn).delete(e);\n\n                i.addEventListener(\"success\", function () {\n                  return n(e);\n                }), i.addEventListener(\"error\", function (e) {\n                  return r(e.target.error);\n                });\n              })];\n\n            case 1:\n              return [2, n.sent()];\n          }\n        });\n      });\n    }, e.prototype.removeMany = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return t = this._database.transaction(Dn, \"readwrite\").objectStore(Dn), [4, Promise.all(e.map(function (e) {\n                return new Promise(function (n, r) {\n                  var i = t.delete(e);\n                  i.addEventListener(\"success\", function () {\n                    return n(e);\n                  }), i.addEventListener(\"error\", function (e) {\n                    return r(e.target.error);\n                  });\n                });\n              }))];\n\n            case 1:\n              return [2, n.sent()];\n          }\n        });\n      });\n    }, e.prototype.clear = function () {\n      return L(this, void 0, void 0, function () {\n        var e = this;\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, new Promise(function (t, n) {\n                var r = e._database.transaction(Dn, \"readwrite\").objectStore(Dn).clear();\n\n                r.addEventListener(\"success\", function () {\n                  return t();\n                }), r.addEventListener(\"error\", function (e) {\n                  return n(e.target.error);\n                });\n              })];\n\n            case 1:\n              return [2, t.sent()];\n          }\n        });\n      });\n    }, e;\n  }(),\n      Fn = function () {\n    function e(e) {\n      var t = e.AsyncStorage,\n          n = e.encryption,\n          r = void 0 === n ? Ln : n;\n      this.itemSizeLimit = 6291456, this._asyncStorage = t, this._encryption = r;\n    }\n\n    return e.prototype._isBelonging = function (e) {\n      return e.startsWith(\"\".concat(this.dbname, \"/\"));\n    }, e.prototype._getActualKey = function (e) {\n      return \"\".concat(this.dbname, \"/\").concat(e);\n    }, e.prototype.init = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              this.dbname = e, n.label = 1;\n\n            case 1:\n              return n.trys.push([1,, 3, 5]), [4, this.get(Rn.key)];\n\n            case 2:\n              if ((t = n.sent()) && JSON.stringify(t) !== JSON.stringify(Rn.value)) throw qt.storeEncryptionInvalid;\n              return [3, 5];\n\n            case 3:\n              return [4, this.set(Rn)];\n\n            case 4:\n              return n.sent(), [7];\n\n            case 5:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.getAllKeys = function () {\n      return L(this, void 0, void 0, function () {\n        var e,\n            t,\n            n = this;\n        return P(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return e = this._getActualKey(Rn.key), [4, this._asyncStorage.getAllKeys()];\n\n            case 1:\n              return t = r.sent(), [2, t.filter(function (t) {\n                return n._isBelonging(t) && t !== e;\n              }).map(function (e) {\n                return e.substring(\"\".concat(n.dbname, \"/\").length);\n              })];\n          }\n        });\n      });\n    }, e.prototype.get = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, this._asyncStorage.getItem(this._getActualKey(e))];\n\n            case 1:\n              return [2, (t = n.sent()) ? this._encryption.decrypt(JSON.parse(t)) : null];\n          }\n        });\n      });\n    }, e.prototype.set = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return t = e.key, n = e.value, r = JSON.stringify(this._encryption.encrypt(n)), t === Rn.key || r.length < this.itemSizeLimit ? [4, this._asyncStorage.setItem(this._getActualKey(t), r)] : [3, 2];\n\n            case 1:\n              return i.sent(), [2, JSON.parse(r)];\n\n            case 2:\n              throw qt.storeItemSizeExceeded;\n          }\n        });\n      });\n    }, e.prototype.setMany = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s, a, o;\n        return P(this, function (l) {\n          switch (l.label) {\n            case 0:\n              t = [], n = 0, r = e, l.label = 1;\n\n            case 1:\n              if (!(n < r.length)) return [3, 8];\n              i = r[n], l.label = 2;\n\n            case 2:\n              return l.trys.push([2, 6,, 7]), s = i.key, a = i.value, o = JSON.stringify(this._encryption.encrypt(a)), s === Rn.key || o.length < this.itemSizeLimit ? [4, this._asyncStorage.setItem(this._getActualKey(s), o)] : [3, 4];\n\n            case 3:\n              return l.sent(), t.push(a), [3, 5];\n\n            case 4:\n              t.push(qt.storeItemSizeExceeded), l.label = 5;\n\n            case 5:\n              return [3, 7];\n\n            case 6:\n              return l.sent(), t.push(qt.collectionWriteFailed), [3, 7];\n\n            case 7:\n              return n++, [3, 1];\n\n            case 8:\n              return [2, t];\n          }\n        });\n      });\n    }, e.prototype.remove = function (e) {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, this._asyncStorage.removeItem(this._getActualKey(e))];\n\n            case 1:\n              return t.sent(), [2, e];\n          }\n        });\n      });\n    }, e.prototype.removeMany = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r;\n        return P(this, function (i) {\n          switch (i.label) {\n            case 0:\n              t = 0, n = e, i.label = 1;\n\n            case 1:\n              return t < n.length ? (r = n[t], [4, this._asyncStorage.removeItem(this._getActualKey(r))]) : [3, 4];\n\n            case 2:\n              i.sent(), i.label = 3;\n\n            case 3:\n              return t++, [3, 1];\n\n            case 4:\n              return [2, e];\n          }\n        });\n      });\n    }, e.prototype.clear = function () {\n      return L(this, void 0, void 0, function () {\n        var e;\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, this.getAllKeys()];\n\n            case 1:\n              return e = t.sent(), [4, this.removeMany(e)];\n\n            case 2:\n              return t.sent(), [4, this.remove(Rn.key)];\n\n            case 3:\n              return t.sent(), [2];\n          }\n        });\n      });\n    }, e;\n  }(),\n      Gn = function () {\n    function e(e) {\n      var t = e.MMKV,\n          n = e.encryption,\n          r = void 0 === n ? Ln : n;\n      this.itemSizeLimit = 6291456, this._mmkv = t, this._encryption = r;\n    }\n\n    return e.prototype._isBelonging = function (e) {\n      return e.startsWith(\"\".concat(this.dbname, \"/\"));\n    }, e.prototype._getActualKey = function (e) {\n      return \"\".concat(this.dbname, \"/\").concat(e);\n    }, e.prototype.init = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              this.dbname = e, n.label = 1;\n\n            case 1:\n              return n.trys.push([1,, 3, 5]), [4, this.get(Rn.key)];\n\n            case 2:\n              if ((t = n.sent()) && JSON.stringify(t) !== JSON.stringify(Rn.value)) throw qt.storeEncryptionInvalid;\n              return [3, 5];\n\n            case 3:\n              return [4, this.set(Rn)];\n\n            case 4:\n              return n.sent(), [7];\n\n            case 5:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.getAllKeys = function () {\n      return L(this, void 0, void 0, function () {\n        var e,\n            t,\n            n = this;\n        return P(this, function (r) {\n          return e = this._getActualKey(Rn.key), t = this._mmkv.getAllKeys(), [2, t.filter(function (t) {\n            return n._isBelonging(t) && t !== e;\n          }).map(function (e) {\n            return e.substr(\"\".concat(n.dbname, \"/\").length);\n          })];\n        });\n      });\n    }, e.prototype.get = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, this._mmkv.getString(this._getActualKey(e))];\n\n            case 1:\n              return [2, (t = n.sent()) ? this._encryption.decrypt(JSON.parse(t)) : null];\n          }\n        });\n      });\n    }, e.prototype.set = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r;\n        return P(this, function (i) {\n          if (t = e.key, n = e.value, r = JSON.stringify(this._encryption.encrypt(n)), t === Rn.key || r.length < this.itemSizeLimit) return this._mmkv.set(this._getActualKey(t), r), [2, JSON.parse(r)];\n          throw qt.storeItemSizeExceeded;\n        });\n      });\n    }, e.prototype.setMany = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r, i, s, a, o;\n        return P(this, function (l) {\n          for (t = [], n = 0, r = e; n < r.length; n++) {\n            i = r[n];\n\n            try {\n              s = i.key, a = i.value, o = JSON.stringify(this._encryption.encrypt(a)), s === Rn.key || o.length < this.itemSizeLimit ? (this._mmkv.set(this._getActualKey(s), o), t.push(a)) : t.push(qt.storeItemSizeExceeded);\n            } catch (e) {\n              t.push(qt.collectionWriteFailed);\n            }\n          }\n\n          return [2, t];\n        });\n      });\n    }, e.prototype.remove = function (e) {\n      return L(this, void 0, void 0, function () {\n        return P(this, function (t) {\n          return this._mmkv.delete(this._getActualKey(e)), [2, e];\n        });\n      });\n    }, e.prototype.removeMany = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t, n, r;\n        return P(this, function (i) {\n          for (t = 0, n = e; t < n.length; t++) {\n            r = n[t], this._mmkv.delete(this._getActualKey(r));\n          }\n\n          return [2, e];\n        });\n      });\n    }, e.prototype.clear = function () {\n      return L(this, void 0, void 0, function () {\n        var e;\n        return P(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, this.getAllKeys()];\n\n            case 1:\n              return e = t.sent(), [4, this.removeMany(e)];\n\n            case 2:\n              return t.sent(), [4, this.remove(Rn.key)];\n\n            case 3:\n              return t.sent(), [2];\n          }\n        });\n      });\n    }, e;\n  }(),\n      xn = \"[NESTDB]\",\n      jn = !0,\n      Bn = function () {\n    function e() {}\n\n    return e.off = function () {\n      jn = !1;\n    }, e.log = function () {\n      for (var e = [], t = 0; t < arguments.length; t++) {\n        e[t] = arguments[t];\n      }\n\n      jn && console.log.apply(console, w([\"\".concat(xn, \"[LOG]\")], e, !1));\n    }, e.warning = function () {\n      for (var e = [], t = 0; t < arguments.length; t++) {\n        e[t] = arguments[t];\n      }\n\n      jn && console.warn.apply(console, w([\"\".concat(xn, \"[WARNING]\")], e, !1));\n    }, e.error = function () {\n      for (var e = [], t = 0; t < arguments.length; t++) {\n        e[t] = arguments[t];\n      }\n\n      jn && console.error.apply(console, w([\"\".concat(xn, \"[ERROR]\")], e, !1));\n    }, e;\n  }();\n\n  !function (e) {\n    e.INIT = \"INIT\", e.OPENING = \"OPENING\", e.OPENED = \"OPENED\", e.CLOSED = \"CLOSED\";\n  }(On || (On = {}));\n\n  var Vn,\n      qn,\n      Kn,\n      zn,\n      Yn,\n      Qn,\n      Wn,\n      Jn = function () {\n    function e(e) {\n      var t = e.name,\n          n = e.version,\n          r = e.store,\n          i = e.config;\n      this.name = t, this._version = n, this._state = On.INIT, this._config = i || new Bt({\n        dbname: t\n      }), this._store = r, this._event = {\n        success: Xt,\n        error: Xt,\n        upgrade: en\n      }, this._collections = new Map(), this._globalMutex = new Mn(\"\".concat(this.name, \".lock\")), this._config.disableLogger && Bn.off(), new yn({\n        dbname: t,\n        limit: this._config.cacheLimit\n      });\n    }\n\n    return Object.defineProperty(e.prototype, \"version\", {\n      get: function get() {\n        return this._version;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"state\", {\n      get: function get() {\n        return this._state;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.commitSchema = function (e) {\n      return L(this, void 0, void 0, function () {\n        var t = this;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return this._state !== On.OPENING ? [3, 2] : [4, Promise.all(e.map(function (e) {\n                return L(t, void 0, void 0, function () {\n                  var t, n, r, i;\n                  return P(this, function (s) {\n                    switch (s.label) {\n                      case 0:\n                        return t = e.collectionName, n = e.keyName, r = e.index, i = void 0 === r ? [] : r, this._collections.has(t) || this._collections.set(t, new kn({\n                          dbname: this.name,\n                          collectionName: t,\n                          keyName: n,\n                          keyHash: e.keyHash || null,\n                          indexes: i,\n                          store: this._store\n                        })), [4, this._collections.get(t).init()];\n\n                      case 1:\n                        return s.sent(), [2];\n                    }\n                  });\n                });\n              }))];\n\n            case 1:\n              return n.sent(), [3, 3];\n\n            case 2:\n              throw qt.databaseSchemaNotOnUpgrade;\n\n            case 3:\n              return [2];\n          }\n        });\n      });\n    }, e.prototype.open = function () {\n      var e;\n      return L(this, void 0, void 0, function () {\n        var t,\n            n,\n            r,\n            i,\n            s = this;\n        return P(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return [4, this._globalMutex.lock()];\n\n            case 1:\n              if (a.sent(), this._state === On.OPENED) return [3, 15];\n              this._state = On.OPENING, a.label = 2;\n\n            case 2:\n              return a.trys.push([2, 5,, 15]), [4, this._store.init(this.name)];\n\n            case 3:\n              return a.sent(), o = this.name, t = \"\".concat(ln(o), \".metadata\"), n = {\n                version: 0,\n                collectionNames: []\n              }, [4, this._store.get(t)];\n\n            case 4:\n              return r = null !== (e = a.sent()) && void 0 !== e ? e : n, [2, new Promise(function (e, n) {\n                var i = function i(e) {\n                  r.version < s._version ? s._event.upgrade(r.version, function (n) {\n                    return L(s, void 0, void 0, function () {\n                      var i;\n                      return P(this, function (s) {\n                        switch (s.label) {\n                          case 0:\n                            if (n) return [3, 5];\n                            r.version++, r.collectionNames = Array.from(this._collections.keys()), s.label = 1;\n\n                          case 1:\n                            return s.trys.push([1, 3,, 4]), [4, this._store.set({\n                              key: t,\n                              value: r,\n                              generation: this._version\n                            })];\n\n                          case 2:\n                            return s.sent(), e({\n                              continued: !0\n                            }), [3, 4];\n\n                          case 3:\n                            return i = s.sent(), e({\n                              continued: !1,\n                              err: i\n                            }), [3, 4];\n\n                          case 4:\n                            return [3, 6];\n\n                          case 5:\n                            e({\n                              continued: !1,\n                              err: n\n                            }), s.label = 6;\n\n                          case 6:\n                            return [2];\n                        }\n                      });\n                    });\n                  }) : e({\n                    continued: !1\n                  });\n                },\n                    a = function a(t) {\n                  var o = t.continued,\n                      l = void 0 !== o && o,\n                      u = t.err,\n                      c = void 0 === u ? null : u;\n                  if (l) setTimeout(function () {\n                    return i(a);\n                  }, 10);else if (c) Bn.error(c.message), s._globalMutex.unlock(), s._event.error(c), n(c);else {\n                    var d = [];\n                    r.collectionNames.forEach(function (e) {\n                      s._collections.has(e) || d.push(L(s, void 0, void 0, function () {\n                        var t, n;\n                        return P(this, function (r) {\n                          switch (r.label) {\n                            case 0:\n                              return [4, kn.metadataOf(this.name, e, this._store)];\n\n                            case 1:\n                              return (t = r.sent()) ? (n = new kn({\n                                dbname: this.name,\n                                collectionName: e,\n                                keyName: t.keyName,\n                                indexes: t.indexes,\n                                store: this._store\n                              }), this._collections.set(e, n), [4, n.init()]) : [3, 3];\n\n                            case 2:\n                              r.sent(), r.label = 3;\n\n                            case 3:\n                              return [2];\n                          }\n                        });\n                      }));\n                    }), Promise.all(d).then(function () {\n                      s._state = On.OPENED, s._globalMutex.unlock(), s._event.success(), e();\n                    }).catch(function (e) {\n                      Bn.error(e.message), s._globalMutex.unlock(), s._event.error(e), n(e);\n                    });\n                  }\n                };\n\n                i(a);\n              })];\n\n            case 5:\n              switch (i = a.sent(), i.code) {\n                case xt.STORE_NOT_AVAILABLE_IN_PRIVATE_BROWSING:\n                  return [3, 6];\n\n                case xt.STORE_NOT_AVAILABLE:\n                  return [3, 8];\n\n                case xt.STORE_ENCRYPTION_INVALID:\n                  return [3, 10];\n              }\n\n              return [3, 13];\n\n            case 6:\n              return Bn.warning(\"Access to the local storage is not allowed in private browsing. Switched to MemoryStore automatically.\"), this._store = new wn({}), this._globalMutex.unlock(), this._event.error(i), [4, this.open()];\n\n            case 7:\n              return a.sent(), [3, 14];\n\n            case 8:\n              return Bn.warning(\"IndexedDB is not available in this environment. Switched to MemoryStore automatically. Consider using other store to save data persistently (e.g. AsyncStorage).\"), this._store = new wn({}), this._globalMutex.unlock(), this._event.error(i), [4, this.open()];\n\n            case 9:\n              return a.sent(), [3, 14];\n\n            case 10:\n              return Bn.warning(\"Encryption algorithm has changed. Stored data would be cleared.\"), [4, this._store.clear()];\n\n            case 11:\n              return a.sent(), this._globalMutex.unlock(), this._event.error(i), [4, this.open()];\n\n            case 12:\n              return a.sent(), [3, 14];\n\n            case 13:\n              throw Bn.error(i.message), this._globalMutex.unlock(), this._event.error(i), i;\n\n            case 14:\n              return [3, 15];\n\n            case 15:\n              return [2];\n          }\n\n          var o;\n        });\n      });\n    }, e.prototype.close = function () {\n      this._state = On.CLOSED, this._collections.forEach(function (e) {\n        return e.close();\n      });\n    }, e.prototype.reset = function () {\n      return L(this, void 0, void 0, function () {\n        var e,\n            t = this;\n        return P(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return (e = yn.get(this.name)) && e.clearByCondition(function (e) {\n                return e.key.startsWith(ln(t.name));\n              }), [4, this._store.clear()];\n\n            case 1:\n              return n.sent(), [2];\n          }\n        });\n      });\n    }, e.prototype.on = function (e, t) {\n      this._event[e] = t;\n    }, e.prototype.off = function (e) {\n      if (\"function\" == typeof this._event[e]) if (\"upgrade\" === e) this._event[e] = en;else this._event[e] = Xt;\n    }, e.prototype.collection = function (e) {\n      return this._collections.get(e) || null;\n    }, e;\n  }(),\n      Xn = function () {\n    function e() {}\n\n    return e.create = function () {\n      return \"\".concat(Math.floor(1e5 * Math.random()), \"-\").concat(new Date().getTime());\n    }, e;\n  }();\n\n  !function (e) {\n    e.AND = \"AND\", e.OR = \"OR\";\n  }(Vn || (Vn = {})), function (e) {\n    e.MEMBER_NICKNAME = \"member_nickname\", e.CHANNEL_NAME = \"channel_name\";\n  }(qn || (qn = {})), function (e) {\n    e.ALL = \"all\", e.JOINED = \"joined_only\", e.INVITED = \"invited_only\", e.INVITED_BY_FRIEND = \"invited_by_friend\", e.INVITED_BY_NON_FRIEND = \"invited_by_non_friend\";\n  }(Kn || (Kn = {})), function (e) {\n    e.ALL = \"all\", e.SUPER = \"super\", e.NON_SUPER = \"nonsuper\";\n  }(zn || (zn = {})), function (e) {\n    e.ALL = \"all\", e.PUBLIC = \"public\", e.PRIVATE = \"private\";\n  }(Yn || (Yn = {})), function (e) {\n    e.ALL = \"all\", e.UNREAD_MESSAGE = \"unread_message\";\n  }(Qn || (Qn = {})), function (e) {\n    e.ALL = \"all\", e.UNHIDDEN = \"unhidden_only\", e.HIDDEN = \"hidden_only\", e.HIDDEN_ALLOW_AUTO_UNHIDE = \"hidden_allow_auto_unhide\", e.HIDDEN_PREVENT_AUTO_UNHIDE = \"hidden_prevent_auto_unhide\";\n  }(Wn || (Wn = {}));\n\n  var Zn = function () {\n    function e() {\n      this._iid = null, this._searchFilter = {}, this._userIdsFilter = {\n        userIds: [],\n        includeMode: !0,\n        queryType: Vn.AND\n      }, this.includeEmpty = !1, this.nicknameContainsFilter = \"\", this.nicknameStartsWithFilter = \"\", this.nicknameExactMatchFilter = \"\", this.channelNameContainsFilter = \"\", this.memberStateFilter = Kn.ALL, this.customTypesFilter = [], this.channelUrlsFilter = [], this.superChannelFilter = zn.ALL, this.publicChannelFilter = Yn.ALL, this.customTypeStartsWithFilter = null, this.unreadChannelFilter = Qn.ALL, this.hiddenChannelFilter = Wn.UNHIDDEN, this.includeFrozen = !0;\n    }\n\n    return Object.defineProperty(e.prototype, \"searchFilter\", {\n      get: function get() {\n        return this._searchFilter;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype._isFriend = function (e) {\n      return !!e.friendDiscoveryKey || !!e.friendName;\n    }, Object.defineProperty(e.prototype, \"iid\", {\n      set: function set(e) {\n        this._iid = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.setSearchFilter = function (e, t) {\n      Array.isArray(e) && 0 !== e.length && \"string\" == typeof t && t && (this._searchFilter = {\n        searchQuery: t,\n        searchFields: e\n      });\n    }, Object.defineProperty(e.prototype, \"userIdsFilter\", {\n      get: function get() {\n        return this._userIdsFilter;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.setUserIdsFilter = function (e, t, n) {\n      void 0 === n && (n = Vn.AND), this._userIdsFilter = {\n        userIds: e,\n        includeMode: t,\n        queryType: n\n      };\n    }, e.prototype.clone = function () {\n      var t = new e();\n      t.setSearchFilter(this.searchFilter.searchFields, this.searchFilter.searchQuery), t.setUserIdsFilter(this.userIdsFilter.userIds, this.userIdsFilter.includeMode, this.userIdsFilter.queryType);\n      var n = JSON.parse(JSON.stringify(this));\n      return Object.keys(n).forEach(function (e) {\n        t[e] = n[e];\n      }), t;\n    }, e.prototype.match = function (e) {\n      var t = this._searchFilter,\n          n = t.searchQuery,\n          r = t.searchFields;\n      if (n && r && r.length > 0 && !r.some(function (t) {\n        switch (t) {\n          case qn.CHANNEL_NAME:\n            return e.name.toLowerCase().includes(n.toLowerCase());\n\n          case qn.MEMBER_NICKNAME:\n            return e.members.some(function (e) {\n              return e.nickname.toLowerCase().includes(n.toLowerCase());\n            });\n\n          default:\n            return !0;\n        }\n      })) return !1;\n      var i = this._userIdsFilter,\n          s = i.includeMode,\n          a = i.queryType,\n          o = i.userIds,\n          l = U.get(this._iid).get(\"currentUserId\"),\n          u = e.members.map(function (e) {\n        return e.userId;\n      });\n\n      if (s) {\n        if (o.length > 0) switch (a) {\n          case Vn.AND:\n            if (o.some(function (e) {\n              return !u.includes(e);\n            })) return !1;\n            break;\n\n          case Vn.OR:\n            if (o.every(function (e) {\n              return !u.includes(e);\n            })) return !1;\n        }\n      } else {\n        if (o.includes(l) || o.push(l), e.members.length > o.length) return !1;\n        if (!function (e, t) {\n          if (e === t) return !0;\n          if (null == e || null == t) return !1;\n          if (e.length !== t.length) return !1;\n\n          for (var n = w([], e, !0).sort(), r = w([], t, !0).sort(), i = 0; i < n.length; ++i) {\n            if (n[i] !== r[i]) return !1;\n          }\n\n          return !0;\n        }(o, u)) return !1;\n      }\n\n      if (!this.includeEmpty && !e.lastMessage) return !1;\n      if (!this.includeFrozen && e.isFrozen) return !1;\n      if (this.customTypesFilter.length > 0 && !this.customTypesFilter.includes(e.customType)) return !1;\n      if (this.customTypeStartsWithFilter && !new RegExp(\"^\".concat(this.customTypeStartsWithFilter)).test(e.customType)) return !1;\n      if (this.channelNameContainsFilter && !e.name.toLowerCase().includes(this.channelNameContainsFilter.toLowerCase())) return !1;\n\n      if (this.nicknameContainsFilter) {\n        var c = this.nicknameContainsFilter.toLowerCase();\n        if (e.members.every(function (e) {\n          return !e.nickname.toLowerCase().includes(c);\n        })) return !1;\n      }\n\n      if (this.nicknameStartsWithFilter) {\n        var d = this.nicknameStartsWithFilter.toLowerCase();\n        if (e.members.every(function (e) {\n          return !e.nickname.toLowerCase().startsWith(d);\n        })) return !1;\n      }\n\n      if (this.nicknameExactMatchFilter) {\n        var h = this.nicknameExactMatchFilter.toLowerCase();\n        if (e.members.every(function (e) {\n          return e.nickname.toLowerCase() !== h;\n        })) return !1;\n      }\n\n      if (this.channelUrlsFilter.length > 0 && !this.channelUrlsFilter.includes(e.url)) return !1;\n      if (this.memberStateFilter) switch (this.memberStateFilter) {\n        case Kn.JOINED:\n          if (\"joined\" !== e.myMemberState) return !1;\n          break;\n\n        case Kn.INVITED:\n          if (\"invited\" !== e.myMemberState) return !1;\n          break;\n\n        case Kn.INVITED_BY_FRIEND:\n          if (\"invited\" !== e.myMemberState || !this._isFriend(e.inviter)) return !1;\n          break;\n\n        case Kn.INVITED_BY_NON_FRIEND:\n          if (\"invited\" !== e.myMemberState || this._isFriend(e.inviter)) return !1;\n      }\n      if (this.hiddenChannelFilter) switch (this.hiddenChannelFilter) {\n        case Wn.UNHIDDEN:\n          if (e.isHidden || \"unhidden\" !== e.hiddenState) return !1;\n          break;\n\n        case Wn.HIDDEN:\n          if (!e.isHidden) return !1;\n          break;\n\n        case Wn.HIDDEN_ALLOW_AUTO_UNHIDE:\n          if (!e.isHidden || \"hidden_allow_auto_unhide\" !== e.hiddenState) return !1;\n          break;\n\n        case Wn.HIDDEN_PREVENT_AUTO_UNHIDE:\n          if (!e.isHidden || \"hidden_prevent_auto_unhide\" !== e.hiddenState) return !1;\n      }\n      if (this.unreadChannelFilter && this.unreadChannelFilter === Qn.UNREAD_MESSAGE) if (0 === e.unreadMessageCount) return !1;\n      if (this.publicChannelFilter) switch (this.publicChannelFilter) {\n        case Yn.PUBLIC:\n          if (!e.isPublic || \"none\" === e.myMemberState) return !1;\n          break;\n\n        case Yn.PRIVATE:\n          if (e.isPublic) return !1;\n      }\n      if (this.superChannelFilter) switch (this.superChannelFilter) {\n        case zn.SUPER:\n          if (!e.isSuper) return !1;\n          break;\n\n        case zn.NON_SUPER:\n          if (e.isSuper) return !1;\n      }\n      return !0;\n    }, e.QueryType = Vn, e.SearchField = qn, e.MemberStateFilter = Kn, e.SuperChannelFilter = zn, e.PublicChannelFilter = Yn, e.UnreadChannelFilter = Qn, e.HiddenChannelFilter = Wn, e;\n  }(),\n      $n = function () {\n    function e(e) {\n      var t = e.iid;\n      this._iid = t, this._filter = new Zn(), this._filter.iid = this._iid, this._order = ot.LATEST_LAST_MESSAGE, this._limit = 20;\n    }\n\n    return e.prototype.setFilter = function (e) {\n      return this._filter = e.clone(), this._filter.iid = this._iid, this;\n    }, e.prototype.setOrder = function (e) {\n      return this._order = e, this;\n    }, e.prototype.setLimit = function (e) {\n      return this._limit = e, this;\n    }, e.prototype.build = function () {\n      return new Et({\n        iid: this._iid,\n        filter: this._filter,\n        order: this._order,\n        limit: this._limit\n      });\n    }, e;\n  }(),\n      er = function () {\n    function e(e) {\n      var t = e.iid,\n          n = e.channel;\n      this._iid = t, this._channel = n, this._startingPoint = Date.now(), this._filter = new Re(), this._limit = 100;\n    }\n\n    return e.prototype.setFilter = function (e) {\n      return this._filter = e.clone(), this;\n    }, e.prototype.setStartingPoint = function (e) {\n      return this._startingPoint = e, this;\n    }, e.prototype.setLimit = function (e) {\n      return this._limit = e, this;\n    }, e.prototype.build = function () {\n      return new nt({\n        iid: this._iid,\n        channel: this._channel,\n        startingPoint: this._startingPoint,\n        filter: this._filter,\n        limit: this._limit\n      });\n    }, e;\n  }(),\n      tr = {},\n      nr = {},\n      rr = new WeakMap(),\n      ir = new WeakMap(),\n      sr = new WeakMap(),\n      ar = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n(e) {\n      var r;\n      return c(this, n), (r = t.call(this, e)).channelType = Rt.CHANNEL_TYPE_GROUP, r.isDistinct = !1, r.isSuper = !1, r.isBroadcast = !1, r.isPublic = !1, r.unreadMessageCount = 0, r.inviter = null, r.members = [], r.memberMap = {}, r.lastMessage = null, r.memberCount = 0, r.joinedMemberCount = 0, r.cachedReadReceiptStatus = {}, r.cachedDeliveryReceiptStatus = null, r.myPushTriggerOption = n.PushTriggerOption.DEFAULT, r.isPushEnabled, r.isHidden = !1, r.hiddenState = n.HiddenState.UNHIDDEN, r.isDiscoverable = !0, r.myLastRead = 0, r.messageSurvivalSeconds = -1, r.invitedAt = 0, r.joinedAt = 0, r._messageOffsetTimestamp = 0, r._cachedLastDeliveredReceipt = {\n        sentAt: 0,\n        timeout: null\n      }, rr.set(y(r), {}), ir.set(y(r), {\n        start: 0,\n        end: 0\n      }), sr.set(y(r), 0), e && r._update(e), r;\n    }\n\n    return h(n, [{\n      key: \"messageOffsetTimestamp\",\n      get: function get() {\n        return this._messageOffsetTimestamp;\n      }\n    }, {\n      key: \"createMessageCollection\",\n      value: function value() {\n        return new er({\n          iid: this._iid,\n          channel: this\n        });\n      }\n    }, {\n      key: \"_setGroupChannelUnreadCount\",\n      value: function value(e, t) {\n        try {\n          if (\"number\" == typeof e && e >= 0) if (\"all\" === this.myCountPreference || \"unread_message_count_only\" === this.myCountPreference) {\n            if (this.isSuper || this.isBroadcast) {\n              var n = U.get(this._iid).container.maxUnreadCountOfSuperGroupChannel;\n              this.unreadMessageCount = e >= n ? n : e;\n            } else this.unreadMessageCount = e;\n          } else this.unreadMessageCount = 0;\n          \"number\" == typeof t && t >= 0 && (\"all\" === this.myCountPreference || \"unread_mention_count_only\" === this.myCountPreference ? this.unreadMentionCount = t : this.unreadMentionCount = 0);\n        } catch (e) {}\n      }\n    }, {\n      key: \"_update\",\n      value: function value(e) {\n        var t = this,\n            n = x.get(this._iid),\n            r = n.BaseChannel,\n            i = n.GroupChannel,\n            s = n.User,\n            a = n.Member;\n\n        if (this.isAccessCodeRequired = !!e.is_access_code_required && e.is_access_code_required, this.isDistinct = !!e.is_distinct && e.is_distinct, this.isPushEnabled = !!e.is_push_enabled && e.is_push_enabled, this.isHidden = !!e.hasOwnProperty(\"is_hidden\") && e.is_hidden, this.myPushTriggerOption = e.push_trigger_option ? e.push_trigger_option : i.PushTriggerOption.DEFAULT, this.myCountPreference = e.hasOwnProperty(\"count_preference\") ? e.count_preference : i.CountPreference.ALL, this.unreadMessageCount = 0, this.unreadMentionCount = 0, this._setGroupChannelUnreadCount(parseInt(e.unread_message_count), parseInt(e.unread_mention_count)), e.hasOwnProperty(\"read_receipt\") && (this.cachedReadReceiptStatus = {}, Object.keys(e.read_receipt).forEach(function (n) {\n          var r = e.read_receipt[n];\n          t.updateReadReceipt(n, parseInt(r));\n        })), e.hasOwnProperty(\"delivery_receipt\") && \"object\" === u(e.delivery_receipt) && null !== e.delivery_receipt && (this.cachedDeliveryReceiptStatus || (this.cachedDeliveryReceiptStatus = {}), Object.keys(e.delivery_receipt).forEach(function (n) {\n          var r = e.delivery_receipt[n];\n          t.updateDeliveryReceipt(n, parseInt(r));\n        })), e.hasOwnProperty(\"user_last_read\") && \"number\" == typeof e.user_last_read ? this.myLastRead = e.user_last_read : this.myLastRead = 0, e.hasOwnProperty(\"members\")) {\n          this.members = [], this.memberMap = {};\n\n          for (var o = 0; o < e.members.length; o++) {\n            var l = new a(e.members[o]);\n            this.members.push(l), this.memberMap[l.userId] = l;\n          }\n        }\n\n        this.myMemberState = e.member_state || \"none\", this.myRole = e.my_role || i.Role.NONE, e.hasOwnProperty(\"is_muted\") ? \"string\" == typeof e.is_muted ? this.myMutedState = e.is_muted : \"boolean\" == typeof e.is_muted ? this.myMutedState = e.is_muted ? \"muted\" : \"unmuted\" : this.myMutedState = \"unmuted\" : this.myMutedState = \"unmuted\", e.hasOwnProperty(\"member_count\") && (this.memberCount = parseInt(e.member_count)), e.hasOwnProperty(\"joined_member_count\") && (this.joinedMemberCount = parseInt(e.joined_member_count)), e.hasOwnProperty(\"last_message\") && \"object\" === u(e.last_message) && e.last_message ? e.last_message instanceof Tt ? this.lastMessage = e.last_message : this.lastMessage = r.buildMessage(e.last_message, this) : this.lastMessage = null, e.hasOwnProperty(\"inviter\") && null !== e.inviter && \"object\" === u(e.inviter) && Object.keys(e.inviter).length > 0 ? this.inviter = new s(e.inviter) : this.inviter = null, this.invitedAt = e.invited_at || 0, this.joinedAt = e.joined_ts || 0, e.hasOwnProperty(\"is_super\") && \"boolean\" == typeof e.is_super ? this.isSuper = e.is_super : this.isSuper = !1, e.hasOwnProperty(\"is_broadcast\") && \"boolean\" == typeof e.is_broadcast ? this.isBroadcast = e.is_broadcast : this.isBroadcast = !1, e.hasOwnProperty(\"is_public\") && \"boolean\" == typeof e.is_public ? this.isPublic = e.is_public : this.isPublic = !1, e.hasOwnProperty(\"hidden_state\") ? this.hiddenState = e.hidden_state : this.hiddenState = i.HiddenState.UNHIDDEN, e.hasOwnProperty(\"is_discoverable\") && \"boolean\" == typeof e.is_discoverable ? this.isDiscoverable = e.is_discoverable : this.isDiscoverable = this.isPublic, e.hasOwnProperty(\"ts_message_offset\") && (this._messageOffsetTimestamp = e.ts_message_offset), e.hasOwnProperty(\"message_survival_seconds\") && \"number\" == typeof e.message_survival_seconds && (this.messageSurvivalSeconds = e.message_survival_seconds);\n      }\n    }, {\n      key: \"addMember\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n\n        if (!this.isSuper && !this.isBroadcast) {\n          var n = x.get(this._iid),\n              r = n.Member,\n              i = this.removeMember(e);\n          i && i.state === r.JOINED && (e.state = r.JOINED), this.memberMap[e.userId] = e, this.members.push(e), this.memberCount++, this.updateReadReceipt(e.userId, t), this.updateDeliveryReceipt(e.userId, t);\n        }\n      }\n    }, {\n      key: \"removeMember\",\n      value: function value(e) {\n        var t = null;\n\n        if (!this.isSuper && !this.isBroadcast && this.memberMap.hasOwnProperty(e.userId)) {\n          delete this.memberMap[e.userId];\n\n          for (var n = 0; n < this.members.length; n++) {\n            var r = this.members[n];\n\n            if (r.userId === e.userId) {\n              t = r, this.members.splice(n, 1);\n              break;\n            }\n          }\n\n          this.memberCount--;\n        }\n\n        return t;\n      }\n    }, {\n      key: \"parse\",\n      value: function value(e) {\n        this._update(e);\n      }\n    }, {\n      key: \"update\",\n      value: function value(e) {\n        this.__update(e), this._update(e);\n      }\n    }, {\n      key: \"isIdentical\",\n      value: function value(e) {\n        return e && this.url === e.url;\n      }\n    }, {\n      key: \"isEqual\",\n      value: function value(e) {\n        return se.deepEqual(this, e);\n      }\n    }, {\n      key: \"createMemberListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).MemberListQuery)(this.url);\n      }\n    }, {\n      key: \"createBannedUserListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).BannedUserListQuery)({\n          channelUrl: this.url,\n          isOpenChannel: this.isOpenChannel()\n        });\n      }\n    }, {\n      key: \"refresh\",\n      value: function value(e) {\n        return x.get(this._iid).GroupChannel.getChannelWithoutCache(this.url, e);\n      }\n    }, {\n      key: \"updateChannel\",\n      value: function value() {\n        var e = this,\n            t = me.toArray(arguments),\n            n = void 0;\n        \"function\" == typeof t[t.length - 1] && (n = t.pop());\n        var r = x.get(this._iid),\n            i = r.GroupChannel,\n            s = r.GroupChannelParams;\n        if (t[0] instanceof s && 1 === t.length) return oe(this._iid, function (n) {\n          var r = t[0];\n          (r.channelUrl = e.url, r._validate()) ? U.get(e._iid).container.apiClient.updateGroupChannel(l(l({}, r), {}, {\n            operatorUserIds: r.operatorUserIds\n          }), function (e, t) {\n            var r = null;\n            e || (r = i.upsert(t)), n(e, r);\n          }) : n(me.error, null);\n        }, n);\n\n        if (3 === t.length) {\n          var a = new s();\n          return a.channelUrl = this.url, a.name = t[0], \"string\" == typeof t[1] ? a.coverUrl = t[1] : a.coverImage = t[1], a.data = t[2], n ? this.updateChannel(a, n) : this.updateChannel(a);\n        }\n\n        if (4 === t.length) {\n          var o = new s();\n          return o.channelUrl = this.url, o.isDistinct = t[0], o.name = t[1], \"string\" == typeof t[1] ? o.coverUrl = t[2] : o.coverImage = t[2], o.data = t[3], n ? this.updateChannel(o, n) : this.updateChannel(o);\n        }\n\n        if (5 === t.length) {\n          var u = new s();\n          return u.channelUrl = this.url, u.isDistinct = t[0], u.name = t[1], \"string\" == typeof t[2] ? u.coverUrl = t[2] : u.coverImage = t[2], u.data = t[3], u.customType = t[4], n ? this.updateChannel(u, n) : this.updateChannel(u);\n        }\n\n        return oe(this._iid, function (e) {\n          return e(me.error, null);\n        }, n);\n      }\n    }, {\n      key: \"invite\",\n      value: function value(e, t) {\n        var n = null,\n            r = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.length > 0 && e.every(function (e) {\n              return !!e.userId && \"string\" == typeof e.userId;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 3);\n        return n = i[0], e = i[1], t = i[2], n ? oe(this._iid, function (e) {\n          return e(me.error, null);\n        }, t) : this.inviteWithUserIds(e.map(function (e) {\n          return e.userId;\n        }), t);\n      }\n    }, {\n      key: \"inviteWithUserIds\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.inviteToGroupChannel({\n            channelUrl: n.url,\n            userIds: e\n          }, function (e, r) {\n            var i = null;\n            e || (i = x.get(n._iid).GroupChannel.upsert(r));\n            t(e, i);\n          });\n        }, t);\n      }\n    }, {\n      key: \"acceptInvitation\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          optional: !0,\n          defaultValue: null\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.acceptInvitation({\n            channelUrl: n.url,\n            accessCode: e\n          }, function (e, r) {\n            var i = null;\n            e || ((i = x.get(n._iid).GroupChannel.upsert(r)).myMemberState = \"joined\");\n            t(e, i);\n          });\n        }, t);\n      }\n    }, {\n      key: \"declineInvitation\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.declineInvitation({\n            channelUrl: t.url\n          }, function (n, r) {\n            var i = null;\n\n            if (!n) {\n              var s = x.get(t._iid).GroupChannel;\n              (i = s.upsert(r)).myMemberState = \"none\", t.isPublic || s.removeCachedChannel(t.url);\n            }\n\n            e(n, i);\n          });\n        }, e);\n      }\n    }, {\n      key: \"join\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          optional: !0,\n          defaultValue: null\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.joinGroupChannel({\n            channelUrl: n.url,\n            accessCode: e\n          }, function (e, r) {\n            var i = null;\n            e || ((i = x.get(n._iid).GroupChannel.upsert(r)).myMemberState = \"joined\");\n            t(e, i);\n          });\n        }, t);\n      }\n    }, {\n      key: \"leave\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.leaveGroupChannel({\n            channelUrl: t.url\n          }, function (t, n) {\n            return e(t, null);\n          });\n        }, e);\n      }\n    }, {\n      key: \"muteUser\",\n      value: function value(e, t, n, r) {\n        return this.muteUserWithUserId(e ? e.userId : null, t, n, r);\n      }\n    }, {\n      key: \"muteUserWithUserId\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"number\",\n          optional: !0,\n          defaultValue: -1,\n          constraint: function constraint(e) {\n            return e >= -1;\n          }\n        }), new me({\n          type: \"string\",\n          optional: !0,\n          defaultValue: \"\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 5);\n        return s = o[0], e = o[1], t = o[2], n = o[3], r = o[4], oe(this._iid, function (r) {\n          s ? r(s, null) : U.get(i._iid).container.apiClient.muteUser({\n            channelUrl: i.url,\n            userId: e,\n            description: n,\n            seconds: t,\n            isGroupChannel: !0\n          }, function (e, t) {\n            r(e, null);\n          });\n        }, r);\n      }\n    }, {\n      key: \"unmuteUser\",\n      value: function value(e, t) {\n        return this.unmuteUserWithUserId(e ? e.userId : null, t);\n      }\n    }, {\n      key: \"unmuteUserWithUserId\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.unmuteUser({\n            channelUrl: n.url,\n            userId: e,\n            isGroupChannel: !0\n          }, function (e, n) {\n            t(e, null);\n          });\n        }, t);\n      }\n    }, {\n      key: \"banUser\",\n      value: function value(e, t, n, r) {\n        return this.banUserWithUserId(e ? e.userId : null, t, n, r);\n      }\n    }, {\n      key: \"banUserWithUserId\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"number\",\n          optional: !0,\n          defaultValue: -1,\n          constraint: function constraint(e) {\n            return e >= -1;\n          }\n        }), new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 5);\n        return s = o[0], e = o[1], t = o[2], n = o[3], r = o[4], oe(this._iid, function (r) {\n          s ? r(s, null) : U.get(i._iid).container.apiClient.banUser({\n            channelUrl: i.url,\n            userId: e,\n            description: n,\n            seconds: t,\n            isGroupChannel: !0\n          }, function (e, t) {\n            r(e, null);\n          });\n        }, r);\n      }\n    }, {\n      key: \"unbanUser\",\n      value: function value(e, t) {\n        return this.unbanUserWithUserId(e ? e.userId : null, t);\n      }\n    }, {\n      key: \"unbanUserWithUserId\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.unbanUser({\n            channelUrl: n.url,\n            userId: e,\n            isGroupChannel: !0\n          }, function (e, n) {\n            t(e, null);\n          });\n        }, t);\n      }\n    }, {\n      key: \"updateJoinedMemberCount\",\n      value: function value() {\n        if (!this.isSuper && !this.isBroadcast) {\n          var e = x.get(this._iid).Member;\n          this.joinedMemberCount = this.members.filter(function (t) {\n            return t.state === e.JOINED;\n          }).length;\n        }\n      }\n    }, {\n      key: \"setLatestMemberCount\",\n      value: function value(e, t, n) {\n        var r = !1;\n        return \"number\" == typeof e && \"number\" == typeof t && \"number\" == typeof n && n >= sr.get(this) && (sr.set(this, n), r = t !== this.joinedMemberCount || e !== this.memberCount, this.memberCount = e, this.joinedMemberCount = t), r;\n      }\n    }, {\n      key: \"hide\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"boolean\",\n          optional: !0,\n          defaultValue: !1\n        }), new me({\n          type: \"boolean\",\n          optional: !0,\n          defaultValue: !0\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return i = a[0], e = a[1], t = a[2], n = a[3], oe(this._iid, function (n) {\n          i ? n(i, null) : U.get(r._iid).container.apiClient.hideGroupChannel({\n            channelUrl: r.url,\n            hidePreviousMessages: e,\n            allowAutoUnhide: t\n          }, function (i, s) {\n            if (!i) {\n              var a = x.get(r._iid).GroupChannel;\n              r.isHidden = !0, r.hiddenState = t ? a.HiddenState.HIDDEN_ALLOW_AUTO_UNHIDE : a.HiddenState.HIDDEN_PREVENT_AUTO_UNHIDE, e && r._setGroupChannelUnreadCount(0, 0), s.hasOwnProperty(\"ts_message_offset\") && (r._messageOffsetTimestamp = s.ts_message_offset), a.cachedChannels[r.url] = r;\n            }\n\n            n(i, s);\n          });\n        }, n);\n      }\n    }, {\n      key: \"unhide\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.unhideGroupChannel({\n            channelUrl: t.url\n          }, function (n, r) {\n            if (!n) {\n              var i = x.get(t._iid).GroupChannel;\n              t.isHidden = !1, t.hiddenState = i.HiddenState.UNHIDDEN, i.cachedChannels[t.url] = t;\n            }\n\n            e(n, r);\n          });\n        }, e);\n      }\n    }, {\n      key: \"freeze\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.freeze({\n            channelUrl: t.url,\n            isGroupChannel: !0,\n            freezing: !0\n          }, function (n, r) {\n            if (!n) {\n              var i = x.get(t._iid).GroupChannel;\n              t.isFrozen = !0, i.cachedChannels[t.url] = t;\n            }\n\n            e(n, null);\n          });\n        }, e);\n      }\n    }, {\n      key: \"unfreeze\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.freeze({\n            channelUrl: t.url,\n            isGroupChannel: !0,\n            freezing: !1\n          }, function (n, r) {\n            if (!n) {\n              var i = x.get(t._iid).GroupChannel;\n              t.isFrozen = !1, i.cachedChannels[t.url] = t;\n            }\n\n            e(n, null);\n          });\n        }, e);\n      }\n    }, {\n      key: \"delete\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.deleteGroupChannel({\n            channelUrl: t.url\n          }, function (n, r) {\n            n || x.get(t._iid).GroupChannel.removeCachedChannel(t.url);\n            e(n, r);\n          });\n        }, e);\n      }\n    }, {\n      key: \"markAsRead\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          var n = x.get(t._iid).Command,\n              r = ji.getInstance(t._iid),\n              i = n.bRead({\n            channelUrl: t.url\n          });\n          r.sendCommand(i, function (n, i) {\n            if (r.getErrorFirstCallback()) {\n              var s = [n, i];\n              i = s[0], n = s[1];\n            }\n\n            if (i) e(i, null);else if (r.currentUser) {\n              var a = bt.of(t._iid),\n                  o = ge.of(t._iid);\n              t.updateReadReceipt(r.currentUser.userId, n.getJsonElement().ts);\n              var l = !1;\n              (t.unreadMessageCount > 0 || t.unreadMentionCount > 0) && (t._setGroupChannelUnreadCount(0, 0), Object.keys(r.channelHandlers).forEach(function (e) {\n                r.channelHandlers[e].onChannelChanged(t);\n              }), l = !0), e(null, null), a.upsert([t]).then(function () {\n                l && o.send({\n                  source: de.EVENT_CHANNEL_CHANGED,\n                  payload: {\n                    channel: t\n                  }\n                }), o.send({\n                  source: de.EVENT_READ_RECEIPT_UPDATED,\n                  payload: {\n                    channel: t\n                  }\n                });\n              }).catch(function (e) {\n                J.error(e);\n              });\n            } else {\n              var u = new SendBirdException(\"Connection should be made first.\", SendBirdException.CONNECTION_REQUIRED);\n              e(u, null);\n            }\n          });\n        }, e);\n      }\n    }, {\n      key: \"getUnreadMemberCount\",\n      value: function value(e) {\n        var t = U.get(this._iid),\n            n = x.get(this._iid).Member,\n            r = t.container.currentUserId;\n\n        if (e instanceof Tt && !e.isAdminMessage() && r && !this.isSuper && !this.isBroadcast) {\n          for (var i = 0, s = e.createdAt, a = this.members, o = 0; o < a.length; o++) {\n            var l = a[o];\n            if (r !== l.userId && l.state === n.JOINED && (!e.sender || e.sender.userId !== l.userId)) (this.cachedReadReceiptStatus[l.userId] || 0) < s && i++;\n          }\n\n          return i;\n        }\n\n        return 0;\n      }\n    }, {\n      key: \"getReadReceipt\",\n      value: function value(e) {\n        return this.getUnreadMemberCount(e);\n      }\n    }, {\n      key: \"markAsDelivered\",\n      value: function value() {\n        var e = this,\n            t = ji.getInstance(this._iid),\n            n = t.currentUser ? t.currentUser.userId : null;\n        U.get(this._iid).container.apiClient.markAsDelivered({\n          channelUrl: this.url,\n          userId: n\n        }, function (t, r) {\n          if (t) J.debug(t);else {\n            var i = r.hasOwnProperty(\"ts\") ? r.ts : 0;\n            e.updateDeliveryReceipt(n, i);\n          }\n        });\n      }\n    }, {\n      key: \"getUndeliveredMemberCount\",\n      value: function value(e) {\n        var t = U.get(this._iid),\n            n = x.get(this._iid).Member,\n            r = t.container.currentUserId;\n\n        if (this.cachedDeliveryReceiptStatus && e instanceof Tt && !e.isAdminMessage() && r && !this.isSuper && !this.isBroadcast) {\n          var i,\n              s = e.createdAt,\n              a = 0,\n              o = I(this.members);\n\n          try {\n            for (o.s(); !(i = o.n()).done;) {\n              var l = i.value;\n              r === l.userId || l.state !== n.JOINED || e.sender && e.sender.userId === l.userId || this.cachedDeliveryReceiptStatus[l.userId] < s && a++;\n            }\n          } catch (e) {\n            o.e(e);\n          } finally {\n            o.f();\n          }\n\n          return a;\n        }\n\n        return 0;\n      }\n    }, {\n      key: \"getDeliveryReceipt\",\n      value: function value(e) {\n        return this.getUndeliveredMemberCount(e);\n      }\n    }, {\n      key: \"getReadMembers\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n            n = ji.getInstance(this._iid);\n\n        if (n.currentUser && !this.isSuper && !this.isBroadcast && e instanceof Tt && !e.isAdminMessage()) {\n          for (var r = [], i = 0; i < this.members.length; i++) {\n            var s = this.members[i];\n\n            if (t || s.userId !== n.currentUser.userId && s.userId !== e.sender.userId) {\n              var a = this.cachedReadReceiptStatus[s.userId] || 0;\n              a >= e.createdAt && r.push(s);\n            }\n          }\n\n          return r;\n        }\n\n        return [];\n      }\n    }, {\n      key: \"getUnreadMembers\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n            n = ji.getInstance(this._iid);\n\n        if (n.currentUser && !this.isSuper && !this.isBroadcast && e instanceof Tt && !e.isAdminMessage()) {\n          for (var r = [], i = 0; i < this.members.length; i++) {\n            var s = this.members[i];\n\n            if (t || s.userId !== n.currentUser.userId && s.userId !== e.sender.userId) {\n              var a = this.cachedReadReceiptStatus[s.userId] || 0;\n              a < e.createdAt && r.push(s);\n            }\n          }\n\n          return r;\n        }\n\n        return [];\n      }\n    }, {\n      key: \"getReadStatus\",\n      value: function value() {\n        var e = this,\n            t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],\n            n = ji.getInstance(this._iid);\n\n        if (n.currentUser && !this.isSuper && !this.isBroadcast) {\n          for (var r = {}, i = Object.keys(this.cachedReadReceiptStatus), s = function s(_s2) {\n            var a = i[_s2];\n            if (!t && a === n.currentUser.userId) return \"continue\";\n            var o = e.cachedReadReceiptStatus[a],\n                l = e.members.filter(function (e) {\n              return e.userId === a;\n            });\n            r[a] = {\n              user: l.length > 0 ? l[0] : null,\n              last_seen_at: parseInt(o)\n            };\n          }, a = 0; a < i.length; a++) {\n            s(a);\n          }\n\n          return r;\n        }\n\n        return {};\n      }\n    }, {\n      key: \"updateReadReceipt\",\n      value: function value(e, t) {\n        var n = this.cachedReadReceiptStatus[e];\n\n        if (!n || n < t) {\n          this.cachedReadReceiptStatus[e] = t;\n          var r = ji.getInstance(this._iid);\n          r.currentUser && e === r.currentUser.userId && (this.myLastRead = t);\n        }\n      }\n    }, {\n      key: \"updateDeliveryReceipt\",\n      value: function value(e, t) {\n        if (this.cachedDeliveryReceiptStatus) if (this.cachedDeliveryReceiptStatus.hasOwnProperty(e)) {\n          var n = this.cachedDeliveryReceiptStatus[e];\n          (!n || n < t) && (this.cachedDeliveryReceiptStatus[e] = t);\n        } else this.cachedDeliveryReceiptStatus[e] = t;\n      }\n    }, {\n      key: \"startTyping\",\n      value: function value() {\n        var e = ji.getInstance(this._iid),\n            t = new Date().getTime(),\n            n = e.Options.typingIndicatorThrottle;\n        (\"number\" != typeof n || n < 1e3 || n > 9e3) && (n = 1e3);\n        var r = ir.get(this);\n\n        if (t - r.start >= n) {\n          r.end = 0, r.start = t;\n          var i = x.get(this._iid).Command.bTypeStart({\n            channelUrl: this.url,\n            time: r.start\n          });\n          e.sendCommand(i, null);\n        }\n      }\n    }, {\n      key: \"endTyping\",\n      value: function value() {\n        var e = ji.getInstance(this._iid),\n            t = new Date().getTime(),\n            n = e.Options.typingIndicatorThrottle;\n        (\"number\" != typeof n || n < 1e3 || n > 9e3) && (n = 1e3);\n        var r = ir.get(this);\n\n        if (t - r.end >= n) {\n          r.start = 0, r.end = t;\n          var i = x.get(this._iid).Command.bTypeEnd({\n            channelUrl: this.url,\n            time: r.end\n          });\n          e.sendCommand(i, null);\n        }\n      }\n    }, {\n      key: \"invalidateTypingStatus\",\n      value: function value() {\n        var e = rr.get(this),\n            t = new Date().getTime(),\n            n = !1;\n        return Object.keys(e).forEach(function (r) {\n          var i = e[r].ts;\n          t - i >= 1e4 && (delete e[r], n = !0);\n        }), n;\n      }\n    }, {\n      key: \"getTypingMembers\",\n      value: function value() {\n        var e = this,\n            t = rr.get(this),\n            n = [];\n        return Object.keys(t).forEach(function (t) {\n          var r = e.memberMap[t];\n          r && n.push(r);\n        }), n;\n      }\n    }, {\n      key: \"getTypingUsers\",\n      value: function value() {\n        var e = rr.get(this),\n            t = [];\n        return Object.keys(e).forEach(function (n) {\n          var r = e[n].user;\n          t.push(r);\n        }), t;\n      }\n    }, {\n      key: \"updateTypingStatus\",\n      value: function value(e, t) {\n        var n = rr.get(this);\n        t ? n[e.userId] = {\n          user: e,\n          ts: new Date().getTime()\n        } : delete n[e.userId];\n      }\n    }, {\n      key: \"isTyping\",\n      value: function value() {\n        var e = rr.get(this);\n        return 0 !== Object.keys(e).length;\n      }\n    }, {\n      key: \"registerScheduledUserMessage\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.ScheduledUserMessage,\n            s = r.ScheduledUserMessageParams,\n            a = null,\n            o = me.parse(arguments, [new me({\n          type: s,\n          constraint: function constraint(e) {\n            return \"string\" == typeof e.message && \"string\" == typeof e._getScheduleString();\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            l = C(o, 3);\n        return a = l[0], e = l[1], t = l[2], oe(this._iid, function (t) {\n          a ? t(a, null) : U.get(n._iid).container.apiClient.registerScheduledUserMessage({\n            groupChannelParams: e,\n            channelUrl: n.url,\n            isOpenChannel: !1\n          }, function (e, r) {\n            var s = null;\n\n            if (!e) {\n              s = new i(r);\n              var a = ji.getInstance(n._iid).currentUser;\n              a && s._sender && a.userId === s._sender.userId && (a.nickname = s._sender.nickname, a.plainProfileUrl = s._sender.plainProfileUrl, a.metaData = s._sender.metaData);\n            }\n\n            t(e, s);\n          });\n        }, t);\n      }\n    }, {\n      key: \"getPushPreference\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.getMyPushTriggerOption({\n            channelUrl: t.url\n          }, function (n, r) {\n            var i = null;\n\n            if (!n) {\n              try {\n                i = r.enable;\n              } catch (e) {\n                i = !1;\n              }\n\n              t.isPushEnabled = i;\n            }\n\n            e && e(n, i);\n          });\n        }, e);\n      }\n    }, {\n      key: \"setPushPreference\",\n      value: function value(e, t) {\n        var n = this;\n        return oe(this._iid, function (t) {\n          var r = x.get(n._iid).GroupChannel;\n          U.get(n._iid).container.apiClient.setMyPushTriggerOption({\n            channelUrl: n.url,\n            enable: e\n          }, function (e, i) {\n            e || (n.isPushEnabled = i.enable, n.isPushEnabled || (n.myPushTriggerOption = r.PushTriggerOption.OFF)), t(e, i);\n          });\n        }, t);\n      }\n    }, {\n      key: \"getMyPushTriggerOption\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.getMyPushTriggerOption({\n            channelUrl: t.url\n          }, function (r, i) {\n            var s = null;\n\n            if (!r) {\n              try {\n                s = i.push_trigger_option || n.PushTriggerOption.DEFAULT;\n              } catch (e) {\n                J.debug(e);\n              }\n\n              t.myPushTriggerOption = s;\n            }\n\n            e(r, s);\n          });\n        }, e);\n      }\n    }, {\n      key: \"setMyPushTriggerOption\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.GroupChannel,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: i.PushTriggerOption\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 3);\n        return s = o[0], e = o[1], t = o[2], oe(this._iid, function (t) {\n          s ? t(s, null) : U.get(n._iid).container.apiClient.setMyPushTriggerOption({\n            channelUrl: n.url,\n            pushTriggerOption: e\n          }, function (e, r) {\n            var i = null;\n\n            if (!e) {\n              try {\n                i = r.push_trigger_option;\n              } catch (e) {\n                J.debug(e);\n              }\n\n              n.myPushTriggerOption = i;\n            }\n\n            t(e, i);\n          });\n        }, t);\n      }\n    }, {\n      key: \"setMyCountPreference\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.GroupChannel,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: i.CountPreference\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 3);\n        return s = o[0], e = o[1], t = o[2], oe(this._iid, function (t) {\n          s ? t(s, null) : U.get(n._iid).container.apiClient.setMyCountPreference({\n            channelUrl: n.url,\n            countPreference: e\n          }, function (e, r) {\n            var s = null;\n            e || (s = n.myCountPreference = r.count_preference, n._setGroupChannelUnreadCount(n.unreadMessageCount, n.unreadMentionCount), i.cachedChannels[n.url] = n), t(e, s);\n          });\n        }, t);\n      }\n    }, {\n      key: \"resetMyHistory\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.resetMyHistory({\n            channelUrl: t.url\n          }, function (n, r) {\n            if (!n && r.hasOwnProperty(\"ts_message_offset\")) {\n              var i = x.get(t._iid).GroupChannel;\n              t._messageOffsetTimestamp = r.ts_message_offset, i.cachedChannels[t.url] = t;\n            }\n\n            e(n, r);\n          });\n        }, e);\n      }\n    }], [{\n      key: \"MemberStateFilter\",\n      get: function get() {\n        return {\n          ALL: \"all\",\n          JOINED: \"joined_only\",\n          INVITED: \"invited_only\",\n          INVITED_BY_FRIEND: \"invited_by_friend\",\n          INVITED_BY_NON_FRIEND: \"invited_by_non_friend\",\n          LEFT: \"left\"\n        };\n      }\n    }, {\n      key: \"PushTriggerOption\",\n      get: function get() {\n        return {\n          DEFAULT: \"default\",\n          ALL: \"all\",\n          MENTION_ONLY: \"mention_only\",\n          OFF: \"off\"\n        };\n      }\n    }, {\n      key: \"CountPreference\",\n      get: function get() {\n        return {\n          ALL: \"all\",\n          UNREAD_MESSAGE_COUNT_ONLY: \"unread_message_count_only\",\n          UNREAD_MENTION_COUNT_ONLY: \"unread_mention_count_only\",\n          OFF: \"off\"\n        };\n      }\n    }, {\n      key: \"HiddenState\",\n      get: function get() {\n        return {\n          UNHIDDEN: \"unhidden\",\n          HIDDEN_ALLOW_AUTO_UNHIDE: \"hidden_allow_auto_unhide\",\n          HIDDEN_PREVENT_AUTO_UNHIDE: \"hidden_prevent_auto_unhide\"\n        };\n      }\n    }, {\n      key: \"PublicChannelFilter\",\n      get: function get() {\n        return {\n          ALL: \"all\",\n          PUBLIC: \"public\",\n          PRIVATE: \"private\"\n        };\n      }\n    }, {\n      key: \"SuperChannelFilter\",\n      get: function get() {\n        return {\n          ALL: \"all\",\n          SUPER: \"super\",\n          NON_SUPER: \"nonsuper\",\n          BROADCAST_ONLY: \"broadcast_only\"\n        };\n      }\n    }, {\n      key: \"UnreadChannelFilter\",\n      get: function get() {\n        return {\n          ALL: \"all\",\n          UNREAD_MESSAGE: \"unread_message\"\n        };\n      }\n    }, {\n      key: \"HiddenChannelFilter\",\n      get: function get() {\n        return {\n          ALL: \"all\",\n          UNHIDDEN: \"unhidden_only\",\n          HIDDEN: \"hidden_only\",\n          HIDDEN_ALLOW_AUTO_UNHIDE: \"hidden_allow_auto_unhide\",\n          HIDDEN_PREVENT_AUTO_UNHIDE: \"hidden_prevent_auto_unhide\"\n        };\n      }\n    }, {\n      key: \"Role\",\n      get: function get() {\n        return {\n          OPERATOR: \"operator\",\n          NONE: \"none\"\n        };\n      }\n    }, {\n      key: \"UnreadItemKey\",\n      get: function get() {\n        return {\n          GROUP_CHANNEL_UNREAD_MENTION_COUNT: \"group_channel_unread_mention_count\",\n          NONSUPER_UNREAD_MENTION_COUNT: \"non_super_group_channel_unread_mention_count\",\n          SUPER_UNREAD_MENTION_COUNT: \"super_group_channel_unread_mention_count\",\n          GROUP_CHANNEL_UNREAD_MESSAGE_COUNT: \"group_channel_unread_message_count\",\n          NONSUPER_UNREAD_MESSAGE_COUNT: \"non_super_group_channel_unread_message_count\",\n          SUPER_UNREAD_MESSAGE_COUNT: \"super_group_channel_unread_message_count\",\n          GROUP_CHANNEL_INVITATION_COUNT: \"group_channel_invitation_count\",\n          NONSUPER_INVITATION_COUNT: \"non_super_group_channel_invitation_count\",\n          SUPER_INVITATION_COUNT: \"super_group_channel_invitation_count\"\n        };\n      }\n    }, {\n      key: \"cachedChannels\",\n      get: function get() {\n        return tr[this._iid] || (tr[this._iid] = {}), tr[this._iid];\n      }\n    }, {\n      key: \"createGroupChannelCollection\",\n      value: function value() {\n        return new $n({\n          iid: this._iid\n        });\n      }\n    }, {\n      key: \"buildFromSerializedData\",\n      value: function value(e) {\n        var t = x.get(this._iid),\n            n = t.User,\n            r = t.Member,\n            i = t.GroupChannel,\n            s = t.BaseMessage,\n            a = t.UserMessage,\n            o = t.FileMessage,\n            c = t.AdminMessage,\n            d = Nt.deserialize(e),\n            h = function (e) {\n          return null != e && \"object\" === u(e) ? e.messageType === s.MESSAGE_TYPE_USER ? new a(a.objectify(l(l({}, e), {}, {\n            channel: {\n              url: e.channelUrl,\n              channelType: e.channelType\n            },\n            user: e.sender,\n            mentionedUsers: e.mentionedUsers\n          }))) : e.messageType === s.MESSAGE_TYPE_FILE ? new o(o.objectify(l(l({}, e), {}, {\n            channel: {\n              url: e.channelUrl,\n              channelType: e.channelType\n            },\n            user: e.sender,\n            mentionedUsers: e.mentionedUsers\n          }))) : new c(c.objectify(l(l({}, e), {}, {\n            channel: {\n              url: e.channelUrl,\n              channelType: e.channelType\n            },\n            mentionedUsers: e.mentionedUsers\n          }))) : null;\n        }(d.lastMessage);\n\n        return new i({\n          channel_url: d.url,\n          name: d.name,\n          cover_url: d.coverUrl,\n          data: d.data,\n          custom_type: d.customType,\n          invited_at: d.invitedAt,\n          created_at: d.createdAt / 1e3,\n          joined_ts: d.joinedAt,\n          is_access_code_required: d.isAccessCodeRequired,\n          is_distinct: d.isDistinct,\n          is_super: d.isSuper,\n          is_broadcast: d.isBroadcast,\n          is_public: d.isPublic,\n          is_discoverable: d.isDiscoverable,\n          is_hidden: d.isHidden,\n          is_ephemeral: d.isEphemeral,\n          is_muted: d.myMutedState,\n          is_push_enabled: d.isPushEnabled,\n          freeze: d.isFrozen,\n          unread_message_count: d.unreadMessageCount,\n          unread_mention_count: d.unreadMentionCount,\n          push_trigger_option: d.myPushTriggerOption,\n          count_preference: d.myCountPreference,\n          hidden_state: d.hiddenState,\n          member_count: d.memberCount,\n          joined_member_count: d.joinedMemberCount,\n          member_state: d.myMemberState,\n          my_role: d.myRole,\n          user_last_read: d.myLastRead,\n          ts_message_offset: d.messageOffsetTimestamp,\n          message_survival_seconds: d.messageSurvivalSeconds,\n          read_receipt: d.cachedReadReceiptStatus,\n          delivery_receipt: d.cachedDeliveryReceiptStatus,\n          members: d.members.map(function (e) {\n            return r.objectify(l({}, e));\n          }),\n          last_message: h,\n          created_by: null !== d.creator && void 0 !== d.creator && \"object\" === u(d.creator) ? n.objectify(d.creator) : null,\n          inviter: null !== d.inviter && void 0 !== d.inviter && \"object\" === u(d.inviter) ? n.objectify(d.inviter) : null,\n          metadata: d.metadata,\n          cached_primary_key: d.cachedPrimaryKey\n        });\n      }\n    }, {\n      key: \"upsert\",\n      value: function value(e) {\n        var t = x.get(this._iid).GroupChannel,\n            n = new t(e);\n\n        if (t.cachedChannels.hasOwnProperty(n.url)) {\n          if (n.isEphemeral) {\n            var r = t.cachedChannels[n.url];\n            e.last_message = r.lastMessage, e.unread_message_count = r.unreadMessageCount;\n          }\n\n          t.cachedChannels[n.url].update(e);\n        } else t.cachedChannels[n.url] = n;\n\n        return t.cachedChannels[n.url];\n      }\n    }, {\n      key: \"removeCachedChannel\",\n      value: function value(e) {\n        var t = x.get(this._iid),\n            n = t.GroupChannel,\n            r = t.FileMessageQueue;\n        n.cachedChannels[e] && delete n.cachedChannels[e], r.delete(e);\n      }\n    }, {\n      key: \"clearCache\",\n      value: function value() {\n        tr[this._iid] = {}, x.get(this._iid).FileMessageQueue.clear();\n      }\n    }, {\n      key: \"getChannel\",\n      value: function value(e, t) {\n        var n = null,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"string\",\n          optional: !0,\n          nullable: !0,\n          defaultValue: null\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 4);\n        if (n = s[0], e = s[1], r = s[2], t = s[3], n) return oe(this._iid, function (e) {\n          e(n, null);\n        }, t);\n        var a = x.get(this._iid),\n            o = a.GroupChannel;\n        return o.cachedChannels[e] ? oe(this._iid, function (t) {\n          t(null, o.cachedChannels[e]);\n        }, t) : o.getChannelWithoutCache(e, r, t);\n      }\n    }, {\n      key: \"getChannelWithoutCache\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"string\",\n          optional: !0,\n          nullable: !0,\n          defaultValue: null\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return r = a[0], e = a[1], i = a[2], t = a[3], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.getGroupChannel({\n            channelUrl: e,\n            internalCall: i,\n            showMember: !0\n          }, function (e, r) {\n            var i = null;\n            e || (i = n.upsert(r)), t(e, i);\n          });\n        }, t);\n      }\n    }, {\n      key: \"createDistinctChannelIfNotExist\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.GroupChannelParams,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: i,\n          constraint: function constraint(e) {\n            return e._validate();\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 3);\n        return s = o[0], e = o[1], t = o[2], oe(this._iid, function (t) {\n          s ? t(s, null) : (e.isPublic || (e.accessCode = null), U.get(n._iid).container.apiClient.createGroupChannel(l(l({}, e), {}, {\n            isDistinct: !0\n          }), function (e, r) {\n            var i = null;\n\n            if (!e) {\n              var s = x.get(n._iid).GroupChannel;\n              i = {\n                channel: new s(r),\n                isCreated: r.is_created\n              }, s.cachedChannels[i.channel.url] = i.channel;\n            }\n\n            t(e, i);\n          }));\n        }, t);\n      }\n    }, {\n      key: \"createChannel\",\n      value: function value() {\n        var e = this,\n            t = me.toArray(arguments),\n            n = void 0;\n        \"function\" == typeof t[t.length - 1] && (n = t.pop());\n        var r = x.get(this._iid),\n            i = r.GroupChannel,\n            s = r.GroupChannelParams;\n        if (t[0] instanceof s && 1 === t.length) return oe(this._iid, function (n) {\n          var r = t[0];\n          (r.isPublic || (r.accessCode = null), r._validate()) ? U.get(e._iid).container.apiClient.createGroupChannel(r, function (e, t) {\n            var r = null;\n            e || (r = new i(t), i.cachedChannels[r.url] = r), n(e, r);\n          }) : n(me.error, null);\n        }, n);\n\n        if (Array.isArray(t[0])) {\n          var a = new s();\n\n          switch (t.length) {\n            case 1:\n              a.addUsers(t[0]);\n              break;\n\n            case 2:\n              a.addUsers(t[0]), a.isDistinct = t[1];\n              break;\n\n            case 3:\n              a.addUsers(t[0]), a.isDistinct = t[1], a.customType = t[2];\n              break;\n\n            case 5:\n              a.addUsers(t[0]), a.isDistinct = t[1], a.name = t[2], \"string\" == typeof t[3] ? a.coverUrl = t[3] : a.coverImage = t[3], a.data = t[4];\n              break;\n\n            case 6:\n              a.addUsers(t[0]), a.isDistinct = t[1], a.name = t[2], \"string\" == typeof t[3] ? a.coverUrl = t[3] : a.coverImage = t[3], a.data = t[4], a.customType = t[5];\n              break;\n\n            default:\n              return oe(this._iid, function (e) {\n                return e(me.error, null);\n              }, n);\n          }\n\n          return n ? i.createChannel(a, n) : i.createChannel(a);\n        }\n\n        return oe(this._iid, function (e) {\n          return e(me.error, null);\n        }, n);\n      }\n    }, {\n      key: \"createChannelWithUserIds\",\n      value: function value() {\n        var e = me.toArray(arguments),\n            t = void 0;\n        \"function\" == typeof e[e.length - 1] && (t = e.pop());\n        var n = x.get(this._iid),\n            r = n.GroupChannel,\n            i = n.GroupChannelParams,\n            s = new i();\n\n        switch (e.length) {\n          case 1:\n            s.addUserIds(e[0]);\n            break;\n\n          case 2:\n            s.addUserIds(e[0]), s.isDistinct = e[1];\n            break;\n\n          case 3:\n            s.addUserIds(e[0]), s.isDistinct = e[1], s.customType = e[2];\n            break;\n\n          case 5:\n            s.addUserIds(e[0]), s.isDistinct = e[1], s.name = e[2], \"string\" == typeof e[3] ? s.coverUrl = e[3] : s.coverImage = e[3], s.data = e[4];\n            break;\n\n          case 6:\n            s.addUserIds(e[0]), s.isDistinct = e[1], s.name = e[2], \"string\" == typeof e[3] ? s.coverUrl = e[3] : s.coverImage = e[3], s.data = e[4], s.customType = e[5];\n            break;\n\n          default:\n            return oe(this._iid, function (e) {\n              return e(me.error, null);\n            }, t);\n        }\n\n        return t ? r.createChannel(s, t) : r.createChannel(s);\n      }\n    }, {\n      key: \"createMyGroupChannelListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).GroupChannelListQuery)();\n      }\n    }, {\n      key: \"createPublicGroupChannelListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).PublicGroupChannelListQuery)();\n      }\n    }, {\n      key: \"markAsReadAllLastSentAt\",\n      get: function get() {\n        return nr[this._iid] || 0;\n      },\n      set: function set(e) {\n        nr[this._iid] = e;\n      }\n    }, {\n      key: \"getChannelCount\",\n      value: function value(e, t) {\n        return ji.getInstance(this._iid).getGroupChannelCount(e, t);\n      }\n    }, {\n      key: \"getUnreadItemCount\",\n      value: function value(e, t) {\n        return ji.getInstance(this._iid).getUnreadItemCount(e, t);\n      }\n    }, {\n      key: \"getTotalUnreadMessageCount\",\n      value: function value() {\n        var e = me.toArray(arguments),\n            t = \"function\" == typeof e[e.length - 1] ? e.pop() : null,\n            n = ji.getInstance(this._iid);\n        return n.getTotalUnreadMessageCount.apply(n, A(e).concat([t]));\n      }\n    }, {\n      key: \"getTotalUnreadChannelCount\",\n      value: function value(e) {\n        return ji.getInstance(this._iid).getTotalUnreadChannelCount(e);\n      }\n    }]), n;\n  }(Rt),\n      or = function (e) {\n    function t(t) {\n      var n = e.call(this, t) || this;\n      return n.state = \"\", n.role = \"\", n.isMuted = !1, n.isBlockedByMe = !1, n.isBlockingMe = !1, n.restrictionInfo = null, t && n._update(t), n;\n    }\n\n    return k(t, e), t.objectify = function (e) {\n      var t = x.get(this._iid),\n          n = t.User,\n          r = t.RestrictedUser,\n          i = t.RestrictionInfo,\n          s = e.state,\n          a = e.role,\n          o = void 0 === a ? \"\" : a,\n          l = e.isMuted,\n          u = void 0 !== l && l,\n          c = e.isBlockedByMe,\n          d = void 0 !== c && c,\n          h = e.isBlockingMe,\n          p = void 0 !== h && h,\n          f = e.restrictionInfo,\n          _ = void 0 === f ? null : f,\n          g = u ? r.objectify(e) : n.objectify(e);\n\n      if (g.state = s, g.role = o, g.is_muted = u, g.is_blocked_by_me = d, g.is_blocking_me = p, _) {\n        var y = i.objectify(_);\n        g.restriction_type = y.restriction_type, g.muted_description = y.description, g.muted_end_at = y.end_at;\n      }\n\n      return g;\n    }, t.buildFromSerializedData = function (e) {\n      var t = x.get(this._iid).Member,\n          n = Nt.deserialize(e);\n      return new t(t.objectify(_R({}, n)));\n    }, t.prototype._update = function (e) {\n      var t = x.get(this._iid),\n          n = t.RestrictedUser,\n          r = t.RestrictionInfo;\n      this.state = e.state, this.role = e.role || ar.Role.NONE, e.hasOwnProperty(\"is_muted\") && (this.isMuted = e.is_muted), e.hasOwnProperty(\"is_blocked_by_me\") && (this.isBlockedByMe = e.is_blocked_by_me), e.hasOwnProperty(\"is_blocking_me\") && (this.isBlockingMe = e.is_blocking_me), this.isMuted && (this.restrictionInfo = new r(e), this.restrictionInfo.restrictionType = n.RestrictionType.MUTED);\n    }, t.prototype.parse = function (e) {\n      this._update(e);\n    }, Object.defineProperty(t, \"JOINED\", {\n      get: function get() {\n        return \"joined\";\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"INVITED\", {\n      get: function get() {\n        return \"invited\";\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"LEFT\", {\n      get: function get() {\n        return \"left\";\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(Ot),\n      lr = function (e) {\n    function t(t) {\n      var n = e.call(this, t) || this;\n      return n.role = \"\", n.isBlockedByMe = !1, t && n._update(t), n;\n    }\n\n    return k(t, e), t.objectify = function (e) {\n      var t = x.get(this._iid).User,\n          n = e.role,\n          r = void 0 === n ? \"\" : n,\n          i = e.isBlockedByMe,\n          s = void 0 !== i && i,\n          a = t.objectify(e);\n      return a.role = r, a.is_blocked_by_me = s, a;\n    }, t.buildFromSerializedData = function (e) {\n      var t = x.get(this._iid).Sender,\n          n = Nt.deserialize(e);\n      return new t(t.objectify(_R({}, n)));\n    }, t.prototype.parse = function (e) {\n      this._update(e);\n    }, t.prototype._update = function (e) {\n      this.role = e.role || ar.Role.NONE, e.hasOwnProperty(\"is_blocked_by_me\") && (this.isBlockedByMe = e.is_blocked_by_me);\n    }, t;\n  }(Ot),\n      ur = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n(e) {\n      var r;\n      return c(this, n), (r = t.call(this, e)).restrictionInfo = null, e && r._update(e), r;\n    }\n\n    return h(n, [{\n      key: \"_update\",\n      value: function value(e) {\n        var t = x.get(this._iid).RestrictionInfo;\n        this.restrictionInfo = new t(e);\n      }\n    }], [{\n      key: \"RestrictionType\",\n      get: function get() {\n        return {\n          MUTED: \"muted\",\n          BANNED: \"banned\"\n        };\n      }\n    }, {\n      key: \"objectify\",\n      value: function value(e) {\n        var t = x.get(this._iid),\n            n = t.User,\n            r = t.RestrictionInfo,\n            i = e.restrictionInfo,\n            s = void 0 === i ? {} : i;\n        return l(l({}, n.objectify(e)), r.objectify(s));\n      }\n    }]), n;\n  }(Ot),\n      cr = function () {\n    function e(e) {\n      this.emojiHash = null, this.emojiCategories = null, e && this._update(e);\n    }\n\n    return e.prototype._update = function (e) {\n      var t = x.get(this._iid).EmojiCategory;\n      this.emojiHash = e.emoji_hash || \"\", this.emojiCategories = e.emoji_categories ? e.emoji_categories.map(function (e) {\n        return new t(e);\n      }) : [];\n    }, e;\n  }(),\n      dr = function () {\n    function e(e) {\n      this.id = null, this.name = null, this.url = null, this.emojis = null, e && this._update(e);\n    }\n\n    return e.prototype._update = function (e) {\n      var t = x.get(this._iid).Emoji;\n      this.id = e.id || 0, this.name = e.name || \"\", this.url = e.url || \"\", this.emojis = e.emojis ? e.emojis.map(function (e) {\n        return new t(e);\n      }) : [];\n    }, e;\n  }(),\n      hr = function () {\n    function e(e) {\n      this.key = null, this.url = null, e && this._update(e);\n    }\n\n    return e.prototype._update = function (e) {\n      this.key = e.key, this.url = e.url;\n    }, e;\n  }(),\n      pr = {},\n      fr = {},\n      _r = new WeakMap(),\n      gr = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n(e) {\n      var r;\n      return c(this, n), (r = t.call(this, e)).channelType = Rt.CHANNEL_TYPE_OPEN, r.participantCount = 0, _r.set(y(r), 0), r.operators = [], e && r._update(e), r;\n    }\n\n    return h(n, [{\n      key: \"_update\",\n      value: function value(e) {\n        var t = x.get(this._iid).User;\n        e.hasOwnProperty(\"participant_count\") && (this.participantCount = parseInt(e.participant_count)), e.hasOwnProperty(\"operators\") && Array.isArray(e.operators) && (this.operators = e.operators.map(function (e) {\n          return new t(e);\n        }));\n      }\n    }, {\n      key: \"parse\",\n      value: function value(e) {\n        this._update(e);\n      }\n    }, {\n      key: \"update\",\n      value: function value(e) {\n        this.__update(e), this._update(e);\n      }\n    }, {\n      key: \"createParticipantListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).ParticipantListQuery)({\n          channelUrl: this.url\n        });\n      }\n    }, {\n      key: \"createMutedUserListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).MutedUserListQuery)({\n          channelUrl: this.url,\n          isOpenChannel: !0\n        });\n      }\n    }, {\n      key: \"createBannedUserListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).BannedUserListQuery)({\n          channelUrl: this.url,\n          isOpenChannel: !0\n        });\n      }\n    }, {\n      key: \"isOperator\",\n      value: function value(e) {\n        return !!e && this.isOperatorWithUserId(e.userId);\n      }\n    }, {\n      key: \"isOperatorWithUserId\",\n      value: function value(e) {\n        return this.operators.map(function (e) {\n          return e.userId;\n        }).indexOf(e) > -1;\n      }\n    }, {\n      key: \"refresh\",\n      value: function value(e) {\n        return x.get(this._iid).OpenChannel.getChannelWithoutCache(this.url, e);\n      }\n    }, {\n      key: \"enter\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          var n = x.get(t._iid).Command.bEnter({\n            channelUrl: t.url\n          }),\n              r = ji.getInstance(t._iid);\n          r.sendCommand(n, function (n, i) {\n            if (r.getErrorFirstCallback()) {\n              var s = [n, i];\n              i = s[0], n = s[1];\n            }\n\n            i ? (i = i ? new H(i.message, i.code) : null, e(i, null)) : (x.get(t._iid).OpenChannel.enteredChannels[t.url] = t, ge.of(t._iid).send({\n              source: de.EVENT_CHANNEL_ENTER,\n              payload: {\n                channel: t\n              }\n            }), t.refresh(function () {\n              return e(null, null);\n            }));\n          });\n        }, e);\n      }\n    }, {\n      key: \"exit\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          var n = x.get(t._iid),\n              r = n.Command,\n              i = n.FileMessageQueue,\n              s = r.bExit({\n            channelUrl: t.url\n          }),\n              a = ji.getInstance(t._iid);\n          a.sendCommand(s, function (n, r) {\n            if (a.getErrorFirstCallback()) {\n              var s = [n, r];\n              r = s[0], n = s[1];\n            }\n\n            r ? (r = r ? new H(r.message, r.code) : null, e(r, null)) : (delete x.get(t._iid).OpenChannel.enteredChannels[t.url], i.delete(t.url), ge.of(t._iid).send({\n              source: de.EVENT_CHANNEL_EXIT,\n              payload: {\n                channel: t\n              }\n            }), e(null, null));\n          });\n        }, e);\n      }\n    }, {\n      key: \"updateChannel\",\n      value: function value() {\n        var e = this,\n            t = me.toArray(arguments),\n            n = null;\n        \"function\" == typeof t[t.length - 1] && (n = t.pop());\n        var r = x.get(this._iid),\n            i = r.OpenChannel,\n            s = r.OpenChannelParams;\n        if (t[0] instanceof s && 1 === t.length) return oe(this._iid, function (n) {\n          var r = t[0];\n          (r.channelUrl = e.url, r._validate()) ? U.get(e._iid).container.apiClient.updateOpenChannel(r, function (e, t) {\n            var r = null;\n            e || (r = i.upsert(t)), n(e, r);\n          }) : n(me.error, null);\n        }, n);\n\n        if (3 === t.length) {\n          var a = new s();\n          return a.channelUrl = this.url, a.name = t[0], a.coverUrlOrImage = t[1], a.data = t[2], a.operatorUserIds = this.operators.map(function (e) {\n            return e.userId;\n          }), n ? this.updateChannel(a, n) : this.updateChannel(a);\n        }\n\n        if (4 === t.length) {\n          var o = new s();\n          return o.channelUrl = this.url, o.name = t[0], o.coverUrlOrImage = t[1], o.data = t[2], Array.isArray(t[3]) && (o.operatorUserIds = t[3]), n ? this.updateChannel(o, n) : this.updateChannel(o);\n        }\n\n        if (5 === t.length) {\n          var l = new s();\n          return l.channelUrl = this.url, l.name = t[0], l.coverUrlOrImage = t[1], l.data = t[2], Array.isArray(t[3]) && (l.operatorUserIds = t[3]), l.customType = t[4], n ? this.updateChannel(l, n) : this.updateChannel(l);\n        }\n\n        return oe(this._iid, function (e) {\n          return e(me.error, null);\n        }, n);\n      }\n    }, {\n      key: \"updateChannelWithOperatorUserIds\",\n      value: function value() {\n        var e = me.toArray(arguments),\n            t = void 0;\n\n        switch (\"function\" == typeof e[e.length - 1] && (t = e.pop()), e.length) {\n          case 4:\n          case 5:\n            return t ? this.updateChannel(params, t) : this.updateChannel(params);\n\n          default:\n            return oe(this._iid, function (e) {\n              return e(me.error, null);\n            }, t);\n        }\n      }\n    }, {\n      key: \"muteUser\",\n      value: function value(e, t, n, r) {\n        return this.muteUserWithUserId(e ? e.userId : null, t, n, r);\n      }\n    }, {\n      key: \"muteUserWithUserId\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"number\",\n          optional: !0,\n          defaultValue: -1,\n          constraint: function constraint(e) {\n            return e >= -1;\n          }\n        }), new me({\n          type: \"string\",\n          optional: !0,\n          defaultValue: \"\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 5);\n        return s = o[0], e = o[1], t = o[2], n = o[3], r = o[4], oe(this._iid, function (r) {\n          s ? r(s, null) : U.get(i._iid).container.apiClient.muteUser({\n            channelUrl: i.url,\n            userId: e,\n            description: n,\n            seconds: t,\n            isGroupChannel: !1\n          }, function (e, t) {\n            r(e, null);\n          });\n        }, r);\n      }\n    }, {\n      key: \"unmuteUser\",\n      value: function value(e, t) {\n        return this.unmuteUserWithUserId(e ? e.userId : null, t);\n      }\n    }, {\n      key: \"unmuteUserWithUserId\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.unmuteUser({\n            channelUrl: n.url,\n            userId: e,\n            isGroupChannel: !1\n          }, function (e, n) {\n            t(e, null);\n          });\n        }, t);\n      }\n    }, {\n      key: \"banUser\",\n      value: function value(e, t, n) {\n        return this.banUserWithUserId(e ? e.userId : null, t, n);\n      }\n    }, {\n      key: \"banUserWithUserId\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"number\",\n          optional: !0,\n          defaultValue: -1,\n          constraint: function constraint(e) {\n            return e >= -1;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return i = a[0], e = a[1], t = a[2], n = a[3], oe(this._iid, function (n) {\n          i ? n(i, null) : U.get(r._iid).container.apiClient.banUser({\n            channelUrl: r.url,\n            userId: e,\n            description: null,\n            seconds: t,\n            isGroupChannel: !1\n          }, function (e, t) {\n            n(e, null);\n          });\n        }, n);\n      }\n    }, {\n      key: \"unbanUser\",\n      value: function value(e, t) {\n        return this.unbanUserWithUserId(e ? e.userId : null, t);\n      }\n    }, {\n      key: \"unbanUserWithUserId\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.unbanUser({\n            channelUrl: n.url,\n            userId: e,\n            isGroupChannel: !1\n          }, function (e, n) {\n            t(e, null);\n          });\n        }, t);\n      }\n    }, {\n      key: \"setLatestParticipantCount\",\n      value: function value(e, t) {\n        var n = !1;\n        return \"number\" == typeof e && \"number\" == typeof t && t >= _r.get(this) && (_r.set(this, t), n = e !== this.participantCount, this.participantCount = e), n;\n      }\n    }, {\n      key: \"delete\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.deleteOpenChannel({\n            channelUrl: t.url\n          }, function (n, r) {\n            n || (delete x.get(t._iid).OpenChannel.cachedChannels[t.url], x.get(t._iid).FileMessageQueue.delete(t.url));\n            e(n, r);\n          });\n        }, e);\n      }\n    }], [{\n      key: \"cachedChannels\",\n      get: function get() {\n        return pr[this._iid] || (pr[this._iid] = {}), pr[this._iid];\n      }\n    }, {\n      key: \"enteredChannels\",\n      get: function get() {\n        return fr[this._iid] || (fr[this._iid] = {}), fr[this._iid];\n      }\n    }, {\n      key: \"buildFromSerializedData\",\n      value: function value(e) {\n        var t = x.get(this._iid),\n            n = t.User,\n            r = t.OpenChannel,\n            i = Nt.deserialize(e);\n        return new r({\n          channel_url: i.url,\n          name: i.name,\n          cover_url: i.coverUrl,\n          data: i.data,\n          custom_type: i.customType,\n          created_at: i.createdAt / 1e3,\n          freeze: i.isFrozen,\n          is_ephemeral: i.isEphemeral,\n          participant_count: i.participantCount,\n          operators: i.operators.map(function (e) {\n            return n.objectify(e);\n          })\n        });\n      }\n    }, {\n      key: \"getChannel\",\n      value: function value(e, t) {\n        var n = null,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"string\",\n          optional: !0,\n          nullable: !0,\n          defaultValue: null\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 4);\n        if (n = s[0], e = s[1], r = s[2], t = s[3], n) return oe(this._iid, function (e) {\n          e(n, null);\n        }, t);\n        var a = x.get(this._iid),\n            o = a.OpenChannel;\n        return o.cachedChannels[e] ? oe(this._iid, function (t) {\n          t(null, o.cachedChannels[e]);\n        }, t) : o.getChannelWithoutCache(e, r, t);\n      }\n    }, {\n      key: \"getChannelWithoutCache\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"string\",\n          optional: !0,\n          nullable: !0,\n          defaultValue: null\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return r = a[0], e = a[1], i = a[2], t = a[3], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.getOpenChannel({\n            channelUrl: e,\n            internalCall: i\n          }, function (e, r) {\n            var i = null;\n            e || (i = x.get(n._iid).OpenChannel.upsert(r));\n            t(e, i);\n          });\n        }, t);\n      }\n    }, {\n      key: \"createChannel\",\n      value: function value() {\n        var e = this,\n            t = me.toArray(arguments),\n            n = null;\n        \"function\" == typeof t[t.length - 1] && (n = t.pop());\n        var r = x.get(this._iid),\n            i = r.OpenChannel,\n            s = r.OpenChannelParams;\n        if (t[0] instanceof s && 1 === t.length) return oe(this._iid, function (n) {\n          var r = t[0];\n          r._validate() ? U.get(e._iid).container.apiClient.createOpenChannel(r, function (t, r) {\n            var i = null;\n            t || (i = x.get(e._iid).OpenChannel.upsert(r));\n            n(t, i);\n          }) : n(me.error, null);\n        }, n);\n        var a = new s();\n\n        switch (t.length) {\n          case 0:\n            break;\n\n          case 1:\n            a.name = t[0];\n            break;\n\n          case 2:\n            a.name = t[0], a.coverUrlOrImage = t[1];\n            break;\n\n          case 3:\n            a.name = t[0], a.coverUrlOrImage = t[1], a.data = t[2];\n            break;\n\n          case 4:\n            a.name = t[0], a.coverUrlOrImage = t[1], a.data = t[2], a.operatorUserIds = t[3];\n            break;\n\n          case 5:\n            a.name = t[0], a.coverUrlOrImage = t[1], a.data = t[2], a.operatorUserIds = t[3], a.customType = t[4];\n            break;\n\n          default:\n            return oe(this._iid, function (e) {\n              return e(me.error, null);\n            }, n);\n        }\n\n        return n ? i.createChannel(a, n) : i.createChannel(a);\n      }\n    }, {\n      key: \"createChannelWithOperatorUserIds\",\n      value: function value() {\n        var e = me.toArray(arguments),\n            t = void 0;\n\n        switch (\"function\" == typeof e[e.length - 1] && (t = e.pop()), e.length) {\n          case 4:\n          case 5:\n            return t ? this.createChannel.apply(this, A(e).concat([t])) : this.createChannel.apply(this, A(e));\n\n          default:\n            return oe(this._iid, function (e) {\n              return e(me.error, null);\n            }, t);\n        }\n      }\n    }, {\n      key: \"upsert\",\n      value: function value(e) {\n        var t = new (0, x.get(this._iid).OpenChannel)(e);\n        return this.cachedChannels.hasOwnProperty(t.url) ? this.cachedChannels[t.url].update(e) : this.cachedChannels[t.url] = t, this.cachedChannels[t.url];\n      }\n    }, {\n      key: \"removeCachedChannel\",\n      value: function value(e) {\n        this.cachedChannels[e] && delete this.cachedChannels[e], x.get(this._iid).FileMessageQueue.delete(e);\n      }\n    }, {\n      key: \"clearCache\",\n      value: function value() {\n        pr[this._iid] = {}, x.get(this._iid).FileMessageQueue.clear();\n      }\n    }, {\n      key: \"clearEnteredChannels\",\n      value: function value() {\n        fr[this._iid] = {};\n      }\n    }, {\n      key: \"createOpenChannelListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).OpenChannelListQuery)();\n      }\n    }]), n;\n  }(Rt),\n      yr = \"default\",\n      mr = function () {\n    function e(e) {\n      this.name = yr, this.volume = 1, e && this._update(e);\n    }\n\n    return e.prototype._update = function (e) {\n      e.hasOwnProperty(\"name\") && (this.name = e.name), e.hasOwnProperty(\"volume\") && (this.volume = e.volume);\n    }, e.objectify = function (e) {\n      var t = e.name,\n          n = void 0 === t ? yr : t,\n          r = e.volume;\n      return {\n        name: n,\n        volume: void 0 === r ? 1 : r\n      };\n    }, e.prototype.serialize = function () {\n      return Nt.serialize(this);\n    }, e;\n  }(),\n      Er = function () {\n    function e(e, t) {\n      void 0 === t && (t = []), this.key = e, this.value = Array.isArray(t) && t.every(function (e) {\n        return \"string\" == typeof e;\n      }) ? t : [];\n    }\n\n    return e.prototype.encode = function () {\n      return {\n        key: this.key,\n        value: this.value || []\n      };\n    }, e;\n  }(),\n      vr = new WeakMap(),\n      br = function () {\n    function e(t) {\n      c(this, e), this._mentionType = e.MentionType.USERS, this._mentionedUserIds = [], this._cachedMentionedUsers = [], this._cachedMentionedUserIds = [], this._metaArrays = [], vr.set(this, null), this._parentMessageId = null, this._reqId = null, this.data = null, this.customType = null, this.pushNotificationDeliveryOption = null, this.appleCriticalAlertOptions = null, this.isReplyToChannel = !1, this.mentionedMessageTemplate = null, t && this._update(t);\n    }\n\n    return h(e, [{\n      key: \"mentionType\",\n      get: function get() {\n        return this._mentionType;\n      },\n      set: function set(e) {\n        var t = x.get(this._iid).BaseMessageParams;\n        Object.keys(t.MentionType).map(function (e) {\n          return t.MentionType[e];\n        }).indexOf(e) > -1 && (this._mentionType = e);\n      }\n    }, {\n      key: \"mentionedUserIds\",\n      get: function get() {\n        return this._cachedMentionedUserIds;\n      },\n      set: function set(e) {\n        if (Array.isArray(e)) {\n          if (0 === e.length) return this._cachedMentionedUserIds = [], void (this._mentionedUserIds = []);\n\n          for (var t = ji.getInstance(this._iid), n = 0; n < e.length; n++) {\n            var r = e[n];\n\n            if (\"string\" != typeof r) {\n              this._cachedMentionedUserIds = [], this._mentionedUserIds = [];\n              break;\n            }\n\n            this._mentionedUserIds.indexOf(r) < 0 && t.currentUser && t.currentUser.userId !== r && (this._cachedMentionedUserIds.push(r), this._mentionedUserIds.push(r));\n          }\n        }\n      }\n    }, {\n      key: \"mentionedUsers\",\n      get: function get() {\n        return this._cachedMentionedUsers;\n      },\n      set: function set(e) {\n        if (Array.isArray(e)) {\n          if (0 === e.length) return this._cachedMentionedUserIds = [], void (this._mentionedUserIds = []);\n\n          for (var t = ji.getInstance(this._iid), n = 0; n < e.length; n++) {\n            var r = e[n];\n\n            if (!r.hasOwnProperty(\"userId\")) {\n              this._cachedMentionedUsers = [], this._mentionedUserIds = [];\n              break;\n            }\n\n            this._mentionedUserIds.indexOf(r.userId) < 0 && t.currentUser && t.currentUser.userId !== r.userId && (this._cachedMentionedUsers.push(r), this._mentionedUserIds.push(r.userId));\n          }\n        }\n      }\n    }, {\n      key: \"metaArrayKeys\",\n      get: function get() {\n        return this._metaArrays.map(function (e) {\n          return e.key;\n        });\n      },\n      set: function set(e) {\n        var t = x.get(this._iid).MessageMetaArray,\n            n = {};\n\n        if (Array.isArray(e)) {\n          this._metaArrays = [];\n\n          for (var r = 0; r < e.length; r++) {\n            \"string\" != typeof e[r] || n[e[r]] || (n[e[r]] = !0, this._metaArrays.push(new t(e[r])));\n          }\n        }\n      }\n    }, {\n      key: \"metaArrays\",\n      get: function get() {\n        return this._metaArrays;\n      },\n      set: function set(e) {\n        var t = x.get(this._iid).MessageMetaArray;\n\n        if (Array.isArray(e)) {\n          this._metaArrays = [];\n\n          for (var n = 0; n < e.length; n++) {\n            var r = e[n];\n\n            if (r instanceof t) {\n              var i,\n                  s = this._metaArrays.map(function (e) {\n                return e.key;\n              }).indexOf(r.key);\n\n              if (s < 0) this._metaArrays.push(r);else (i = this._metaArrays[s].value).push.apply(i, A(r.value));\n            }\n          }\n        }\n      }\n    }, {\n      key: \"rootMessageId\",\n      get: function get() {\n        return vr.get(this);\n      }\n    }, {\n      key: \"parentMessageId\",\n      get: function get() {\n        return this._parentMessageId;\n      },\n      set: function set(e) {\n        vr.set(this, e), this._parentMessageId = e;\n      }\n    }, {\n      key: \"_serialize\",\n      value: function value(e) {\n        return Nt.serialize(this, function (t) {\n          t.hasOwnProperty(\"_mentionType\") && (t.mentionType = t._mentionType, delete t._mentionType), t.hasOwnProperty(\"_mentionedUserIds\") && (t.mentionedUserIds = t._mentionedUserIds, delete t._mentionedUserIds), t.hasOwnProperty(\"_cachedMentionedUsers\") && (t.cachedMentionedUsers = t._cachedMentionedUsers, delete t._cachedMentionedUsers), t.hasOwnProperty(\"_cachedMentionedUserIds\") && (t.cachedMentionedUserIds = t._cachedMentionedUserIds, delete t._cachedMentionedUserIds), t.hasOwnProperty(\"_metaArrays\") && (t.metaArrays = t._metaArrays, delete t._metaArrays), t.hasOwnProperty(\"_parentMessageId\") && (t.parentMessageId = t._parentMessageId, delete t._parentMessageId), e && e(t);\n        });\n      }\n    }, {\n      key: \"_update\",\n      value: function value(e) {\n        e.hasOwnProperty(\"mention_type\") && (this._mentionType = e.mention_type), e.hasOwnProperty(\"mentioned_user_ids\") && (this._mentionedUserIds = e.mentioned_user_ids), e.hasOwnProperty(\"mentioned_message_template\") && (this.mentionedMessageTemplate = e.mentioned_message_template), e.hasOwnProperty(\"cached_mentioned_users\") && (this._cachedMentionedUsers = e.cached_mentioned_users), e.hasOwnProperty(\"cached_mentioned_user_ids\") && (this._cachedMentionedUserIds = e.cached_mentioned_user_ids), e.hasOwnProperty(\"meta_arrays\") && (this._metaArrays = e.meta_arrays.map(function (e) {\n          return new Er(e.key, e.value);\n        })), e.hasOwnProperty(\"parent_message_id\") && (this.parentMessageId = e.parent_message_id), e.hasOwnProperty(\"data\") && (this.data = e.data), e.hasOwnProperty(\"custom_type\") && (this.customType = e.custom_type), e.hasOwnProperty(\"push_notification_delivery_option\") && (this.pushNotificationDeliveryOption = e.push_notification_delivery_option), e.hasOwnProperty(\"apple_critical_alert_options\") && (this.appleCriticalAlertOptions = new mr(e.apple_critical_alert_options)), e.hasOwnProperty(\"is_reply_to_channel\") && (this.isReplyToChannel = e.is_reply_to_channel);\n      }\n    }, {\n      key: \"_validate\",\n      value: function value() {\n        var e = x.get(this._iid),\n            t = e.BaseMessageParams,\n            n = e.MessageMetaArray,\n            r = vr.get(this);\n        return Object.keys(t.MentionType).map(function (e) {\n          return t.MentionType[e];\n        }).indexOf(this.mentionType) > -1 && this._mentionedUserIds.every(function (e) {\n          return \"string\" == typeof e;\n        }) && (\"string\" == typeof this.mentionedMessageTemplate || null === this.mentionedMessageTemplate) && Array.isArray(this._metaArrays) && this._metaArrays.every(function (e) {\n          return e instanceof n;\n        }) && (\"number\" == typeof r || null === r) && (\"number\" == typeof this._parentMessageId || null === this._parentMessageId) && (\"string\" == typeof this.data || null === this.data) && (\"string\" == typeof this.customType || null === this.customType) && (null === this.pushNotificationDeliveryOption || Object.keys(t.PushNotificationDeliveryOption).map(function (e) {\n          return t.PushNotificationDeliveryOption[e];\n        }).indexOf(this.pushNotificationDeliveryOption) > -1) && (null === this.appleCriticalAlertOptions || this.appleCriticalAlertOptions instanceof mr) && \"boolean\" == typeof this.isReplyToChannel;\n      }\n    }], [{\n      key: \"_objectify\",\n      value: function value(t) {\n        var n = t.mentionType,\n            r = void 0 === n ? e.MentionType.USERS : n,\n            i = t.mentionedUserIds,\n            s = void 0 === i ? [] : i,\n            a = t.mentionedMessageTemplate,\n            o = void 0 === a ? null : a,\n            l = t.cachedMentionedUsers,\n            u = void 0 === l ? [] : l,\n            c = t.cachedMentionedUserIds,\n            d = void 0 === c ? [] : c,\n            h = t.metaArrays,\n            p = void 0 === h ? [] : h,\n            f = t.parentMessageId,\n            _ = void 0 === f ? null : f,\n            g = t.pushNotificationDeliveryOption,\n            y = void 0 === g ? null : g,\n            m = t.appleCriticalAlertOptions,\n            E = void 0 === m ? null : m,\n            v = t.isReplyToChannel;\n\n        return {\n          mention_type: r,\n          mentioned_user_ids: s,\n          mentioned_message_template: o,\n          cached_mentioned_users: u,\n          cached_mentioned_user_ids: d,\n          meta_arrays: p,\n          parent_message_id: _,\n          push_notification_delivery_option: y,\n          apple_critical_alert_options: E,\n          is_reply_to_channel: void 0 !== v && v\n        };\n      }\n    }, {\n      key: \"MentionType\",\n      get: function get() {\n        return {\n          USERS: \"users\",\n          CHANNEL: \"channel\"\n        };\n      }\n    }, {\n      key: \"PushNotificationDeliveryOption\",\n      get: function get() {\n        return {\n          DEFAULT: \"default\",\n          SUPPRESS: \"suppress\"\n        };\n      }\n    }]), e;\n  }(),\n      Cr = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n(e) {\n      var r;\n      return c(this, n), (r = t.call(this, e)).message = null, r.pollId = void 0, r._translationTargetLanguages = [], e && r._update(e), r;\n    }\n\n    return h(n, [{\n      key: \"serialize\",\n      value: function value() {\n        return b(_(n.prototype), \"_serialize\", this).call(this, function (e) {\n          e.hasOwnProperty(\"_translationTargetLanguages\") && (e.translationTargetLanguages = e._translationTargetLanguages, delete e._translationTargetLanguages);\n        });\n      }\n    }, {\n      key: \"targetLanguages\",\n      get: function get() {\n        return this.translationTargetLanguages;\n      },\n      set: function set(e) {\n        this.translationTargetLanguages = e;\n      }\n    }, {\n      key: \"translationTargetLanguages\",\n      get: function get() {\n        return this._translationTargetLanguages;\n      },\n      set: function set(e) {\n        if (Array.isArray(e)) {\n          for (var t = 0; t < e.length; t++) {\n            if (\"string\" != typeof e[t]) return void (this._translationTargetLanguages = []);\n          }\n\n          this._translationTargetLanguages = e;\n        }\n      }\n    }, {\n      key: \"_update\",\n      value: function value(e) {\n        b(_(n.prototype), \"_update\", this).call(this, e), e.hasOwnProperty(\"message\") && (this.message = e.message), e.hasOwnProperty(\"translation_target_languages\") && (this._translationTargetLanguages = e.translation_target_languages), e.hasOwnProperty(\"poll_id\") && (this.pollId = e.poll_id);\n      }\n    }, {\n      key: \"_validate\",\n      value: function value() {\n        return b(_(n.prototype), \"_validate\", this).call(this) && (\"string\" == typeof this.message || null === this.message) && Array.isArray(this.translationTargetLanguages) && this.translationTargetLanguages.every(function (e) {\n          return \"string\" == typeof e;\n        }) && (\"number\" == typeof this.pollId || null === this.pollId || void 0 === this.pollId);\n      }\n    }], [{\n      key: \"objectify\",\n      value: function value(e) {\n        var t = e.message,\n            n = void 0 === t ? null : t,\n            r = e.data,\n            i = void 0 === r ? null : r,\n            s = e.customType,\n            a = void 0 === s ? null : s,\n            o = e.translationTargetLanguages,\n            u = void 0 === o ? [] : o,\n            c = e.pollId,\n            d = void 0 === c ? void 0 : c;\n        return l(l({}, br._objectify(e)), {}, {\n          message: n,\n          data: i,\n          custom_type: a,\n          translation_target_languages: u,\n          poll_id: d\n        });\n      }\n    }]), n;\n  }(br),\n      Ar = function () {\n    function e(e, t, n) {\n      void 0 === t && (t = []), void 0 === n && (n = 0), this.key = e, this.userIds = t, this.updatedAt = n;\n\n      for (var r = {}, i = 0, s = this.userIds; i < s.length; i++) {\n        r[s[i]] = this.updatedAt;\n      }\n\n      this._version = r;\n    }\n\n    return Object.defineProperty(e.prototype, \"isEmpty\", {\n      get: function get() {\n        return 0 === this.userIds.length;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.createFromJson = function (e) {\n      var t = e.key,\n          n = e.user_ids,\n          r = e.updated_at;\n      return \"string\" == typeof t && t && Array.isArray(n) && n.length > 0 && \"number\" == typeof r ? new this(t, n, r) : null;\n    }, e.objectify = function (e) {\n      return {\n        key: e.key,\n        user_ids: e.userIds,\n        updated_at: e.updatedAt\n      };\n    }, e.prototype._applyEvent = function (e) {\n      if (e.key === this.key && (!this._version[e.userId] || this._version[e.userId] < e.updatedAt)) {\n        var t = this.userIds.indexOf(e.userId);\n\n        switch (e.operation) {\n          case \"add\":\n            t < 0 && this.userIds.push(e.userId);\n            break;\n\n          case \"delete\":\n            t >= 0 && this.userIds.splice(t, 1);\n        }\n\n        this._version[e.userId] = e.updatedAt;\n      }\n    }, e;\n  }(),\n      Nr = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n(e) {\n      var r;\n      return c(this, n), (r = t.call(this, e)).messageType = Tt.MESSAGE_TYPE_USER, r.message = null, r._sender = null, r.translations = {}, r.requestState = null, r.requestedMentionUserIds = [], r.errorCode = 0, r.messageSurvivalSeconds = -1, r.plugins = [], r.poll = null, r._messageParams = null, e && r._update(e), r;\n    }\n\n    return h(n, [{\n      key: \"applyPollUpdateEvent\",\n      value: function value(e) {\n        var t = x.get(this._iid),\n            n = t.Poll,\n            r = t.PollUpdateEvent,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: r,\n          constraint: function constraint(e) {\n            return Object.values(n.Status).includes(e.status);\n          }\n        })]),\n            a = C(s, 2);\n\n        if (i = a[0], e = a[1], !i && this.poll && this.poll.id === e.poll.id) {\n          if (e.status === n.Status.REMOVED) return this.poll = new n(n.objectify(this.poll)), this.poll.details.status = e.status, !0;\n          if (this.poll.details.updatedAt < e.poll.details.updatedAt) return this.poll = e.poll, !0;\n        }\n\n        return !1;\n      }\n    }, {\n      key: \"applyPollVoteEvent\",\n      value: function value(e) {\n        var t = x.get(this._iid),\n            n = t.PollVoteEvent,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: n\n        })]),\n            s = C(i, 2);\n\n        if (r = s[0], e = s[1], !r && this.poll && this.poll.id === e.pollId) {\n          var a,\n              o = I(this.poll.details.options);\n\n          try {\n            for (o.s(); !(a = o.n()).done;) {\n              var l = a.value;\n              if (l._applyEvent(e)) return !0;\n            }\n          } catch (r) {\n            o.e(r);\n          } finally {\n            o.f();\n          }\n        }\n\n        return !1;\n      }\n    }, {\n      key: \"_update\",\n      value: function value(e) {\n        var t = ji.getInstance(this._iid),\n            n = x.get(this._iid),\n            r = n.Sender,\n            i = n.Plugin,\n            s = n.Poll;\n        this.message = String(e.message), this._sender = new r(e.user), this.reqId = e.hasOwnProperty(\"req_id\") ? String(e.req_id) : \"\", this.translations = e.hasOwnProperty(\"translations\") ? e.translations : {}, this.requestState = this.messageId > 0 ? t.MessageRequestState.SUCCEEDED : t.MessageRequestState.FAILED, e.hasOwnProperty(\"sending_status\") && (this.requestState = e.sending_status, this.requestState === t.MessageSendingStatus.CANCELED && (this.requestState = t.MessageRequestState.FAILED)), this.requestedMentionUserIds = [], e.hasOwnProperty(\"requested_mention_user_ids\") && (this.requestedMentionUserIds = e.requested_mention_user_ids), this.errorCode = 0, e.hasOwnProperty(\"error_code\") && (this.errorCode = e.error_code), this.messageSurvivalSeconds = -1, e.hasOwnProperty(\"message_survival_seconds\") && (this.messageSurvivalSeconds = e.message_survival_seconds), this.plugins = [], e.hasOwnProperty(\"plugins\") && Array.isArray(e.plugins) && (this.plugins = e.plugins.map(function (e) {\n          return new i(e);\n        })), this.poll = null, e.hasOwnProperty(\"poll\") && (this.poll = new s(e.poll)), e.hasOwnProperty(\"message_params\") && (this._messageParams = new Cr(e.message_params));\n      }\n    }, {\n      key: \"sender\",\n      get: function get() {\n        var e = ji.getInstance(this._iid),\n            t = x.get(this._iid).GroupChannel;\n\n        if (this._sender && e.Options.useMemberAsMessageSender && this.isGroupChannel()) {\n          var n = t.cachedChannels[this.channelUrl];\n\n          if (n) {\n            var r = n.memberMap[this._sender.userId];\n            r && (this._sender.nickname !== r.nickname && (this._sender.nickname = r.nickname), this._sender.plainProfileUrl !== r.plainProfileUrl && (this._sender.plainProfileUrl = r.plainProfileUrl), se.deepEqual(this._sender.metaData, r.metaData) || (this._sender.metaData = r.metaData));\n          }\n        }\n\n        return this._sender;\n      },\n      set: function set(e) {\n        this._sender = e;\n      }\n    }, {\n      key: \"isResendable\",\n      value: function value() {\n        var e = ji.getInstance(this._iid);\n        return this.sendingStatus === e.MessageSendingStatus.FAILED && se.isResendableError(this.errorCode);\n      }\n    }, {\n      key: \"serialize\",\n      value: function value() {\n        var e = this;\n        return b(_(n.prototype), \"serialize\", this).call(this, function (t) {\n          e._messageParams && (t.messageParams = e._messageParams.serialize());\n        });\n      }\n    }, {\n      key: \"messageParams\",\n      get: function get() {\n        return this._messageParams;\n      }\n    }, {\n      key: \"_clone\",\n      value: function value() {\n        return x.get(this._iid).UserMessage.buildFromSerializedData(this.serialize());\n      }\n    }, {\n      key: \"_isSentByMe\",\n      value: function value() {\n        var e = ji.getInstance(this._iid);\n        return this.sendingStatus === e.MessageSendingStatus.SUCCEEDED && 0 === this.updatedAt && this._sender && this._sender.userId === e.currentUser.userId;\n      }\n    }], [{\n      key: \"objectify\",\n      value: function value(e) {\n        var t = ji.getInstance(this._iid),\n            n = x.get(this._iid),\n            r = n.BaseChannel,\n            i = n.BaseMessageParams,\n            s = n.Sender,\n            a = n.User,\n            o = n.UserMessage,\n            u = n.FileMessage,\n            c = n.AdminMessage,\n            d = n.ThreadInfo,\n            h = n.OGMetaData,\n            p = n.Plugin,\n            f = n.Reaction,\n            _ = n.AppleCriticalAlertOptions,\n            g = n.Poll,\n            y = n.UserMessageParams,\n            m = e.messageId,\n            E = e.messageType,\n            v = void 0 === E ? Tt.MESSAGE_TYPE_BASE : E,\n            b = e.reqId,\n            C = void 0 === b ? \"\" : b,\n            A = e.user,\n            N = e.channel,\n            S = void 0 === N ? null : N,\n            I = e.channelUrl,\n            T = void 0 === I ? \"\" : I,\n            O = e.channelType,\n            U = void 0 === O ? r.CHANNEL_TYPE_OPEN : O,\n            M = e.message,\n            k = e.data,\n            R = void 0 === k ? \"\" : k,\n            L = e.customType,\n            P = void 0 === L ? \"\" : L,\n            w = e.mentionType,\n            D = void 0 === w ? i.MentionType.USERS : w,\n            H = e.mentionedUsers,\n            F = void 0 === H ? [] : H,\n            G = e.mentionedUserIds,\n            j = void 0 === G ? [] : G,\n            B = e.mentionedMessageTemplate,\n            V = void 0 === B ? null : B,\n            q = e.requestedMentionUserIds,\n            K = void 0 === q ? [] : q,\n            z = e.reactions,\n            Y = void 0 === z ? [] : z,\n            Q = e.metaArrays,\n            W = void 0 === Q ? [] : Q,\n            J = e.rootMessageId,\n            X = void 0 === J ? 0 : J,\n            Z = e.parentMessageId,\n            $ = void 0 === Z ? 0 : Z,\n            ee = e.parentMessageText,\n            te = void 0 === ee ? \"\" : ee,\n            ne = e.threadInfo,\n            re = void 0 === ne ? null : ne,\n            ie = e.isReplyToChannel,\n            se = void 0 !== ie && ie,\n            ae = e.parentMessage,\n            oe = void 0 === ae ? null : ae,\n            le = e.translations,\n            ue = void 0 === le ? {} : le,\n            ce = e.sendingStatus,\n            de = e.errorCode,\n            he = void 0 === de ? 0 : de,\n            pe = e.silent,\n            fe = void 0 !== pe && pe,\n            _e = e.isGlobalBlocked,\n            ge = void 0 !== _e && _e,\n            ye = e.messageSurvivalSeconds,\n            me = void 0 === ye ? -1 : ye,\n            Ee = e.ogMetaData,\n            ve = void 0 === Ee ? null : Ee,\n            be = e.isOperatorMessage,\n            Ce = void 0 !== be && be,\n            Ae = e.plugins,\n            Ne = void 0 === Ae ? [] : Ae,\n            Se = e.appleCriticalAlertOptions,\n            Ie = e.poll,\n            Te = void 0 === Ie ? null : Ie,\n            Oe = e.createdAt,\n            Ue = e.updatedAt,\n            Me = void 0 === Ue ? 0 : Ue,\n            ke = e.messageParams,\n            Re = void 0 === ke ? null : ke,\n            Le = e.isAutoResendRegistered,\n            Pe = void 0 !== Le && Le,\n            we = {};\n\n        switch (we.req_id = C, we.msg_id = m, v) {\n          case Tt.MESSAGE_TYPE_USER:\n            we.type = \"MESG\";\n            break;\n\n          case Tt.MESSAGE_TYPE_FILE:\n            we.type = \"FILE\";\n            break;\n\n          case Tt.MESSAGE_TYPE_ADMIN:\n            we.type = \"ADMM\";\n        }\n\n        if (we.user = s.objectify(l({}, A)), we.channel_url = S ? S.url : T, we.channel_type = S ? S.channelType : U, we.message = M, we.data = R, we.custom_type = P, we.translations = ue, we.is_global_block = !!ge, we.ts = Oe, we.updated_at = Me, we.mention_type = D, we.mentioned_users = F.map(function (e) {\n          return a.objectify(e);\n        }), we.mentioned_user_ids = j, we.mentioned_message_template = V, we.requested_mention_user_ids = K, we.reactions = Y.map(function (e) {\n          return f.objectify(e);\n        }), we.metaarray = {}, W.forEach(function (e) {\n          var t = e.key;\n          we.metaarray[t] = e.value;\n        }), we.metaarray_key_order = W.map(function (e) {\n          return e.key;\n        }), we.root_message_id = X, we.parent_message_id = $, we.parent_message_text = te, re && (we.thread_info = d.objectify(re)), we.is_reply_to_channel = se, oe) switch (oe.messageType) {\n          case Tt.MESSAGE_TYPE_USER:\n            we.parent_message_info = o._objectifySerializedData(oe);\n            break;\n\n          case Tt.MESSAGE_TYPE_FILE:\n            we.parent_message_info = u._objectifySerializedData(oe);\n            break;\n\n          case Tt.MESSAGE_TYPE_ADMIN:\n            we.parent_message_info = c._objectifySerializedData(oe);\n        }\n        return we.sending_status = m > 0 ? t.MessageSendingStatus.SUCCEEDED : t.MessageSendingStatus.FAILED, ce && (we.sending_status = ce), we.silent = !!fe, we.error_code = he, we.message_survival_seconds = me, ve && (we.og_tag = h.objectify(ve)), we.is_op_msg = !!Ce, we.plugins = Ne.map(function (e) {\n          return p.objectify(e);\n        }), Te && (we.poll = g.objectify(Te)), Se && (we.apple_critical_alert_options = _.objectify(Se)), Re && (we.message_params = y.objectify(Re)), we.is_auto_resend_registered = Pe, we;\n      }\n    }, {\n      key: \"build\",\n      value: function value(e, t, n, r, i, s, a, o, l, u, c, d, h, p, f, _, g, y, m, E, v, b, C, A, N, S, I, T, O, U, M) {\n        return this.objectify({\n          messageId: t,\n          reqId: e,\n          user: n,\n          channel: r,\n          message: i,\n          data: s,\n          customType: a,\n          mentionType: p,\n          mentionedUsers: f,\n          mentionedUserIds: E,\n          mentionedMessageTemplate: v,\n          requestedMentionUserIds: C,\n          reactions: h,\n          metaArrays: d,\n          rootMessageId: _,\n          parentMessageId: g,\n          parentMessageText: y,\n          threadInfo: m,\n          translations: o,\n          sendingStatus: b,\n          errorCode: A,\n          isGlobalBlocked: l,\n          messageSurvivalSeconds: N,\n          ogMetaData: S,\n          isOperatorMessage: I,\n          plugins: T,\n          appleCriticalAlertOptions: O,\n          poll: U,\n          createdAt: u,\n          updatedAt: c,\n          messageParams: M\n        });\n      }\n    }, {\n      key: \"buildFromSerializedData\",\n      value: function value(e) {\n        var t = x.get(this._iid).UserMessage,\n            n = Nt.deserialize(e);\n        return new t(this._objectifySerializedData(n));\n      }\n    }, {\n      key: \"_objectifySerializedData\",\n      value: function value(e) {\n        return x.get(this._iid).UserMessage.objectify(l(l({}, e), {}, {\n          channel: {\n            url: e.channelUrl,\n            channelType: e.channelType\n          },\n          user: e.sender,\n          messageParams: e.messageParams ? new Cr(Cr.objectify(e.messageParams)) : null\n        }));\n      }\n    }]), n;\n  }(Tt),\n      Sr = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n(e) {\n      var r;\n      return c(this, n), (r = t.call(this, e)).fileName = null, r.mimeType = null, r.fileSize = null, r._isUpdate = !1, r._file = null, r._fileType = null, r._fileUrl = null, r._thumbnailSizes = [], e && r._update(e), r;\n    }\n\n    return h(n, [{\n      key: \"serialize\",\n      value: function value() {\n        return b(_(n.prototype), \"_serialize\", this).call(this, function (e) {\n          e.hasOwnProperty(\"_isUpdate\") && (e.isUpdate = e._isUpdate, delete e._isUpdate), e.hasOwnProperty(\"_file\") && (e.file = e._file, delete e._file), e.hasOwnProperty(\"_fileType\") && (e.fileType = e._fileType, delete e._fileType), e.hasOwnProperty(\"_fileUrl\") && (e.fileUrl = e._fileUrl, delete e._fileUrl), e.hasOwnProperty(\"_thumbnailSizes\") && (e.thumbnailSizes = e._thumbnailSizes, delete e._thumbnailSizes);\n        });\n      }\n    }, {\n      key: \"file\",\n      get: function get() {\n        return this._file;\n      },\n      set: function set(e) {\n        se.isFile(e) && (this._fileUrl = null, this._file = e, te.isFile(e) ? this._fileType = D.FILE : te.isBlob(e) ? this._fileType = D.BLOB : te.isFileLikeObject(e) ? this._fileType = D.BLOB_LIKE_OBJECT : \"string\" == typeof e && (this._fileType = D.URL));\n      }\n    }, {\n      key: \"fileType\",\n      get: function get() {\n        return this._fileType;\n      }\n    }, {\n      key: \"fileUrl\",\n      get: function get() {\n        return this._fileUrl;\n      },\n      set: function set(e) {\n        \"string\" == typeof e && (this._fileUrl = e, this._file = null);\n      }\n    }, {\n      key: \"thumbnailSizes\",\n      get: function get() {\n        return this._thumbnailSizes;\n      },\n      set: function set(e) {\n        if (Array.isArray(e)) {\n          for (var t = 0; t < e.length; t++) {\n            if (\"object\" !== u(e[t]) || \"number\" != typeof e[t].maxWidth || \"number\" != typeof e[t].maxHeight) return void (this._thumbnailSizes = []);\n          }\n\n          this._thumbnailSizes = e;\n        }\n      }\n    }, {\n      key: \"_update\",\n      value: function value(e) {\n        b(_(n.prototype), \"_update\", this).call(this, e), e.hasOwnProperty(\"file_name\") && (this.fileName = e.file_name), e.hasOwnProperty(\"mime_type\") && (this.mimeType = e.mime_type), e.hasOwnProperty(\"file_size\") && (this.fileSize = e.file_size), e.hasOwnProperty(\"is_update\") && (this._isUpdate = e.is_update), e.hasOwnProperty(\"file\") && (this._file = e.file), e.hasOwnProperty(\"file_type\") && (this._fileType = e.file_type), e.hasOwnProperty(\"file_url\") && (this._fileUrl = e.file_url), e.hasOwnProperty(\"thumbnail_sizes\") && (this._thumbnailSizes = e.thumbnail_sizes);\n      }\n    }, {\n      key: \"_validate\",\n      value: function value() {\n        return b(_(n.prototype), \"_validate\", this).call(this) && (this._isUpdate || se.isFile(this.file) || \"string\" == typeof this.fileUrl) && (\"string\" == typeof this.fileName || null === this.fileName) && (\"string\" == typeof this.mimeType || null === this.mimeType) && (\"number\" == typeof this.fileSize || null === this.fileSize) && (null === this._thumbnailSizes || this._thumbnailSizes.every(function (e) {\n          return \"object\" === u(e) && e.maxWidth > 0 && e.maxHeight > 0;\n        }));\n      }\n    }], [{\n      key: \"objectify\",\n      value: function value(e) {\n        var t = e.fileName,\n            n = void 0 === t ? null : t,\n            r = e.mimeType,\n            i = void 0 === r ? null : r,\n            s = e.fileSize,\n            a = void 0 === s ? null : s,\n            o = e.data,\n            u = void 0 === o ? null : o,\n            c = e.customType,\n            d = void 0 === c ? null : c,\n            h = e.isUpdate,\n            p = void 0 !== h && h,\n            f = e.file,\n            _ = void 0 === f ? null : f,\n            g = e.fileType,\n            y = void 0 === g ? null : g,\n            m = e.fileUrl,\n            E = void 0 === m ? null : m,\n            v = e.thumbnailSizes,\n            b = void 0 === v ? [] : v;\n\n        return l(l({}, br._objectify(e)), {}, {\n          file_name: n,\n          mime_type: i,\n          file_size: a,\n          data: u,\n          custom_type: d,\n          is_update: p,\n          file: _,\n          file_type: y,\n          file_url: E,\n          thumbnail_sizes: b\n        });\n      }\n    }]), n;\n  }(br),\n      Ir = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n(e) {\n      var r;\n      return c(this, n), (r = t.call(this, e)).messageType = Tt.MESSAGE_TYPE_FILE, r.plainUrl = null, r.name = \"File\", r.size = 0, r.type = null, r.thumbnails = [], r._sender = null, r.requireAuth = null, r.requestState = null, r.requestedMentionUserIds = [], r.errorCode = 0, r.messageSurvivalSeconds = -1, r._messageParams = null, e && r._update(e), r;\n    }\n\n    return h(n, [{\n      key: \"_update\",\n      value: function value(e) {\n        var t = ji.getInstance(this._iid),\n            n = U.get(this._iid).container.auth,\n            r = x.get(this._iid).Sender;\n\n        if (this._sender = new r(e.user), this.requireAuth = !!e.hasOwnProperty(\"require_auth\") && e.require_auth, e.hasOwnProperty(\"url\") && (this.plainUrl = e.url.split(\"?auth=\")[0]), this.name = e.hasOwnProperty(\"name\") ? e.name : \"File\", this.size = parseInt(e.size) || 0, this.type = e.type, e.hasOwnProperty(\"custom\") && (this.data = e.custom), e.hasOwnProperty(\"file\")) {\n          var i = e.file;\n          i.hasOwnProperty(\"url\") && (this.plainUrl = i.url), i.hasOwnProperty(\"name\") && (this.name = i.name), i.hasOwnProperty(\"size\") && (this.size = i.size), i.hasOwnProperty(\"type\") && (this.type = i.type), i.hasOwnProperty(\"custom\") && (this.data = i.custom);\n        }\n\n        if (Object.defineProperty(this, \"url\", {\n          value: this.requireAuth ? \"\".concat(this.plainUrl, \"?auth=\").concat(n.eKey) : this.plainUrl,\n          configurable: !0,\n          writable: !1\n        }), this.reqId = e.hasOwnProperty(\"req_id\") ? String(e.req_id) : \"\", this.thumbnails = e.hasOwnProperty(\"thumbnails\") ? e.thumbnails : [], this.requireAuth) for (var s = 0; s < this.thumbnails.length; s++) {\n          this.thumbnails[s].plainUrl = String(this.thumbnails[s].url).split(\"?auth=\")[0], this.thumbnails[s].url = this.requireAuth ? \"\".concat(this.thumbnails[s].plainUrl, \"?auth=\").concat(n.eKey) : this.thumbnails[s].plainUrl;\n        }\n        this.requestState = this.messageId > 0 ? t.MessageRequestState.SUCCEEDED : t.MessageRequestState.FAILED, e.hasOwnProperty(\"sending_status\") && (this.requestState = e.sending_status, this.requestState === t.MessageSendingStatus.CANCELED && (this.requestState = t.MessageRequestState.FAILED)), this.requestedMentionUserIds = [], e.hasOwnProperty(\"requested_mention_user_ids\") && (this.requestedMentionUserIds = e.requested_mention_user_ids), this.errorCode = 0, e.hasOwnProperty(\"error_code\") && (this.errorCode = e.error_code), this.messageSurvivalSeconds = -1, e.hasOwnProperty(\"message_survival_seconds\") && (this.messageSurvivalSeconds = e.message_survival_seconds), e.hasOwnProperty(\"message_params\") && (this._messageParams = new Sr(e.message_params));\n      }\n    }, {\n      key: \"sender\",\n      get: function get() {\n        var e = ji.getInstance(this._iid),\n            t = x.get(this._iid).GroupChannel;\n\n        if (this._sender && e.Options.useMemberAsMessageSender && this.isGroupChannel()) {\n          var n = t.cachedChannels[this.channelUrl];\n\n          if (n) {\n            var r = n.memberMap[this._sender.userId];\n            r && (this._sender.nickname !== r.nickname && (this._sender.nickname = r.nickname), this._sender.plainProfileUrl !== r.plainProfileUrl && (this._sender.plainProfileUrl = r.plainProfileUrl), se.deepEqual(this._sender.metaData, r.metaData) || (this._sender.metaData = r.metaData));\n          }\n        }\n\n        return this._sender;\n      },\n      set: function set(e) {\n        this._sender = e;\n      }\n    }, {\n      key: \"isResendable\",\n      value: function value() {\n        var e = ji.getInstance(this._iid);\n        return this.sendingStatus === e.MessageSendingStatus.FAILED && se.isResendableError(this.errorCode);\n      }\n    }, {\n      key: \"serialize\",\n      value: function value() {\n        var e = this;\n        return b(_(n.prototype), \"serialize\", this).call(this, function (t) {\n          e._messageParams && (t.messageParams = e._messageParams.serialize());\n        });\n      }\n    }, {\n      key: \"messageParams\",\n      get: function get() {\n        return this._messageParams;\n      }\n    }, {\n      key: \"_clone\",\n      value: function value() {\n        var e = x.get(this._iid).FileMessage.buildFromSerializedData(this.serialize());\n\n        if (this._messageParams && e._messageParams) {\n          var t = this._messageParams.file;\n          t && te.isBlob(t) && (e._messageParams.file = t.slice());\n        }\n\n        return e;\n      }\n    }, {\n      key: \"_isSentByMe\",\n      value: function value() {\n        var e = ji.getInstance(this._iid);\n        return this.sendingStatus === e.MessageSendingStatus.SUCCEEDED && 0 === this.updatedAt && this._sender && this._sender.userId === e.currentUser.userId;\n      }\n    }], [{\n      key: \"objectify\",\n      value: function value(e) {\n        var t = ji.getInstance(this._iid),\n            n = x.get(this._iid),\n            r = n.BaseChannel,\n            i = n.BaseMessageParams,\n            s = n.Sender,\n            a = n.User,\n            o = n.UserMessage,\n            u = n.FileMessage,\n            c = n.AdminMessage,\n            d = n.ThreadInfo,\n            h = n.OGMetaData,\n            p = n.Reaction,\n            f = n.FileMessageParams,\n            _ = n.AppleCriticalAlertOptions,\n            g = e.messageId,\n            y = e.messageType,\n            m = void 0 === y ? Tt.MESSAGE_TYPE_BASE : y,\n            E = e.reqId,\n            v = void 0 === E ? \"\" : E,\n            b = e.user,\n            C = void 0 === b ? {} : b,\n            A = e.channel,\n            N = e.plainUrl,\n            S = e.name,\n            I = void 0 === S ? null : S,\n            T = e.type,\n            O = e.size,\n            U = void 0 === O ? 0 : O,\n            M = e.data,\n            k = void 0 === M ? \"\" : M,\n            R = e.customType,\n            L = void 0 === R ? \"\" : R,\n            P = e.mentionType,\n            w = void 0 === P ? i.MentionType.USERS : P,\n            D = e.mentionedUsers,\n            H = void 0 === D ? [] : D,\n            F = e.mentionedUserIds,\n            G = void 0 === F ? [] : F,\n            j = e.requestedMentionUserIds,\n            B = void 0 === j ? [] : j,\n            V = e.reactions,\n            q = void 0 === V ? [] : V,\n            K = e.metaArrays,\n            z = void 0 === K ? [] : K,\n            Y = e.rootMessageId,\n            Q = void 0 === Y ? 0 : Y,\n            W = e.parentMessageId,\n            J = void 0 === W ? 0 : W,\n            X = e.parentMessageText,\n            Z = void 0 === X ? \"\" : X,\n            $ = e.threadInfo,\n            ee = void 0 === $ ? null : $,\n            te = e.isReplyToChannel,\n            ne = void 0 !== te && te,\n            re = e.parentMessage,\n            ie = void 0 === re ? null : re,\n            se = e.thumbnails,\n            ae = void 0 === se ? [] : se,\n            oe = e.requireAuth,\n            le = void 0 !== oe && oe,\n            ue = e.sendingStatus,\n            ce = e.errorCode,\n            de = void 0 === ce ? 0 : ce,\n            he = e.silent,\n            pe = void 0 !== he && he,\n            fe = e.isGlobalBlocked,\n            _e = void 0 !== fe && fe,\n            ge = e.messageSurvivalSeconds,\n            ye = void 0 === ge ? -1 : ge,\n            me = e.ogMetaData,\n            Ee = void 0 === me ? null : me,\n            ve = e.isOperatorMessage,\n            be = void 0 !== ve && ve,\n            Ce = e.appleCriticalAlertOptions,\n            Ae = e.createdAt,\n            Ne = e.updatedAt,\n            Se = void 0 === Ne ? 0 : Ne,\n            Ie = e.messageParams,\n            Te = void 0 === Ie ? null : Ie,\n            Oe = e.isAutoResendRegistered,\n            Ue = void 0 !== Oe && Oe,\n            Me = {};\n\n        switch (Me.req_id = v, Me.msg_id = g, m) {\n          case Tt.MESSAGE_TYPE_USER:\n            Me.type = \"MESG\";\n            break;\n\n          case Tt.MESSAGE_TYPE_FILE:\n            Me.type = \"FILE\";\n            break;\n\n          case Tt.MESSAGE_TYPE_ADMIN:\n            Me.type = \"ADMM\";\n        }\n\n        Me.user = s.objectify(l({}, C)), Me.channel_url = A.url, Me.channel_type = A.channelType === r.CHANNEL_TYPE_OPEN ? r.CHANNEL_TYPE_OPEN : r.CHANNEL_TYPE_GROUP, Me.url = N, Me.name = I, Me.type = T, Me.size = U, Me.custom = k, Me.custom_type = L, Me.thumbnails = ae, Me.require_auth = le, Me.is_global_block = !!_e, Me.ts = Ae, Me.updated_at = Se, Me.mention_type = w, Me.mentioned_users = H.map(function (e) {\n          return a.objectify(e);\n        }), Me.mentioned_user_ids = G, Me.requested_mention_user_ids = B, Me.reactions = q.map(function (e) {\n          return p.objectify(e);\n        }), Me.metaarray = {};\n\n        for (var ke = 0; ke < z.length; ke++) {\n          var Re = z[ke].key;\n          Me.metaarray[Re] = z[ke].value;\n        }\n\n        if (Me.metaarray_key_order = z.map(function (e) {\n          return e.key;\n        }), Me.root_message_id = Q, Me.parent_message_id = J, Me.parent_message_text = Z, ee && (Me.thread_info = d.objectify(ee)), Me.is_reply_to_channel = ne, ie) switch (ie.messageType) {\n          case r.MESSAGE_TYPE_USER:\n            Me.parent_message_info = o._objectifySerializedData(ie);\n            break;\n\n          case r.MESSAGE_TYPE_FILE:\n            Me.parent_message_info = u._objectifySerializedData(ie);\n            break;\n\n          case r.MESSAGE_TYPE_ADMIN:\n            Me.parent_message_info = c._objectifySerializedData(ie);\n        }\n        return Me.sending_status = g > 0 ? t.MessageSendingStatus.SUCCEEDED : t.MessageSendingStatus.FAILED, ue && (Me.sending_status = ue), Me.silent = !!pe, Me.error_code = de, Me.message_survival_seconds = ye, Ee && (Me.og_tag = h.objectify(Ee)), Me.is_op_msg = !!be, Ce && (Me.apple_critical_alert_options = _.objectify(Ce)), Te && (Me.message_params = f.objectify(Te)), Me.is_auto_resend_registered = Ue, Me;\n      }\n    }, {\n      key: \"build\",\n      value: function value(e, t, n, r, i, s, a, o, l, u, c, d, h, p, f, _, g, y, m, E, v, b, C, A, N, S, I, T, O, U, M, k) {\n        return this.objectify({\n          messageId: t,\n          reqId: e,\n          user: n,\n          channel: r,\n          plainUrl: i,\n          name: s,\n          type: a,\n          size: o,\n          data: l,\n          customType: u,\n          mentionType: y,\n          mentionedUsers: m,\n          mentionedUserIds: A,\n          requestedMentionUserIds: S,\n          reactions: g,\n          metaArrays: _,\n          rootMessageId: E,\n          parentMessageId: v,\n          parentMessageText: b,\n          threadInfo: C,\n          thumbnails: h,\n          requireAuth: p,\n          sendingStatus: N,\n          errorCode: I,\n          isGlobalBlocked: c,\n          messageSurvivalSeconds: T,\n          ogMetaData: O,\n          isOperatorMessage: U,\n          appleCriticalAlertOptions: M,\n          createdAt: d,\n          updatedAt: f,\n          messageParams: k\n        });\n      }\n    }, {\n      key: \"buildFromSerializedData\",\n      value: function value(e) {\n        var t = x.get(this._iid).FileMessage,\n            n = Nt.deserialize(e);\n        return new t(this._objectifySerializedData(n));\n      }\n    }, {\n      key: \"_objectifySerializedData\",\n      value: function value(e) {\n        return x.get(this._iid).FileMessage.objectify(l(l({}, e), {}, {\n          channel: {\n            url: e.channelUrl,\n            channelType: e.channelType\n          },\n          user: e.sender,\n          messageParams: e.messageParams ? new Sr(Sr.objectify(e.messageParams)) : null\n        }));\n      }\n    }]), n;\n  }(Tt),\n      Tr = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n(e) {\n      var r;\n      return c(this, n), (r = t.call(this, e)).messageType = Tt.MESSAGE_TYPE_ADMIN, r.message = \"\", r.translations = {}, e && r._update(e), r;\n    }\n\n    return h(n, [{\n      key: \"_update\",\n      value: function value(e) {\n        this.message = String(e.message), this.translations = e.hasOwnProperty(\"translations\") ? e.translations : {};\n      }\n    }], [{\n      key: \"objectify\",\n      value: function value(e) {\n        var t = x.get(this._iid),\n            n = t.BaseChannel,\n            r = t.BaseMessageParams,\n            i = t.UserMessage,\n            s = t.FileMessage,\n            a = t.AdminMessage,\n            o = t.User,\n            l = t.ThreadInfo,\n            u = t.OGMetaData,\n            c = t.Reaction,\n            d = e.messageId,\n            h = e.messageType,\n            p = void 0 === h ? Tt.MESSAGE_TYPE_BASE : h,\n            f = e.channel,\n            _ = e.message,\n            g = e.data,\n            y = void 0 === g ? \"\" : g,\n            m = e.customType,\n            E = void 0 === m ? \"\" : m,\n            v = e.mentionType,\n            b = void 0 === v ? r.MentionType.USERS : v,\n            C = e.mentionedUsers,\n            A = void 0 === C ? [] : C,\n            N = e.mentionedMessageTemplate,\n            S = void 0 === N ? null : N,\n            I = e.reactions,\n            T = void 0 === I ? [] : I,\n            O = e.metaArrays,\n            U = void 0 === O ? [] : O,\n            M = e.rootMessageId,\n            k = void 0 === M ? 0 : M,\n            R = e.parentMessageId,\n            L = void 0 === R ? 0 : R,\n            P = e.parentMessageText,\n            w = void 0 === P ? \"\" : P,\n            D = e.threadInfo,\n            H = void 0 === D ? null : D,\n            F = e.isReplyToChannel,\n            G = void 0 !== F && F,\n            j = e.parentMessage,\n            B = void 0 === j ? null : j,\n            V = e.translations,\n            q = void 0 === V ? {} : V,\n            K = e.silent,\n            z = void 0 !== K && K,\n            Y = e.ogMetaData,\n            Q = void 0 === Y ? null : Y,\n            W = e.createdAt,\n            J = e.updatedAt,\n            X = void 0 === J ? 0 : J,\n            Z = {\n          msg_id: d,\n          channel_url: f.url,\n          channel_type: f.channelType === n.CHANNEL_TYPE_OPEN ? n.CHANNEL_TYPE_OPEN : n.CHANNEL_TYPE_GROUP,\n          message: _,\n          data: y,\n          custom_type: E,\n          silent: z,\n          ts: W,\n          updated_at: X\n        };\n\n        switch (p) {\n          case Tt.MESSAGE_TYPE_USER:\n            Z.type = \"MESG\";\n            break;\n\n          case Tt.MESSAGE_TYPE_FILE:\n            Z.type = \"FILE\";\n            break;\n\n          case Tt.MESSAGE_TYPE_ADMIN:\n            Z.type = \"ADMM\";\n        }\n\n        Z.translations = q, Z.mention_type = b, Z.mentioned_users = A.map(function (e) {\n          return o.objectify(e);\n        }), Z.mentioned_message_template = S, Z.reactions = T.map(function (e) {\n          return c.objectify(e);\n        }), Z.metaarray = {};\n\n        for (var $ = 0; $ < U.length; $++) {\n          var ee = U[$].key;\n          Z.metaarray[ee] = U[$].value;\n        }\n\n        if (Z.metaarray_key_order = U.map(function (e) {\n          return e.key;\n        }), Z.root_message_id = k, Z.parent_message_id = L, Z.parent_message_text = w, H && (Z.thread_info = l.objectify(H)), Z.is_reply_to_channel = G, B) switch (B.messageType) {\n          case n.MESSAGE_TYPE_USER:\n            Z.parent_message_info = i._objectifySerializedData(B);\n            break;\n\n          case n.MESSAGE_TYPE_FILE:\n            Z.parent_message_info = s._objectifySerializedData(B);\n            break;\n\n          case n.MESSAGE_TYPE_ADMIN:\n            Z.parent_message_info = a._objectifySerializedData(B);\n        }\n        return Q && (Z.og_tag = u.objectify(Q)), Z;\n      }\n    }, {\n      key: \"build\",\n      value: function value(e, t, n, r, i, s, a, o, l, u, c, d, h, p, f, _, g, y) {\n        return this.objectify({\n          messageId: e,\n          channel: t,\n          message: n,\n          data: r,\n          customType: i,\n          mentionType: c,\n          mentionedUsers: d,\n          mentionedMessageTemplate: h,\n          reactions: u,\n          metaArrays: l,\n          rootMessageId: p,\n          parentMessageId: f,\n          parentMessageText: _,\n          threadInfo: g,\n          translations: s,\n          ogMetaData: y,\n          createdAt: a,\n          updatedAt: o\n        });\n      }\n    }, {\n      key: \"buildFromSerializedData\",\n      value: function value(e) {\n        var t = x.get(this._iid).AdminMessage,\n            n = Nt.deserialize(e);\n        return new t(this._objectifySerializedData(n));\n      }\n    }, {\n      key: \"_objectifySerializedData\",\n      value: function value(e) {\n        return x.get(this._iid).AdminMessage.objectify(l(l({}, e), {}, {\n          channel: {\n            url: e.channelUrl,\n            channelType: e.channelType\n          }\n        }));\n      }\n    }]), n;\n  }(Tt),\n      Or = function () {\n    function e(t) {\n      c(this, e);\n      var n = x.get(this._iid),\n          r = n.BaseMessage,\n          i = n.BaseMessageParams;\n      this.scheduledId = 0, this.scheduledDateTimeString = \"\", this.scheduledTimezone = \"\", this.status = e.Status.SCHEDULED, this.createdAt = 0, this.updatedAt = 0, this._messageType = r.MESSAGE_TYPE_BASE, this._sender = null, this._channelType = \"\", this.channelUrl = \"\", this.message = \"\", this.customType = \"\", this.data = \"\", this.metaArrays = [], this.mentionType = i.MentionType.USERS, this.mentionedUsers = [], this.pushNotificationDeliveryOption = i.PushNotificationDeliveryOption.DEFAULT, this.translationTargetLanguages = [], this.errorMessage = \"\", this.errorCode = 0, this.appleCriticalAlertOptions = null, t && this._update(t);\n    }\n\n    return h(e, [{\n      key: \"sender\",\n      get: function get() {\n        var e = ji.getInstance(this._iid),\n            t = x.get(this._iid).GroupChannel;\n\n        if (e.Options.useMemberAsMessageSender && this.isGroupChannel()) {\n          var n = t.cachedChannels[this.channelUrl];\n\n          if (n) {\n            var r = n.memberMap[this._sender.userId];\n            r && (this._sender.nickname !== r.nickname && (this._sender.nickname = r.nickname), this._sender.plainProfileUrl !== r.plainProfileUrl && (this._sender.plainProfileUrl = r.plainProfileUrl), se.deepEqual(this._sender.metaData, r.metaData) || (this._sender.metaData = r.metaData));\n          }\n        }\n\n        return this._sender;\n      },\n      set: function set(e) {\n        this._sender = e;\n      }\n    }, {\n      key: \"_update\",\n      value: function value(t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.User,\n            s = r.Sender,\n            a = r.BaseMessageParams,\n            o = r.MessageMetaArray,\n            l = r.AppleCriticalAlertOptions;\n        this.scheduledId = t.hasOwnProperty(\"scheduled_id\") ? parseInt(t.scheduled_id) : 0, this.scheduledDateTimeString = t.hasOwnProperty(\"scheduled_dt\") ? String(t.scheduled_dt) : \"\", this.scheduledTimezone = t.hasOwnProperty(\"scheduled_timezone\") ? String(t.scheduled_timezone) : \"\", this.status = t.hasOwnProperty(\"status\") ? String(t.status) : \"\", this.createdAt = t.hasOwnProperty(\"created_at\") ? parseInt(t.created_at) : 0, this.updatedAt = t.hasOwnProperty(\"updated_at\") ? parseInt(t.updated_at) : 0, this.channelUrl = t.hasOwnProperty(\"channel_url\") ? String(t.channel_url) : \"\", this._channelType = t.hasOwnProperty(\"channel_type\") ? String(t.channel_type) : \"\", this._messageType = t.hasOwnProperty(\"type\") ? String(t.type) : \"\", this._sender = t.hasOwnProperty(\"user\") ? new s(t.user) : null, this.message = t.hasOwnProperty(\"message\") ? String(t.message) : \"\", this.customType = t.hasOwnProperty(\"custom_type\") ? String(t.custom_type) : \"\", this.data = t.hasOwnProperty(\"data\") ? String(t.data) : \"\";\n        var u = t.hasOwnProperty(\"metaarray\") ? t.metaarray : {},\n            c = t.hasOwnProperty(\"metaarray_key_order\") ? t.metaarray_key_order : Object.keys(u).sort(function (e, t) {\n          return e.localeCompare(t);\n        });\n        this.metaArrays = [];\n\n        for (var d = 0; d < c.length; d++) {\n          var h = c[d];\n          this.metaArrays.push(new o(h, u[h] || []));\n        }\n\n        (this.mentionType = t.hasOwnProperty(\"mention_type\") ? t.mention_type : a.MentionType.USERS, this.mentionedUsers = [], t.hasOwnProperty(\"mentioned_users\")) && t.mentioned_users.forEach(function (e) {\n          var t = new i(e);\n          n.mentionedUsers.push(t);\n        });\n        this.pushNotificationDeliveryOption = t.hasOwnProperty(\"push_option\") ? t.push_option : a.PushNotificationDeliveryOption.DEFAULT, this.translationTargetLanguages = t.hasOwnProperty(\"translation_target_langs\") ? t.translation_target_langs : [], this.status === e.Status.FAILED && (t.hasOwnProperty(\"error\") && t.error.hasOwnProperty(\"message\") && (this.errorMessage = String(t.error.message)), t.hasOwnProperty(\"error\") && t.error.hasOwnProperty(\"code\") && (this.errorCode = parseInt(t.error.code))), t.hasOwnProperty(\"apple_critical_alert_options\") && (this.appleCriticalAlertOptions = new l(t.apple_critical_alert_options));\n      }\n    }, {\n      key: \"isOpenChannel\",\n      value: function value() {\n        var e = x.get(this._iid).BaseChannel;\n        return this._channelType === e.CHANNEL_TYPE_OPEN;\n      }\n    }, {\n      key: \"isGroupChannel\",\n      value: function value() {\n        var e = x.get(this._iid).BaseChannel;\n        return this._channelType === e.CHANNEL_TYPE_GROUP;\n      }\n    }, {\n      key: \"metaArray\",\n      get: function get() {\n        var e = {};\n        return this.metaArrays.forEach(function (t) {\n          e[t.key] = t.value;\n        }), e;\n      },\n      set: function set(e) {\n        if (\"object\" === u(e) && e) {\n          var t = x.get(this._iid).MessageMetaArray,\n              n = [];\n          Object.keys(e).forEach(function (r) {\n            n.push(new t(r, e[r]));\n          }), this.metaArrays = n;\n        }\n      }\n    }], [{\n      key: \"Status\",\n      get: function get() {\n        return {\n          SCHEDULED: \"scheduled\",\n          SENT: \"sent\",\n          CANCELED: \"canceled\",\n          FAILED: \"failed\"\n        };\n      }\n    }]), e;\n  }(),\n      Ur = function () {\n    function e() {\n      this.threadInfo = null, this.targetMessageId = 0, this.channelUrl = null, this.channelType = null;\n    }\n\n    return e.createFromJson = function (e) {\n      var t = x.get(this._iid),\n          n = t.BaseChannel,\n          r = t.ThreadInfo,\n          i = e.thread_info,\n          s = e.root_message_id,\n          a = e.channel_url,\n          o = e.channel_type;\n\n      if (i && \"object\" == typeof i && (\"string\" == typeof s || \"number\" == typeof s) && \"string\" == typeof a && \"string\" == typeof o && [n.CHANNEL_TYPE_GROUP, n.CHANNEL_TYPE_OPEN].includes(o)) {\n        var l = new this();\n        return l.threadInfo = new r(i), l.targetMessageId = parseInt(s + \"\"), l.channelUrl = a, l.channelType = o, l;\n      }\n\n      return null;\n    }, e;\n  }(),\n      Mr = function () {\n    function e() {\n      c(this, e), this.poll = null, this.status = null;\n    }\n\n    return h(e, null, [{\n      key: \"createFromJson\",\n      value: function value(e) {\n        var t = x.get(this._iid).Poll,\n            n = e.poll;\n\n        if (\"object\" === u(n)) {\n          var r = new this();\n          return r.poll = new t(n), r.status = n.status, r;\n        }\n\n        return null;\n      }\n    }]), e;\n  }(),\n      kr = function () {\n    function e() {\n      c(this, e), this.pollId = null, this.updatedVoteCounts = null, this.votedAt = null;\n    }\n\n    return h(e, null, [{\n      key: \"createFromJson\",\n      value: function value(e) {\n        var t = e.poll_id,\n            n = e.updated_vote_counts,\n            r = e.ts;\n\n        if (\"number\" == typeof t && Array.isArray(e.updated_vote_counts) && \"number\" == typeof r) {\n          var i = new this();\n          return i.pollId = t, i.updatedVoteCounts = n.map(function (e) {\n            return {\n              optionId: e.option_id,\n              voteCount: e.vote_count\n            };\n          }), i.votedAt = r, i;\n        }\n\n        return null;\n      }\n    }]), e;\n  }(),\n      Rr = function () {\n    function e() {\n      c(this, e), this.isLoading = !1, this.hasNext = !0, this.limit = 20, this.userIdsFilter = [], this.metaDataKeyFilter = \"\", this.metaDataValuesFilter = [], this.nicknameStartsWithFilter = null, this._token = \"\";\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          \"number\" == typeof t.limit && t.limit > 0 && Array.isArray(t.userIdsFilter) && \"string\" == typeof t.metaDataKeyFilter && Array.isArray(t.metaDataValuesFilter) && !!t.metaDataKeyFilter == t.metaDataValuesFilter.length > 0 && (\"string\" == typeof t.nicknameStartsWithFilter || null === t.nicknameStartsWithFilter) ? t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? (t.isLoading = !0, U.get(t._iid).container.apiClient.loadUserList(l(l({}, t), {}, {\n            token: t._token\n          }), function (n, r) {\n            var i = null;\n\n            if (!n) {\n              var s = x.get(t._iid).User,\n                  a = String(r.next);\n              t._token = a, t.hasNext = !!a, i = r.users.map(function (e) {\n                return new s(e);\n              });\n            }\n\n            t.isLoading = !1, e(n, i);\n          })) : e(null, []) : e(me.error, null);\n        }, e);\n      }\n    }]), e;\n  }(),\n      Lr = function () {\n    function e(t) {\n      c(this, e), this.isLoading = !1, this.hasNext = !0, this.limit = 20, this._isOpenChannel = !1, this._channelUrl = null, this._token = \"\", t.channelUrl && (this._channelUrl = t.channelUrl), t.isOpenChannel && (this._isOpenChannel = t.isOpenChannel);\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          \"number\" == typeof t.limit && t.limit > 0 ? t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? (t.isLoading = !0, U.get(t._iid).container.apiClient.loadBannedUserList(l(l({}, t), {}, {\n            channelUrl: t._channelUrl,\n            isOpenChannel: t._isOpenChannel,\n            token: t._token\n          }), function (n, r) {\n            var i = null;\n\n            if (!n) {\n              var s = x.get(t._iid).RestrictedUser,\n                  a = String(r.next);\n              t._token = a, t.hasNext = !!a, i = r.banned_list.map(function (e) {\n                var t = new s(e);\n                return t.restrictionInfo.restrictionType = s.RestrictionType.BANNED, t;\n              });\n            }\n\n            t.isLoading = !1, e(n, i);\n          })) : e(null, []) : e(me.error, null);\n        }, e);\n      }\n    }]), e;\n  }(),\n      Pr = function () {\n    function e() {\n      c(this, e), this.isLoading = !1, this.hasNext = !0, this.limit = 20, this.userIdsFilter = [], this._token = \"\";\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          \"number\" == typeof t.limit && t.limit > 0 && Array.isArray(t.userIdsFilter) ? t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? (t.isLoading = !0, U.get(t._iid).container.apiClient.loadBlockedUserList(l(l({}, t), {}, {\n            token: t._token\n          }), function (n, r) {\n            var i = null;\n\n            if (!n) {\n              var s = x.get(t._iid).User,\n                  a = String(r.next);\n              t._token = a, t.hasNext = !!a, i = r.users.map(function (e) {\n                return new s(e);\n              });\n            }\n\n            t.isLoading = !1, e(n, i);\n          })) : e(null, []) : e(me.error, null);\n        }, e);\n      }\n    }]), e;\n  }(),\n      wr = function () {\n    function e() {\n      c(this, e), this.isLoading = !1, this.hasMore = !0, this.limit = 20, this._token = \"\";\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          \"number\" == typeof t.limit && t.limit > 0 ? t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasMore ? (t.isLoading = !0, U.get(t._iid).container.apiClient.loadFriendList(l(l({}, t), {}, {\n            token: t._token\n          }), function (n, r) {\n            var i = null;\n\n            if (!n) {\n              var s = x.get(t._iid).User,\n                  a = String(r.next);\n              t._token = a, t.hasMore = !!a, i = r.users.map(function (e) {\n                return new s(e);\n              });\n            }\n\n            t.isLoading = !1, e(n, i);\n          })) : e(null, []) : e(me.error, null);\n        }, e);\n      }\n    }]), e;\n  }(),\n      Dr = function () {\n    function e() {\n      c(this, e), this.isLoading = !1, this.hasNext = !0, this.limit = 20, this.includeEmpty = !1, this.order = e.ORDER_LATEST_LAST_MESSAGE, this._token = \"\", this._searchFilter = {}, this._userIdsFilter = {\n        userIds: [],\n        includeMode: !0,\n        queryType: e.QueryType.AND\n      }, this._userIdsExactFilter = [], this._userIdsIncludeFilter = [], this._userIdsIncludeFilterQueryType = e.QueryType.AND, this.nicknameContainsFilter = \"\", this.nicknameStartsWithFilter = \"\", this.nicknameExactMatchFilter = \"\", this.channelNameContainsFilter = \"\", this.memberStateFilter = ar.MemberStateFilter.ALL, this.customTypesFilter = [], this.channelUrlsFilter = [], this.superChannelFilter = ar.SuperChannelFilter.ALL, this.publicChannelFilter = ar.PublicChannelFilter.ALL, this.customTypeStartsWithFilter = null, this.unreadChannelFilter = ar.UnreadChannelFilter.ALL, this.metadataOrderKeyFilter = null, this.metadataKey = null, this.metadataValues = [], this.metadataValueStartsWith = null, this.hiddenChannelFilter = ar.HiddenChannelFilter.UNHIDDEN, this.includeFrozen = !0, this.includeMetaData = !0;\n    }\n\n    return h(e, [{\n      key: \"userIdsExactFilter\",\n      get: function get() {\n        return this._userIdsExactFilter;\n      },\n      set: function set(e) {\n        Array.isArray(e) && (this._userIdsExactFilter = e, this._userIdsIncludeFilter = [], this._userIdsFilter.userIds = this._userIdsExactFilter, this._userIdsFilter.includeMode = !1);\n      }\n    }, {\n      key: \"userIdsIncludeFilter\",\n      get: function get() {\n        return this._userIdsIncludeFilter;\n      },\n      set: function set(e) {\n        Array.isArray(e) && (this._userIdsIncludeFilter = e, this._userIdsExactFilter = [], this._userIdsFilter.userIds = this._userIdsIncludeFilter, this._userIdsFilter.includeMode = !0);\n      }\n    }, {\n      key: \"userIdsIncludeFilterQueryType\",\n      get: function get() {\n        return this._userIdsIncludeFilterQueryType;\n      },\n      set: function set(t) {\n        Object.keys(e.QueryType).map(function (t) {\n          return e.QueryType[t];\n        }).indexOf(t) > -1 && (this._userIdsIncludeFilterQueryType = t.toUpperCase(), this._userIdsFilter.queryType = this._userIdsIncludeFilterQueryType);\n      }\n    }, {\n      key: \"setSearchFilter\",\n      value: function value(e, t) {\n        Array.isArray(e) && 0 !== e.length && \"string\" == typeof t && t && (this._searchFilter = {\n          search_query: t,\n          search_fields: e.join(\",\").toLocaleLowerCase()\n        });\n      }\n    }, {\n      key: \"serialize\",\n      value: function value() {\n        return Nt.serialize(this, function (e) {\n          e.isLoading = !1;\n        });\n      }\n    }, {\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          var n = x.get(t._iid),\n              r = n.GroupChannel,\n              i = n.GroupChannelListQuery;\n          !(\"number\" == typeof t.limit && t.limit > 0 && \"boolean\" == typeof t.includeEmpty && \"string\" == typeof t.order && [i.ORDER_CHRONOLOGICAL, i.ORDER_LATEST_LAST_MESSAGE, i.CHANNEL_NAME_ALPHABETICAL, i.METADATA_VALUE_ALPHABETICAL].indexOf(t.order.toLowerCase()) > -1 && Array.isArray(t._userIdsExactFilter) && Array.isArray(t._userIdsIncludeFilter) && Array.isArray(t.customTypesFilter) && Array.isArray(t.channelUrlsFilter) && Object.keys(i.QueryType).map(function (e) {\n            return i.QueryType[e];\n          }).indexOf(t._userIdsIncludeFilterQueryType.toUpperCase()) > -1 && Object.keys(r.MemberStateFilter).map(function (e) {\n            return r.MemberStateFilter[e];\n          }).indexOf(t.memberStateFilter) > -1 && Object.keys(r.SuperChannelFilter).map(function (e) {\n            return r.SuperChannelFilter[e];\n          }).indexOf(t.superChannelFilter) > -1 && Object.keys(r.PublicChannelFilter).map(function (e) {\n            return r.PublicChannelFilter[e];\n          }).indexOf(t.publicChannelFilter) > -1 && Object.keys(r.UnreadChannelFilter).map(function (e) {\n            return r.UnreadChannelFilter[e];\n          }).indexOf(t.unreadChannelFilter) > -1 && Object.keys(r.HiddenChannelFilter).map(function (e) {\n            return r.HiddenChannelFilter[e];\n          }).indexOf(t.hiddenChannelFilter) > -1) || \"string\" != typeof t.customTypeStartsWithFilter && null !== t.customTypeStartsWithFilter || \"string\" != typeof t.nicknameContainsFilter || \"string\" != typeof t.nicknameStartsWithFilter || \"string\" != typeof t.nicknameExactMatchFilter || \"string\" != typeof t.channelNameContainsFilter || \"string\" != typeof t.metadataOrderKeyFilter && null !== t.metadataOrderKeyFilter || \"string\" != typeof t.metadataKey && null !== t.metadataKey || !Array.isArray(t.metadataValues) || !t.metadataValues.every(function (e) {\n            return \"string\" == typeof e;\n          }) || \"string\" != typeof t.metadataValueStartsWith && null !== t.metadataValueStartsWith || \"boolean\" != typeof t.includeFrozen || \"boolean\" != typeof t.includeMetaData ? e(me.error, null) : t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? (t.isLoading = !0, U.get(t._iid).container.apiClient.loadGroupChannelList(l(l({}, t), {}, {\n            token: t._token,\n            userIdsFilter: t._userIdsFilter,\n            searchFilter: t._searchFilter\n          })).then(function (n) {\n            var r = x.get(t._iid).GroupChannel,\n                i = String(n.next);\n            t._token = i, t.hasNext = !!i;\n            var s = n.channels;\n            if (!s || !Array.isArray(s)) throw new H(\"Failed at loading group channels.\", H.MALFORMED_DATA);\n            var a = s.map(function (e) {\n              return \"number\" == typeof n.ts && (e.ts = n.ts), r.upsert(e);\n            });\n            t.isLoading = !1, e(null, a);\n          }).catch(function (n) {\n            t.isLoading = !1, e(n, null);\n          })) : e(null, []);\n        }, e);\n      }\n    }], [{\n      key: \"ORDER_LATEST_LAST_MESSAGE\",\n      get: function get() {\n        return \"latest_last_message\";\n      }\n    }, {\n      key: \"ORDER_CHRONOLOGICAL\",\n      get: function get() {\n        return \"chronological\";\n      }\n    }, {\n      key: \"CHANNEL_NAME_ALPHABETICAL\",\n      get: function get() {\n        return \"channel_name_alphabetical\";\n      }\n    }, {\n      key: \"METADATA_VALUE_ALPHABETICAL\",\n      get: function get() {\n        return \"metadata_value_alphabetical\";\n      }\n    }, {\n      key: \"QueryType\",\n      get: function get() {\n        return {\n          AND: \"AND\",\n          OR: \"OR\"\n        };\n      }\n    }, {\n      key: \"SearchField\",\n      get: function get() {\n        return {\n          MEMBER_NICKNAME: \"member_nickname\",\n          CHANNEL_NAME: \"channel_name\"\n        };\n      }\n    }, {\n      key: \"buildFromSerializedData\",\n      value: function value(e) {\n        var t = x.get(this._iid).GroupChannel,\n            n = Nt.deserialize(e),\n            r = t.createMyGroupChannelListQuery();\n        return Object.keys(n).forEach(function (e) {\n          r.hasOwnProperty(e) && (r[e] = n[e]);\n        }), r;\n      }\n    }]), e;\n  }(),\n      Hr = function () {\n    function e(t) {\n      c(this, e), this.isLoading = !1, this.hasNext = !0, this.limit = 20, this.mutedMemberFilter = e.MutedMemberFilter.ALL, this.memberStateFilter = ar.MemberStateFilter.ALL, this.nicknameStartsWithFilter = null, this.order = e.Order.MEMBER_NICKNAME_ALPHABETICAL, this._token = \"\", this._channelUrl = t;\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          var n = x.get(t._iid),\n              r = n.GroupChannel,\n              i = n.Member,\n              s = n.MemberListQuery;\n          if (\"number\" == typeof t.limit && t.limit > 0 && Object.keys(s.MutedMemberFilter).map(function (e) {\n            return s.MutedMemberFilter[e];\n          }).indexOf(t.mutedMemberFilter) > -1 && Object.keys(r.MemberStateFilter).map(function (e) {\n            return r.MemberStateFilter[e];\n          }).indexOf(t.memberStateFilter) > -1 && Object.keys(s.Order).map(function (e) {\n            return s.Order[e];\n          }).indexOf(t.order) > -1 && (\"string\" == typeof t.nicknameStartsWithFilter || null === t.nicknameStartsWithFilter)) {\n            if (t.isLoading) e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null);else if (t.hasNext) {\n              t.isLoading = !0;\n              var a = U.get(t._iid);\n              t.memberStateFilter === r.MemberStateFilter.LEFT && (t.memberStateFilter = r.MemberStateFilter.ALL), a.container.apiClient.loadMemberList(l(l({}, t), {}, {\n                channelUrl: t._channelUrl,\n                token: t._token\n              }), function (n, r) {\n                var s = null;\n\n                if (!n) {\n                  var a = String(r.next);\n                  t._token = a, t.hasNext = !!a, s = r.members.map(function (e) {\n                    return new i(e);\n                  });\n                }\n\n                t.isLoading = !1, e(n, s);\n              });\n            } else e(null, []);\n          } else e(me.error, null);\n        }, e);\n      }\n    }], [{\n      key: \"MutedMemberFilter\",\n      get: function get() {\n        return {\n          ALL: \"all\",\n          MUTED: \"muted\",\n          UNMUTED: \"unmuted\"\n        };\n      }\n    }, {\n      key: \"Order\",\n      get: function get() {\n        return {\n          MEMBER_NICKNAME_ALPHABETICAL: \"member_nickname_alphabetical\",\n          OPERATOR_THEN_MEMBER_ALPHABETICAL: \"operator_then_member_alphabetical\"\n        };\n      }\n    }]), e;\n  }(),\n      Fr = function () {\n    function e(t) {\n      c(this, e), this.isLoading = !1, this.hasNext = !0, this.limit = 20, this._token = \"\", t.channelUrl && (this._channelUrl = t.channelUrl), t.isOpenChannel && (this._isOpenChannel = t.isOpenChannel);\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          \"number\" == typeof t.limit && t.limit > 0 ? t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? (t.isLoading = !0, U.get(t._iid).container.apiClient.loadMutedUserList(l(l({}, t), {}, {\n            channelUrl: t._channelUrl,\n            isOpenChannel: t._isOpenChannel,\n            token: t._token\n          }), function (n, r) {\n            var i = null;\n\n            if (!n) {\n              var s = x.get(t._iid).RestrictedUser,\n                  a = String(r.next);\n              t._token = a, t.hasNext = !!a, i = r.muted_list.map(function (e) {\n                var t = new s(e);\n                return t.restrictionInfo.restrictionType = s.RestrictionType.MUTED, t;\n              });\n            }\n\n            t.isLoading = !1, e(n, i);\n          })) : e(null, []) : e(me.error, null);\n        }, e);\n      }\n    }]), e;\n  }(),\n      Gr = function () {\n    function e() {\n      c(this, e), this.limit = 20, this.isLoading = !1, this.hasNext = !0, this.nameKeyword = null, this.urlKeyword = null, this.customTypes = [], this.includeFrozen = !0, this.includeMetaData = !0;\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          !(\"number\" == typeof t.limit && t.limit > 0 && Array.isArray(t.customTypes)) || \"string\" != typeof t.nameKeyword && null !== t.nameKeyword || \"string\" != typeof t.urlKeyword && null !== t.urlKeyword || \"boolean\" != typeof t.includeFrozen || \"boolean\" != typeof t.includeMetaData ? e(me.error, null) : t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? (t.isLoading = !0, U.get(t._iid).container.apiClient.loadOpenChannelList(l(l({}, t), {}, {\n            token: t._token\n          }), function (n, r) {\n            var i = null;\n\n            if (!n) {\n              var s = x.get(t._iid).OpenChannel,\n                  a = String(r.next);\n              t._token = a, t.hasNext = !!a;\n              var o = r.channels;\n              o && Array.isArray(o) ? i = o.map(function (e) {\n                return \"number\" == typeof r.ts && (e.ts = r.ts), s.upsert(e);\n              }) : n = new H(\"Failed at loading open channels.\", H.MALFORMED_DATA);\n            }\n\n            t.isLoading = !1, e(n, i);\n          })) : e(null, []);\n        }, e);\n      }\n    }]), e;\n  }(),\n      xr = new WeakMap(),\n      jr = function () {\n    function e(t) {\n      c(this, e), this.isLoading = !1, this.hasNext = !0, this.limit = 20, this._token = \"\", xr.set(this, t);\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          if (\"number\" == typeof t.limit && t.limit > 0) {\n            if (t.isLoading) e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null);else if (t.hasNext) {\n              t.isLoading = !0;\n              var n = xr.get(t);\n              U.get(t._iid).container.apiClient.loadOperatorList(l(l({}, t), {}, {\n                token: t._token,\n                channelUrl: n.url,\n                isOpenChannel: n.isOpenChannel()\n              }), function (n, r) {\n                var i = null;\n\n                if (!n) {\n                  var s = x.get(t._iid).User,\n                      a = String(r.next);\n                  t._token = a, t.hasNext = !!a, i = r.operators.map(function (e) {\n                    return new s(e);\n                  });\n                }\n\n                t.isLoading = !1, e(n, i);\n              });\n            } else e(null, []);\n          } else e(me.error, null);\n        }, e);\n      }\n    }]), e;\n  }(),\n      Br = new WeakMap(),\n      Vr = function () {\n    function e(t) {\n      c(this, e), this.isLoading = !1, this.hasNext = !0, this.limit = 20, this._token = \"\", t && Br.set(this, t.channelUrl);\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          \"number\" == typeof t.limit && t.limit > 0 ? t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? (t.isLoading = !0, U.get(t._iid).container.apiClient.loadParticipantList(l(l({}, t), {}, {\n            channelUrl: Br.get(t),\n            token: t._token\n          }), function (n, r) {\n            var i = null;\n\n            if (!n) {\n              var s = x.get(t._iid).User,\n                  a = String(r.next);\n              t._token = a, t.hasNext = !!a, i = r.participants.map(function (e) {\n                return new s(e);\n              });\n            }\n\n            t.isLoading = !1, e(n, i);\n          })) : e(null, []) : e(me.error, null);\n        }, e);\n      }\n    }]), e;\n  }(),\n      qr = new WeakMap(),\n      Kr = function () {\n    function e(t) {\n      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n          r = n.limit,\n          i = void 0 === r ? 20 : r,\n          s = n.reverse,\n          a = void 0 !== s && s,\n          o = n.exactMatch,\n          l = void 0 !== o && o,\n          u = n.channelUrl,\n          d = void 0 === u ? \"\" : u,\n          h = n.channelCustomType,\n          p = void 0 === h ? \"\" : h,\n          f = n.messageTimestampFrom,\n          _ = void 0 === f ? null : f,\n          g = n.messageTimestampTo,\n          y = void 0 === g ? null : g,\n          m = n.order,\n          E = void 0 === m ? \"score\" : m,\n          v = n.advancedQuery,\n          b = void 0 !== v && v,\n          C = n.targetFields,\n          A = void 0 === C ? null : C;\n\n      c(this, e), this.isLoading = !1, this.hasNext = !0, qr.set(this, {\n        keyword: t,\n        limit: i,\n        reverse: a,\n        exactMatch: l,\n        channelUrl: d,\n        channelCustomType: p,\n        messageTimestampFrom: _,\n        messageTimestampTo: y,\n        order: E,\n        advancedQuery: b,\n        targetFields: A,\n        previousToken: \"\",\n        nextToken: \"\"\n      });\n    }\n\n    return h(e, [{\n      key: \"key\",\n      get: function get() {\n        return qr.get(this).keyword;\n      }\n    }, {\n      key: \"limit\",\n      get: function get() {\n        return qr.get(this).limit;\n      }\n    }, {\n      key: \"reverse\",\n      get: function get() {\n        return qr.get(this).reverse;\n      }\n    }, {\n      key: \"exactMatch\",\n      get: function get() {\n        return qr.get(this).exactMatch;\n      }\n    }, {\n      key: \"channelUrl\",\n      get: function get() {\n        return qr.get(this).channelUrl;\n      }\n    }, {\n      key: \"channelCustomType\",\n      get: function get() {\n        return qr.get(this).channelCustomType;\n      }\n    }, {\n      key: \"messageTimestampFrom\",\n      get: function get() {\n        return qr.get(this).messageTimestampFrom;\n      }\n    }, {\n      key: \"messageTimestampTo\",\n      get: function get() {\n        return qr.get(this).messageTimestampTo;\n      }\n    }, {\n      key: \"order\",\n      get: function get() {\n        return qr.get(this).order;\n      }\n    }, {\n      key: \"next\",\n      value: function value(e) {\n        var t = this,\n            n = x.get(this._iid),\n            r = n.BaseChannel,\n            i = n.GroupChannel,\n            s = n.OpenChannel;\n        return oe(this._iid, function (e) {\n          var n = qr.get(t),\n              a = n.keyword,\n              o = n.limit,\n              l = n.reverse,\n              u = n.exactMatch,\n              c = n.channelUrl,\n              d = n.channelCustomType,\n              h = n.messageTimestampFrom,\n              p = n.messageTimestampTo,\n              f = n.order,\n              _ = n.advancedQuery,\n              g = n.targetFields,\n              y = n.nextToken;\n          !(\"number\" == typeof o && o > 0 && o <= 1e3 && \"boolean\" == typeof l && \"boolean\" == typeof u) || \"string\" != typeof c && null !== c || \"string\" != typeof d && null !== d || \"number\" != typeof h && null !== h || \"number\" != typeof p && null !== p || !([\"score\", \"ts\"].indexOf(f) >= 0) || \"boolean\" != typeof _ && null !== _ || !Array.isArray(g) && null !== g ? e(me.error, null) : t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? (t.isLoading = !0, U.get(t._iid).container.apiClient.searchMessages({\n            keyword: a,\n            limit: o,\n            reverse: l,\n            exactMatch: u,\n            channelUrl: c,\n            channelCustomType: d,\n            messageTimestampFrom: h,\n            messageTimestampTo: p,\n            order: f,\n            advancedQuery: _,\n            targetFields: g,\n            nextToken: y\n          }, function (n, a) {\n            var o = null;\n            n || (o = [], a.results.forEach(function (e) {\n              if (e.channel.hasOwnProperty(\"members\")) {\n                var t = new i(e.channel);\n                i.cachedChannels[t.url] = t, o.push(r.buildMessage(e, t));\n              } else {\n                var n = new s(e.channel);\n                s.cachedChannels[n.url] = n, o.push(r.buildMessage(e, n));\n              }\n            }), t.hasNext = a.has_next, qr.get(t).nextToken = a.end_cursor), t.isLoading = !1, e(n, o);\n          })) : e(null, []);\n        }, e);\n      }\n    }]), e;\n  }(),\n      zr = new WeakMap(),\n      Yr = new WeakMap(),\n      Qr = function () {\n    function e(t) {\n      c(this, e), this.isLoading = !1, this.hasMore = !0, this.limit = 20, Yr.set(this, Number.MAX_SAFE_INTEGER), zr.set(this, t), this.reverse = !1, this.messageTypeFilter = null, this.customTypeFilter = null, this.customTypesFilter = [], this.senderUserIdsFilter = [], this.includeMetaArray = !1, this.includeReaction = null, this.includeReactions = null, this.includeReplies = null, this.includeParentMessageText = null, this.includeThreadInfo = !1, this.replyType = null, this.includeParentMessageInfo = null, this.showSubchannelMessagesOnly = !1, this.includePollDetails = !1;\n    }\n\n    return h(e, [{\n      key: \"load\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = x.get(this._iid),\n            a = s.BaseChannel,\n            o = s.BaseMessage,\n            l = null,\n            u = me.parse(arguments, [new me({\n          type: \"number\",\n          optional: !0,\n          defaultValue: this.limit\n        }), new me({\n          type: \"boolean\",\n          optional: !0,\n          defaultValue: this.reverse\n        }), new me({\n          type: [\"string\", \"number\"],\n          optional: !0,\n          defaultValue: this.messageTypeFilter,\n          constraint: function constraint(e) {\n            return Object.keys(a.MessageTypeFilter).map(function (e) {\n              return a.MessageTypeFilter[e];\n            }).indexOf(e) > -1 || [0, 1, 2, 3].indexOf(e) > -1;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            c = C(u, 5);\n        return l = c[0], e = c[1], t = c[2], n = c[3], r = c[4], oe(this._iid, function (r) {\n          if ((\"string\" != typeof i.customTypeFilter && null !== i.customTypeFilter || !Array.isArray(i.customTypesFilter) || !i.customTypesFilter.every(function (e) {\n            return \"string\" == typeof e || null === e;\n          }) || !Array.isArray(i.senderUserIdsFilter) || !i.senderUserIdsFilter.every(function (e) {\n            return \"string\" == typeof e;\n          }) || \"boolean\" != typeof i.includeMetaArray || null !== i.includeReaction && \"boolean\" != typeof i.includeReaction || null !== i.includeReactions && \"boolean\" != typeof i.includeReactions || \"boolean\" != typeof i.includeThreadInfo || null !== i.includeReplies && \"boolean\" != typeof i.includeReplies || !(null === i.replyType || \"string\" == typeof i.replyType && Object.values(o.ReplyType).includes(i.replyType)) || null !== i.includeParentMessageText && \"boolean\" != typeof i.includeParentMessageText || null !== i.includeParentMessageInfo && \"boolean\" != typeof i.includeParentMessageInfo || \"boolean\" != typeof i.showSubchannelMessagesOnly) && (l = me.error), l) r(l, null);else {\n            if (i.limit = e, i.reverse = t, i.messageTypeFilter = n, \"number\" == typeof i.messageTypeFilter) switch (i.messageTypeFilter) {\n              case 0:\n                i.messageTypeFilter = a.MessageTypeFilter.ALL;\n                break;\n\n              case 1:\n                i.messageTypeFilter = a.MessageTypeFilter.USER;\n                break;\n\n              case 2:\n                i.messageTypeFilter = a.MessageTypeFilter.FILE;\n                break;\n\n              case 3:\n                i.messageTypeFilter = a.MessageTypeFilter.ADMIN;\n            }\n            if (i.isLoading) r(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null);else if (i.hasMore) {\n              i.isLoading = !0;\n              var s = zr.get(i);\n              U.get(i._iid).container.apiClient.getMessageList({\n                channel: s,\n                token: Yr.get(i) || new Date().getTime() + 1e4,\n                tokenType: \"timestamp\",\n                isInclusive: !1,\n                prevResultSize: e,\n                nextResultSize: 0,\n                shouldReverse: t,\n                messageType: i.messageTypeFilter,\n                customType: i.customTypeFilter,\n                customTypes: i.customTypesFilter,\n                senderUserIds: i.senderUserIdsFilter,\n                includeMetaArray: i.includeMetaArray,\n                includeReaction: i.includeReaction,\n                includeReactions: i.includeReactions,\n                includeReplies: i.includeReplies,\n                includeParentMessageText: i.includeParentMessageText,\n                includeThreadInfo: i.includeThreadInfo,\n                replyType: i.replyType,\n                includeParentMessageInfo: i.includeParentMessageInfo,\n                showSubchannelMessagesOnly: i.showSubchannelMessagesOnly,\n                includePollDetails: i.includePollDetails\n              }).then(function (t) {\n                var n = t.messages.map(function (e) {\n                  return a.buildMessage(e, s);\n                });\n                (0 === n.length || n.length < e) && (i.hasMore = !1);\n                var o = Yr.get(i);\n                Yr.set(i, Math.min.apply(Math, A(n.map(function (e) {\n                  return e.createdAt;\n                })).concat([o]))), i.isLoading = !1, r(null, n);\n              }).catch(function (e) {\n                i.isLoading = !1, r(e, null);\n              });\n            } else r(null, []);\n          }\n        }, r);\n      }\n    }]), e;\n  }(),\n      Wr = function () {\n    function e() {\n      c(this, e), this.isLoading = !1, this.hasNext = !0, this.limit = 20, this.includeEmpty = !1, this.order = Dr.ORDER_LATEST_LAST_MESSAGE, this._token = \"\", this.channelNameContainsFilter = \"\", this.channelUrlsFilter = [], this.customTypesFilter = [], this.customTypeStartsWithFilter = null, this.superChannelFilter = ar.SuperChannelFilter.ALL, this.membershipFilter = e.MembershipType.JOINED, this.metadataOrderKeyFilter = null, this.metadataKey = null, this.metadataValues = [], this.metadataValueStartsWith = null, this.includeFrozen = !0, this.includeMetaData = !0;\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(t) {\n        var n = this;\n        return oe(this._iid, function (t) {\n          var r = x.get(n._iid).GroupChannel;\n          !(\"number\" == typeof n.limit && n.limit > 0 && \"boolean\" == typeof n.includeEmpty && \"string\" == typeof n.order && [e.ORDER_CHRONOLOGICAL, e.CHANNEL_NAME_ALPHABETICAL, e.METADATA_VALUE_ALPHABETICAL, e.ORDER_LATEST_LAST_MESSAGE].indexOf(n.order.toLowerCase()) > -1 && Array.isArray(n.customTypesFilter) && Array.isArray(n.channelUrlsFilter) && Object.keys(e.MembershipType).map(function (t) {\n            return e.MembershipType[t];\n          }).indexOf(n.membershipFilter) > -1 && Object.keys(r.SuperChannelFilter).map(function (e) {\n            return r.SuperChannelFilter[e];\n          }).indexOf(n.superChannelFilter) > -1) || \"string\" != typeof n.customTypeStartsWithFilter && null !== n.customTypeStartsWithFilter || \"string\" != typeof n.channelNameContainsFilter || \"string\" != typeof n.metadataOrderKeyFilter && null !== n.metadataOrderKeyFilter || \"string\" != typeof n.metadataKey && null !== n.metadataKey || !Array.isArray(n.metadataValues) || !n.metadataValues.every(function (e) {\n            return \"string\" == typeof e;\n          }) || \"string\" != typeof n.metadataValueStartsWith && null !== n.metadataValueStartsWith || \"boolean\" != typeof n.includeFrozen || \"boolean\" != typeof n.includeMetaData ? t(me.error, null) : n.isLoading ? t(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : n.hasNext ? (n.isLoading = !0, U.get(n._iid).container.apiClient.loadPublicGroupChannelList(l(l({}, n), {}, {\n            token: n._token\n          }), function (e, i) {\n            var s = null;\n\n            if (!e) {\n              var a = String(i.next);\n              n._token = a, n.hasNext = !!a;\n              var o = i.channels;\n              o && Array.isArray(o) ? s = o.map(function (e) {\n                return \"number\" == typeof i.ts && (e.ts = i.ts), r.upsert(e);\n              }) : e = new H(\"Failed at loading group channels.\", H.MALFORMED_DATA);\n            }\n\n            n.isLoading = !1, t(e, s);\n          })) : t(null, []);\n        }, t);\n      }\n    }], [{\n      key: \"MembershipType\",\n      get: function get() {\n        return {\n          ALL: \"all\",\n          JOINED: \"joined\"\n        };\n      }\n    }, {\n      key: \"ORDER_LATEST_LAST_MESSAGE\",\n      get: function get() {\n        return \"latest_last_message\";\n      }\n    }, {\n      key: \"ORDER_CHRONOLOGICAL\",\n      get: function get() {\n        return \"chronological\";\n      }\n    }, {\n      key: \"CHANNEL_NAME_ALPHABETICAL\",\n      get: function get() {\n        return \"channel_name_alphabetical\";\n      }\n    }, {\n      key: \"METADATA_VALUE_ALPHABETICAL\",\n      get: function get() {\n        return \"metadata_value_alphabetical\";\n      }\n    }]), e;\n  }(),\n      Jr = new WeakMap(),\n      Xr = new WeakMap(),\n      Zr = function () {\n    function e() {\n      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n          n = t.channelUrl,\n          r = void 0 === n ? null : n,\n          i = t.token,\n          s = void 0 === i ? \"\" : i,\n          a = t.limit,\n          o = void 0 === a ? 20 : a;\n      c(this, e), this.channelUrl = r, this.token = s, this.limit = o, Jr.set(this, !1), Xr.set(this, !0);\n    }\n\n    return h(e, [{\n      key: \"isLoading\",\n      get: function get() {\n        return !!Jr.get(this);\n      }\n    }, {\n      key: \"hasNext\",\n      get: function get() {\n        return !!Xr.get(this);\n      }\n    }, {\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          \"string\" == typeof t.channelUrl && \"number\" == typeof t.limit && t.limit > 0 && t.limit <= 100 ? t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? (Jr.set(t, !0), U.get(t._iid).container.apiClient.getPollList(l({}, t), function (n, r) {\n            if (n) Jr.set(t, !1), e(n, null);else {\n              var i = x.get(t._iid).Poll,\n                  s = r.hasOwnProperty(\"polls\") && Array.isArray(r.polls) ? r.polls.map(function (e) {\n                return new i(e);\n              }) : [],\n                  a = r.hasOwnProperty(\"next\") && r.next ? String(r.next) : \"\";\n              t.token = a, Jr.set(t, !1), Xr.set(t, !!a), e(null, s);\n            }\n          })) : e(null, []) : e(me.error, null);\n        }, e);\n      }\n    }]), e;\n  }(),\n      $r = new WeakMap(),\n      ei = new WeakMap(),\n      ti = function () {\n    function e() {\n      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n          n = t.channelUrl,\n          r = void 0 === n ? null : n,\n          i = t.pollId,\n          s = void 0 === i ? null : i,\n          a = t.optionId,\n          o = void 0 === a ? null : a,\n          l = t.token,\n          u = void 0 === l ? \"\" : l,\n          d = t.limit,\n          h = void 0 === d ? 100 : d;\n      c(this, e), this.channelUrl = r, this.pollId = s, this.optionId = o, this.token = u, this.limit = h, $r.set(this, !1), ei.set(this, !0);\n    }\n\n    return h(e, [{\n      key: \"isLoading\",\n      get: function get() {\n        return !!$r.get(this);\n      }\n    }, {\n      key: \"hasNext\",\n      get: function get() {\n        return !!ei.get(this);\n      }\n    }, {\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          \"string\" == typeof t.channelUrl && \"number\" == typeof t.pollId && \"number\" == typeof t.optionId && \"number\" == typeof t.limit && t.limit > 0 && t.limit <= 100 ? t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? ($r.set(t, !0), U.get(t._iid).container.apiClient.getPollOptionVoterList(l({}, t), function (n, r) {\n            if (n) $r.set(t, !1), e(n, null);else {\n              var i = x.get(t._iid).User,\n                  s = r.hasOwnProperty(\"voters\") && Array.isArray(r.voters) ? r.voters.map(function (e) {\n                return new i(e);\n              }) : [],\n                  a = r.hasOwnProperty(\"next\") && r.next ? String(r.next) : \"\";\n              t.token = a, $r.set(t, !1), ei.set(t, !!a), e(null, s);\n            }\n          })) : e(null, []) : e(me.error, null);\n        }, e);\n      }\n    }]), e;\n  }(),\n      ni = function () {\n    function e() {\n      c(this, e), this.isDistinct = null, this.isSuper = null, this.isBroadcast = null, this.isPublic = null, this.channelUrl = null, this.isEphemeral = null, this.isDiscoverable = null, this.isStrict = null, this.name = null, this.data = null, this.customType = null, this.channelCover = null, this.coverUrl = null, this.coverImage = null, this.accessCode = null, this.messageSurvivalSeconds = null, this._invitedUserIds = [];\n      var t = null;\n      Object.defineProperty(this, \"operators\", {\n        set: function set(e) {\n          Array.isArray(e) && e.filter(function (e) {\n            return e.hasOwnProperty(\"userId\");\n          }).length === e.length && (t = e.map(function (e) {\n            return e.userId;\n          }));\n        }\n      }), Object.defineProperty(this, \"operatorUserIds\", {\n        get: function get() {\n          return t;\n        },\n        set: function set(e) {\n          Array.isArray(e) && e.filter(function (e) {\n            return \"string\" == typeof e;\n          }).length === e.length && (t = e);\n        }\n      });\n    }\n\n    return h(e, [{\n      key: \"_validate\",\n      value: function value() {\n        return Array.isArray(this._invitedUserIds) && this._invitedUserIds.every(function (e) {\n          return \"string\" == typeof e;\n        }) && (\"string\" == typeof this.channelUrl || null === this.channelUrl) && (\"string\" == typeof this.coverUrl || null === this.coverUrl) && (se.isFile(this.coverImage) || null === this.coverImage) && (\"string\" == typeof this.name || null === this.name) && (\"string\" == typeof this.data || null === this.data) && (\"string\" == typeof this.customType || null === this.customType) && (\"boolean\" == typeof this.isDistinct || null === this.isDistinct) && (\"boolean\" == typeof this.isSuper || null === this.isSuper) && (\"boolean\" == typeof this.isBroadcast || null === this.isBroadcast) && (\"boolean\" == typeof this.isPublic || null === this.isPublic) && (\"boolean\" == typeof this.isEphemeral || null === this.isEphemeral) && (\"boolean\" == typeof this.isDiscoverable || null === this.isDiscoverable) && (\"boolean\" == typeof this.isStrict || null === this.isStrict) && (Array.isArray(this.operatorUserIds) && this.operatorUserIds.every(function (e) {\n          return \"string\" == typeof e;\n        }) || null === this.operatorUserIds) && (\"string\" == typeof this.accessCode || null === this.accessCode) && (\"number\" == typeof this.messageSurvivalSeconds || null === this.messageSurvivalSeconds);\n      }\n    }, {\n      key: \"addUsers\",\n      value: function value(e) {\n        if (Array.isArray(e)) {\n          var t,\n              n = e.filter(function (e) {\n            return e.hasOwnProperty(\"userId\") && \"string\" == typeof e.userId;\n          }).map(function (e) {\n            return e.userId;\n          });\n\n          (t = this._invitedUserIds).push.apply(t, A(n));\n        }\n      }\n    }, {\n      key: \"addUser\",\n      value: function value(e) {\n        e.hasOwnProperty(\"userId\") && \"string\" == typeof e.userId && this._invitedUserIds.push(e.userId);\n      }\n    }, {\n      key: \"addUserIds\",\n      value: function value(e) {\n        if (Array.isArray(e)) {\n          var t,\n              n = e.filter(function (e) {\n            return \"string\" == typeof e;\n          });\n\n          (t = this._invitedUserIds).push.apply(t, A(n));\n        }\n      }\n    }, {\n      key: \"addUserId\",\n      value: function value(e) {\n        \"string\" == typeof e && this._invitedUserIds.push(e);\n      }\n    }]), e;\n  }(),\n      ri = function () {\n    function e() {\n      c(this, e), this.channelUrl = null, this.name = null, this.coverUrlOrImage = null, this.data = null, this.customType = null, this._operatorUserIds = [];\n    }\n\n    return h(e, [{\n      key: \"operatorUserIds\",\n      get: function get() {\n        return this._operatorUserIds;\n      },\n      set: function set(e) {\n        Array.isArray(e) && e.every(function (e) {\n          return \"string\" == typeof e;\n        }) && (this._operatorUserIds = e);\n      }\n    }, {\n      key: \"operators\",\n      set: function set(e) {\n        Array.isArray(e) && e.every(function (e) {\n          return e.hasOwnProperty(\"userId\");\n        }) && (this._operatorUserIds = e.map(function (e) {\n          return e.userId;\n        }));\n      }\n    }, {\n      key: \"_validate\",\n      value: function value() {\n        return (Array.isArray(this.operatorUserIds) && this.operatorUserIds.every(function (e) {\n          return \"string\" == typeof e;\n        }) || null === this.operatorUserIds) && (\"string\" == typeof this.coverUrlOrImage || se.isFile(this.coverUrlOrImage) || null === this.coverUrlOrImage) && (\"string\" == typeof this.name || null === this.name) && (\"string\" == typeof this.data || null === this.data) && (\"string\" == typeof this.customType || null === this.customType) && (\"string\" == typeof this.channelUrl && /^\\w+$/.test(this.channelUrl) || null === this.channelUrl);\n      }\n    }]), e;\n  }(),\n      ii = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n(e) {\n      var r;\n      return c(this, n), (r = t.call(this)).year = null, r.month = null, r.day = null, r.hour = null, r.min = null, r.timezone = null, r._scheduledDateTimeString = null, e && r._update(e), r;\n    }\n\n    return h(n, [{\n      key: \"scheduledDateTimeString\",\n      get: function get() {\n        return this._scheduledDateTimeString ? this._scheduledDateTimeString : \"number\" == typeof this.year && 4 === this.year.toString().length && \"number\" == typeof this.month && this.month >= 1 && this.month <= 12 && \"number\" == typeof this.day && this.day >= 1 && this.day <= 31 && \"number\" == typeof this.hour && this.hour >= 0 && this.hour <= 24 && \"number\" == typeof this.min && this.min >= 0 && this.min <= 60 && \"string\" == typeof this.timezone && this.timezone.length > 0 ? this.year.toString() + \"-\" + (\"0\" + this.month.toString()).substr(-2) + \"-\" + (\"0\" + this.day.toString()).substr(-2) + \" \" + (\"0\" + this.hour.toString()).substr(-2) + \":\" + (\"0\" + this.min.toString()).substr(-2) : null;\n      },\n      set: function set(e) {\n        e && \"string\" == typeof e && (this._scheduledDateTimeString = e);\n      }\n    }, {\n      key: \"_update\",\n      value: function value(e) {\n        e.hasOwnProperty(\"message\") && (this.message = e.message), e.hasOwnProperty(\"year\") && (this.year = e.year), e.hasOwnProperty(\"month\") && (this.month = e.month), e.hasOwnProperty(\"day\") && (this.day = e.day), e.hasOwnProperty(\"hour\") && (this.hour = e.hour), e.hasOwnProperty(\"min\") && (this.min = e.min), e.hasOwnProperty(\"timezone\") && (this.timezone = e.timezone);\n      }\n    }, {\n      key: \"_getScheduleString\",\n      value: function value() {\n        return this.scheduledDateTimeString ? this.scheduledDateTimeString + \" \" + this.timezone : \"number\" == typeof this.year && 4 === this.year.toString().length && \"number\" == typeof this.month && this.month >= 1 && this.month <= 12 && \"number\" == typeof this.day && this.day >= 1 && this.day <= 31 && \"number\" == typeof this.hour && this.hour >= 0 && this.hour <= 24 && \"number\" == typeof this.min && this.min >= 0 && this.min <= 60 && \"string\" == typeof this.timezone && this.timezone.length > 0 ? this.year.toString() + \"-\" + (\"0\" + this.month.toString()).substr(-2) + \"-\" + (\"0\" + this.day.toString()).substr(-2) + \" \" + (\"0\" + this.hour.toString()).substr(-2) + \":\" + (\"0\" + this.min.toString()).substr(-2) + \" \" + this.timezone : null;\n      }\n    }, {\n      key: \"setSchedule\",\n      value: function value(e, t, n, r, i, s) {\n        \"number\" == typeof e && 4 === e.toString().length && \"number\" == typeof t && t >= 1 && t <= 12 && \"number\" == typeof n && n >= 1 && n <= 31 && \"number\" == typeof r && r >= 0 && r <= 24 && \"number\" == typeof i && i >= 0 && i <= 60 && \"string\" == typeof s && s.length > 0 && (this.scheduledDateTimeString = e.toString() + \"-\" + (\"0\" + t.toString()).substr(-2) + \"-\" + (\"0\" + n.toString()).substr(-2) + \" \" + (\"0\" + r.toString()).substr(-2) + \":\" + (\"0\" + i.toString()).substr(-2), this.timezone = s);\n      }\n    }]), n;\n  }(Cr),\n      si = h(function e() {\n    c(this, e), this.channelCustomTypesFilter = [], this.superChannelFilter = ar.SuperChannelFilter.ALL;\n  }),\n      ai = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n() {\n      return c(this, n), t.call(this);\n    }\n\n    return h(n);\n  }(si),\n      oi = function (e) {\n    f(n, e);\n    var t = E(n);\n\n    function n() {\n      return c(this, n), t.call(this);\n    }\n\n    return h(n);\n  }(si),\n      li = function () {\n    function e() {\n      c(this, e), this.channelUrl = null, this.channelType = null, this.messageId = 0, this.includeMetaArray = !1, this.includeReactions = !1, this.includeParentMessageText = null, this.includeThreadInfo = !1, this.includeParentMessageInfo = null, this.includePollDetails = !1;\n    }\n\n    return h(e, [{\n      key: \"_validate\",\n      value: function value() {\n        var e = x.get(this._iid).BaseChannel;\n        return \"string\" == typeof this.channelUrl && \"string\" == typeof this.channelType && [e.CHANNEL_TYPE_BASE, e.CHANNEL_TYPE_OPEN, e.CHANNEL_TYPE_GROUP].includes(this.channelType) && \"number\" == typeof this.messageId && \"boolean\" == typeof this.includeMetaArray && \"boolean\" == typeof this.includeReactions && \"boolean\" == typeof this.includeThreadInfo && (null === this.includeParentMessageText || \"boolean\" == typeof this.includeParentMessageText) && (null === this.includeParentMessageInfo || \"boolean\" == typeof this.includeParentMessageInfo) && \"boolean\" == typeof this.includePollDetails;\n      }\n    }]), e;\n  }(),\n      ui = function () {\n    function e() {\n      c(this, e);\n      var t = x.get(this._iid).BaseChannel;\n      this.prevResultSize = 0, this.nextResultSize = 0, this.isInclusive = !1, this.reverse = !1, this.messageType = t.MessageTypeFilter.ALL, this.customType = null, this.customTypes = [], this.senderUserIds = null, this.includeMetaArray = !1, this.includeReaction = null, this.includeReactions = null, this.includeReplies = null, this.includeParentMessageText = null, this.includeThreadInfo = !1, this.replyType = null, this.includeParentMessageInfo = null, this.showSubchannelMessagesOnly = !1, this.includePollDetails = !1;\n    }\n\n    return h(e, [{\n      key: \"_validate\",\n      value: function value() {\n        var e = x.get(this._iid),\n            t = e.BaseChannel,\n            n = e.BaseMessage;\n        return \"number\" == typeof this.prevResultSize && \"number\" == typeof this.nextResultSize && \"boolean\" == typeof this.isInclusive && \"boolean\" == typeof this.reverse && \"string\" == typeof this.messageType && Object.values(t.MessageTypeFilter).includes(this.messageType) && (\"string\" == typeof this.customType || null === this.customType) && Array.isArray(this.customTypes) && this.customTypes.every(function (e) {\n          return \"string\" == typeof e || null === e;\n        }) && (Array.isArray(this.senderUserIds) && this.senderUserIds.every(function (e) {\n          return \"string\" == typeof e;\n        }) || null === this.senderUserIds) && \"boolean\" == typeof this.includeMetaArray && (null === this.includeReaction || \"boolean\" == typeof this.includeReaction) && (null === this.includeReactions || \"boolean\" == typeof this.includeReactions) && \"boolean\" == typeof this.includeThreadInfo && (null === this.includeReplies || \"boolean\" == typeof this.includeReplies) && (null === this.replyType || \"string\" == typeof this.replyType && Object.values(n.ReplyType).includes(this.replyType)) && (null === this.includeParentMessageText || \"boolean\" == typeof this.includeParentMessageText) && (null === this.includeParentMessageInfo || \"boolean\" == typeof this.includeParentMessageInfo) && \"boolean\" == typeof this.showSubchannelMessagesOnly && \"boolean\" == typeof this.includePollDetails;\n      }\n    }, {\n      key: \"belongsTo\",\n      value: function value(e) {\n        var t = x.get(this._iid),\n            n = t.BaseChannel,\n            r = t.UserMessageParams,\n            i = t.FileMessageParams,\n            s = t.BaseMessage;\n\n        if (this.messageType !== n.MessageTypeFilter.ALL) {\n          if (e instanceof r && this.messageType !== n.MessageTypeFilter.USER) return !1;\n          if (e instanceof i && this.messageType !== n.MessageTypeFilter.FILE) return !1;\n        }\n\n        if (Array.isArray(this.customTypes) && this.customTypes.length > 0 && !this.customTypes.includes(e.customType)) return !1;\n        if (\"string\" == typeof this.customType && this.customType !== e.customType) return !1;\n\n        if (Array.isArray(this.senderUserIds) && this.senderUserIds.length > 0) {\n          var a = ji.getInstance(e._iid);\n          if (!a || !a.currentUser || !this.senderUserIds.includes(a.currentUser.userId)) return !1;\n        }\n\n        if (\"string\" == typeof this.replyType && e.parentMessageId) {\n          if (this.replyType === s.ReplyType.NONE) return !1;\n          if (this.replyType === s.ReplyType.ONLY_REPLY_TO_CHANNEL && !e.isReplyToChannel) return !1;\n        } else if (!1 === this.includeReplies && e.parentMessageId) return !1;\n\n        return !0;\n      }\n    }]), e;\n  }(),\n      ci = function () {\n    function e() {\n      c(this, e);\n      var t = x.get(this._iid).BaseChannel;\n      this.prevResultSize = 0, this.nextResultSize = 0, this.isInclusive = !1, this.reverse = !1, this.messageType = t.MessageTypeFilter.ALL, this.customType = null, this.customTypes = [], this.senderUserIds = null, this.includeMetaArray = !1, this.includeReaction = null, this.includeReactions = null, this.includeParentMessageText = null, this.includeParentMessageInfo = null, this.includePollDetails = !1;\n    }\n\n    return h(e, [{\n      key: \"_validate\",\n      value: function value() {\n        var e = x.get(this._iid).BaseChannel;\n        return \"number\" == typeof this.prevResultSize && \"number\" == typeof this.nextResultSize && \"boolean\" == typeof this.isInclusive && \"boolean\" == typeof this.reverse && \"string\" == typeof this.messageType && Object.values(e.MessageTypeFilter).includes(this.messageType) && (\"string\" == typeof this.customType || null === this.customType) && Array.isArray(this.customTypes) && this.customTypes.every(function (e) {\n          return \"string\" == typeof e || null === e;\n        }) && (Array.isArray(this.senderUserIds) && this.senderUserIds.every(function (e) {\n          return \"string\" == typeof e;\n        }) || null === this.senderUserIds) && \"boolean\" == typeof this.includeMetaArray && (null === this.includeReaction || \"boolean\" == typeof this.includeReaction) && (null === this.includeReactions || \"boolean\" == typeof this.includeReactions) && (null === this.includeParentMessageText || \"boolean\" == typeof this.includeParentMessageText) && (null === this.includeParentMessageInfo || \"boolean\" == typeof this.includeParentMessageInfo) && \"boolean\" == typeof this.includePollDetails;\n      }\n    }]), e;\n  }(),\n      di = function () {\n    function e() {\n      c(this, e), this.includeMetaArray = !1, this.includeReaction = null, this.includeReactions = null, this.includeReplies = null, this.includeParentMessageText = null, this.includeThreadInfo = !1, this.replyType = null, this.includeParentMessageInfo = null, this.includePollDetails = !1;\n    }\n\n    return h(e, [{\n      key: \"_validate\",\n      value: function value() {\n        return \"boolean\" == typeof this.includeMetaArray && (null === this.includeReaction || \"boolean\" == typeof this.includeReaction) && (null === this.includeReactions || \"boolean\" == typeof this.includeReactions) && \"boolean\" == typeof this.includeThreadInfo && (null === this.includeReplies || \"boolean\" == typeof this.includeReplies) && (null === this.replyType || \"string\" == typeof this.replyType && Object.values(BaseMessage.ReplyType).includes(this.replyType)) && (null === this.includeParentMessageText || \"boolean\" == typeof this.includeParentMessageText) && (null === this.includeParentMessageInfo || \"boolean\" == typeof this.includeParentMessageInfo) && \"boolean\" == typeof this.includePollDetails;\n      }\n    }]), e;\n  }(),\n      hi = function () {\n    function e() {\n      c(this, e), this.customTypes = [], this.includeEmpty = !1, this.includeFrozen = !0;\n    }\n\n    return h(e, [{\n      key: \"_validate\",\n      value: function value() {\n        return (Array.isArray(this.customTypes) && this.customTypes.every(function (e) {\n          return \"string\" == typeof e;\n        }) || null === this.customTypes) && (\"boolean\" == typeof this.includeEmpty || null === this.includeEmpty) && \"boolean\" == typeof this.includeFrozen;\n      }\n    }]), e;\n  }(),\n      pi = function () {\n    function e() {\n      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n          n = t.title,\n          r = void 0 === n ? null : n,\n          i = t.options,\n          s = void 0 === i ? null : i,\n          a = t.data,\n          o = void 0 === a ? null : a,\n          l = t.isAnonymous,\n          u = void 0 === l ? null : l,\n          d = t.allowUserSuggestion,\n          h = void 0 === d ? null : d,\n          p = t.allowMultipleVotes,\n          f = void 0 === p ? null : p,\n          _ = t.closeAt,\n          g = void 0 === _ ? null : _;\n      c(this, e), this.title = r, this.options = s, this.data = o, this.isAnonymous = u, this.allowUserSuggestion = h, this.allowMultipleVotes = f, this.closeAt = g;\n    }\n\n    return h(e, [{\n      key: \"_validate\",\n      value: function value() {\n        return \"string\" == typeof this.title && (Array.isArray(this.options) && this.options.length > 0 && this.options.every(function (e) {\n          return \"string\" == typeof e;\n        }) || null === this.options) && (\"string\" == typeof this.data || null == this.data) && (\"boolean\" == typeof this.isAnonymous || null === this.isAnonymous) && (\"boolean\" == typeof this.allowUserSuggestion || null === this.allowUserSuggestion) && (\"boolean\" == typeof this.allowMultipleVotes || null === this.allowMultipleVotes) && (\"number\" == typeof this.closeAt || null === this.closeAt);\n      }\n    }]), e;\n  }(),\n      fi = function () {\n    function e() {\n      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n          n = t.channelUrl,\n          r = void 0 === n ? null : n,\n          i = t.pollId,\n          s = void 0 === i ? null : i,\n          a = t.showPartialVoters,\n          o = void 0 !== a && a;\n      c(this, e), this.channelUrl = r, this.pollId = s, this.showPartialVoters = o;\n    }\n\n    return h(e, [{\n      key: \"_validate\",\n      value: function value() {\n        return \"string\" == typeof this.channelUrl && \"number\" == typeof this.pollId && \"boolean\" == typeof this.showPartialVoters;\n      }\n    }]), e;\n  }(),\n      _i = function _i() {\n    this.onReconnectStarted = function () {}, this.onReconnectSucceeded = function () {}, this.onReconnectFailed = function () {};\n  },\n      gi = function gi() {\n    this.onFriendsDiscovered = function () {}, this.onTotalUnreadMessageCountUpdated = function () {};\n  },\n      yi = h(function e() {\n    c(this, e), this.onMessageReceived = function (e, t) {}, this.onMessageUpdated = function (e, t) {}, this.onMessageDeleted = function (e, t) {}, this.onReadReceiptUpdated = function (e) {}, this.onReactionUpdated = function (e, t) {}, this.onDeliveryReceiptUpdated = function (e) {}, this.onTypingStatusUpdated = function (e) {}, this.onUserJoined = function (e, t) {}, this.onUserLeft = function (e, t) {}, this.onOperatorUpdated = function (e, t) {}, this.onUserEntered = function (e, t) {}, this.onUserExited = function (e, t) {}, this.onUserMuted = function (e, t) {}, this.onUserUnmuted = function (e, t) {}, this.onUserBanned = function (e, t) {}, this.onUserUnbanned = function (e, t) {}, this.onChannelFrozen = function (e) {}, this.onChannelUnfrozen = function (e) {}, this.onChannelChanged = function (e) {}, this.onChannelDeleted = function (e, t) {}, this.onUserReceivedInvitation = function (e, t, n) {}, this.onUserDeclinedInvitation = function (e, t, n) {}, this.onMetaDataCreated = function (e, t) {}, this.onMetaDataUpdated = function (e, t) {}, this.onMetaDataDeleted = function (e, t) {}, this.onMetaCountersCreated = function (e, t) {}, this.onMetaCountersUpdated = function (e, t) {}, this.onMetaCountersDeleted = function (e, t) {}, this.onChannelHidden = function (e) {}, this.onMentionReceived = function (e, t) {}, this.onThreadInfoUpdated = function (e, t) {}, this.onChannelMemberCountChanged = function (e) {}, this.onChannelParticipantCountChanged = function (e) {}, this.onPollUpdated = function (e) {}, this.onPollVoted = function (e) {};\n  }),\n      mi = h(function e(t) {\n    if (c(this, e), t) {\n      var n = x.get(this._iid),\n          r = n.User,\n          i = n.BaseChannel;\n      this.reader = new r(t.user), this.timestamp = parseInt(t.ts), this.channelUrl = t.hasOwnProperty(\"channel_url\") ? String(t.channel_url) : \"\", this.channelType = t.hasOwnProperty(\"channel_type\") ? String(t.channel_type) : i.CHANNEL_TYPE_GROUP;\n    }\n  }),\n      Ei = function () {\n    function e(e) {\n      this.replyCount = 0, this.mostRepliedUsers = [], this.lastRepliedAt = 0, this.updatedAt = 0, e && this._update(e);\n    }\n\n    return e.objectify = function (e) {\n      var t = x.get(this._iid).User,\n          n = e.replyCount,\n          r = void 0 === n ? 0 : n,\n          i = e.mostRepliedUsers,\n          s = void 0 === i ? [] : i,\n          a = e.lastRepliedAt,\n          o = void 0 === a ? 0 : a,\n          l = e.updatedAt,\n          u = void 0 === l ? 0 : l,\n          c = {};\n      return c.reply_count = r, Array.isArray(s) && s.every(function (e) {\n        return e instanceof t;\n      }) && (c.most_replies = s.map(function (e) {\n        return t.objectify(e);\n      })), c.last_replied_at = o, c.updated_at = u, c;\n    }, e.build = function (e, t, n, r) {\n      return this.objectify({\n        replyCount: e,\n        mostRepliedUsers: t,\n        lastRepliedAt: n,\n        updatedAt: r\n      });\n    }, e.prototype._update = function (e) {\n      var t = x.get(this._iid).User;\n      e.hasOwnProperty(\"reply_count\") && (this.replyCount = parseInt(e.reply_count)), e.hasOwnProperty(\"most_replies\") && Array.isArray(e.most_replies) && e.most_replies.every(function (e) {\n        return \"object\" == typeof e;\n      }) && (this.mostRepliedUsers = e.most_replies.map(function (e) {\n        return new t(e);\n      })), e.hasOwnProperty(\"last_replied_at\") && (this.lastRepliedAt = parseInt(e.last_replied_at)), e.hasOwnProperty(\"updated_at\") && (this.updatedAt = parseInt(e.updated_at));\n    }, e;\n  }(),\n      vi = function () {\n    function e(e) {\n      this.title = null, this.url = null, this.description = null, this.defaultImage = null, e && this._update(e);\n    }\n\n    return e.objectify = function (e) {\n      var t = x.get(this._iid).OGImage,\n          n = e.title,\n          r = void 0 === n ? null : n,\n          i = e.url,\n          s = void 0 === i ? null : i,\n          a = e.description,\n          o = void 0 === a ? null : a,\n          l = e.defaultImage,\n          u = void 0 === l ? null : l,\n          c = {};\n      return c[\"og:title\"] = r, c[\"og:url\"] = s, c[\"og:description\"] = o, u && (c[\"og:image\"] = t.objectify(u)), c;\n    }, e.prototype._update = function (e) {\n      var t = x.get(this._iid).OGImage;\n      e.hasOwnProperty(\"og:title\") && (this.title = e[\"og:title\"]), e.hasOwnProperty(\"og:url\") && (this.url = e[\"og:url\"]), e.hasOwnProperty(\"og:description\") && (this.description = e[\"og:description\"]), e.hasOwnProperty(\"og:image\") && (this.defaultImage = new t(e[\"og:image\"]));\n    }, e;\n  }(),\n      bi = function () {\n    function e(e) {\n      this.url = null, this.secureUrl = null, this.type = null, this.width = 0, this.height = 0, this.alt = null, e && this._update(e);\n    }\n\n    return e.objectify = function (e) {\n      var t = e.url,\n          n = void 0 === t ? null : t,\n          r = e.secureUrl,\n          i = void 0 === r ? null : r,\n          s = e.type,\n          a = void 0 === s ? null : s,\n          o = e.width,\n          l = void 0 === o ? 0 : o,\n          u = e.height,\n          c = void 0 === u ? 0 : u,\n          d = e.alt,\n          h = void 0 === d ? null : d,\n          p = {};\n      return p.url = n, p.secure_url = i, p.type = a, p.width = l, p.height = c, p.alt = h, p;\n    }, e.prototype._update = function (e) {\n      e.hasOwnProperty(\"url\") && (this.url = e.url), e.hasOwnProperty(\"secure_url\") && (this.secureUrl = e.secure_url), e.hasOwnProperty(\"type\") && (this.type = e.type), e.hasOwnProperty(\"width\") && (this.width = parseInt(e.width)), e.hasOwnProperty(\"height\") && (this.height = parseInt(e.height)), e.hasOwnProperty(\"alt\") && (this.alt = e.alt);\n    }, e;\n  }(),\n      Ci = function () {\n    function e(e) {\n      this.type = null, this.vendor = null, this.detail = {}, e && this._update(e);\n    }\n\n    return e.objectify = function (e) {\n      var t = e.type,\n          n = void 0 === t ? \"\" : t,\n          r = e.vendor,\n          i = void 0 === r ? \"\" : r,\n          s = e.detail,\n          a = void 0 === s ? {} : s,\n          o = {};\n      return o.type = n, o.vendor = i, o.detail = a, o;\n    }, e.prototype._update = function (e) {\n      this.type = e.hasOwnProperty(\"type\") ? e.type : \"\", this.vendor = e.hasOwnProperty(\"vendor\") ? e.vendor : \"\", e.hasOwnProperty(\"detail\") && \"object\" == typeof e.detail && !Array.isArray(e.detail) && (this.detail = e.detail);\n    }, e;\n  }(),\n      Ai = function () {\n    function e(t) {\n      c(this, e), this.id = 0, this.title = \"\", this.details = null, this._update(t);\n    }\n\n    return h(e, [{\n      key: \"update\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.PollParams,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: i,\n          constraint: function constraint(e) {\n            return e._validate();\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 3);\n        return s = o[0], e = o[1], t = o[2], oe(this._iid, function (t) {\n          if (s) t(s, null);else {\n            var r = {\n              text: e.data\n            };\n            U.get(n._iid).container.apiClient.updatePoll(l(l({\n              pollId: n.id\n            }, e), {}, {\n              data: r\n            }), function (e, r) {\n              if (e) t(e, null);else {\n                var i = new (0, x.get(n._iid).Poll)(r);\n                t(null, i);\n              }\n            });\n          }\n        }, t);\n      }\n    }, {\n      key: \"delete\",\n      value: function value(e) {\n        var t = this,\n            n = null,\n            r = me.parse(arguments, [new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 2);\n        return n = i[0], e = i[1], oe(this._iid, function (e) {\n          n ? e(n, null) : U.get(t._iid).container.apiClient.deletePoll({\n            pollId: t.id\n          }, function (t, n) {\n            e(t || null, null);\n          });\n        }, e);\n      }\n    }, {\n      key: \"addOption\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return i = a[0], e = a[1], t = a[2], n = a[3], oe(this._iid, function (n) {\n          i ? n(i, null) : U.get(r._iid).container.apiClient.addPollOption({\n            channelUrl: e,\n            pollId: r.id,\n            text: t\n          }, function (e, t) {\n            if (e) n(e, null);else {\n              var i = new (0, x.get(r._iid).Poll)(t);\n              n(null, i);\n            }\n          });\n        }, n);\n      }\n    }, {\n      key: \"vote\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return \"number\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return i = a[0], e = a[1], t = a[2], n = a[3], oe(this._iid, function (n) {\n          i ? n(i, null) : U.get(r._iid).container.apiClient.votePoll({\n            channelUrl: e,\n            pollId: r.id,\n            optionIds: t\n          }, function (e, t) {\n            if (e) n(e, null);else {\n              var i = new (0, x.get(r._iid).Poll)(t);\n              n(null, i);\n            }\n          });\n        }, n);\n      }\n    }, {\n      key: \"close\",\n      value: function value(e) {\n        var t = this,\n            n = null,\n            r = me.parse(arguments, [new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 2);\n        return n = i[0], e = i[1], oe(this._iid, function (e) {\n          n ? e(n, null) : U.get(t._iid).container.apiClient.closePoll({\n            pollId: t.id\n          }, function (n, r) {\n            if (n) e(n, null);else {\n              var i = new (0, x.get(t._iid).Poll)(r);\n              e(null, i);\n            }\n          });\n        }, e);\n      }\n    }, {\n      key: \"_update\",\n      value: function value(e) {\n        var t = x.get(this._iid).PollDetails;\n        this.id = parseInt(e.id), this.title = e.title, e.hasOwnProperty(\"options\") && e.hasOwnProperty(\"is_anonymous\") && e.hasOwnProperty(\"allow_user_suggestion\") && e.hasOwnProperty(\"allow_multiple_votes\") && e.hasOwnProperty(\"close_at\") && e.hasOwnProperty(\"voter_count\") && e.hasOwnProperty(\"status\") && e.hasOwnProperty(\"created_by\") && e.hasOwnProperty(\"created_at\") && e.hasOwnProperty(\"updated_at\") && (this.details = new t(e));\n      }\n    }], [{\n      key: \"Status\",\n      get: function get() {\n        return {\n          OPEN: \"open\",\n          CLOSED: \"closed\",\n          REMOVED: \"removed\"\n        };\n      }\n    }, {\n      key: \"objectify\",\n      value: function value(e) {\n        var t = x.get(this._iid).PollDetails,\n            n = e.id,\n            r = void 0 === n ? 0 : n,\n            i = e.title,\n            s = void 0 === i ? \"\" : i,\n            a = e.details,\n            o = void 0 === a ? null : a,\n            u = l({}, o ? t.objectify(o) : {});\n        return u.id = r, u.title = s, u;\n      }\n    }, {\n      key: \"get\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.PollRetrievalParams,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: i,\n          constraint: function constraint(e) {\n            return e._validate();\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 3);\n        return s = o[0], e = o[1], t = o[2], oe(this._iid, function (t) {\n          s ? t(s, null) : U.get(n._iid).container.apiClient.getPoll(l({}, e), function (e, r) {\n            if (e) t(e, null);else {\n              var i = new (0, x.get(n._iid).Poll)(r);\n              t(null, i);\n            }\n          });\n        }, t);\n      }\n    }, {\n      key: \"create\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.PollParams,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: i,\n          constraint: function constraint(e) {\n            return e._validate();\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 3);\n        return s = o[0], e = o[1], t = o[2], oe(this._iid, function (t) {\n          if (s) t(s, null);else {\n            var r = {\n              text: e.data\n            };\n            U.get(n._iid).container.apiClient.createPoll(l(l({}, e), {}, {\n              data: r\n            }), function (e, r) {\n              if (e) t(e, null);else {\n                var i = new (0, x.get(n._iid).Poll)(r);\n                t(null, i);\n              }\n            });\n          }\n        }, t);\n      }\n    }]), e;\n  }(),\n      Ni = function () {\n    function e(t) {\n      c(this, e), this.options = [], this.data = null, this.isAnonymous = !1, this.allowUserSuggestion = !1, this.allowMultipleVotes = !1, this.closeAt = -1, this.voterCount = 0, this.votedOptionIds = [], this.status = \"\", this.createdBy = null, this.createdAt = 0, this.updatedAt = 0, this._update(t);\n    }\n\n    return h(e, [{\n      key: \"_update\",\n      value: function value(e) {\n        var t = x.get(this._iid).PollOption;\n        e.hasOwnProperty(\"options\") && Array.isArray(e.options) && (this.options = e.options.map(function (e) {\n          return new t(e);\n        }));\n\n        try {\n          this.data = JSON.parse(e.data);\n        } catch (t) {\n          this.data = e.data;\n        }\n\n        this.isAnonymous = !!e.hasOwnProperty(\"is_anonymous\") && e.is_anonymous, this.allowUserSuggestion = !!e.hasOwnProperty(\"allow_user_suggestion\") && e.allow_user_suggestion, this.allowMultipleVotes = !!e.hasOwnProperty(\"allow_multiple_votes\") && e.allow_multiple_votes, this.closeAt = parseInt(e.close_at), this.voterCount = parseInt(e.voter_count), e.hasOwnProperty(\"voted_option_ids\") && Array.isArray(e.voted_option_ids) && (this.votedOptionIds = e.voted_option_ids.map(function (e) {\n          return parseInt(e);\n        })), this.status = e.status, this.createdBy = e.created_by, this.createdAt = parseInt(e.created_at), this.updatedAt = parseInt(e.updated_at);\n      }\n    }], [{\n      key: \"objectify\",\n      value: function value(e) {\n        var t = x.get(this._iid).PollOption,\n            n = e.options,\n            r = void 0 === n ? [] : n,\n            i = e.data,\n            s = void 0 === i ? null : i,\n            a = e.isAnonymous,\n            o = void 0 !== a && a,\n            l = e.allowUserSuggestion,\n            u = void 0 !== l && l,\n            c = e.allowMultipleVotes,\n            d = void 0 !== c && c,\n            h = e.closeAt,\n            p = void 0 === h ? -1 : h,\n            f = e.voterCount,\n            _ = void 0 === f ? 0 : f,\n            g = e.votedOptionIds,\n            y = void 0 === g ? [] : g,\n            m = e.status,\n            E = void 0 === m ? \"\" : m,\n            v = e.createdBy,\n            b = void 0 === v ? \"\" : v,\n            C = e.createdAt,\n            A = void 0 === C ? 0 : C,\n            N = e.updatedAt,\n            S = void 0 === N ? 0 : N,\n            I = {};\n\n        return I.options = r.map(function (e) {\n          return t.objectify(e);\n        }), I.data = JSON.stringify(s), I.is_anonymous = o, I.allow_user_suggestion = u, I.allow_multiple_votes = d, I.close_at = p, I.voter_count = _, I.voted_option_ids = y, I.status = E, I.created_by = b, I.created_at = A, I.updated_at = S, I;\n      }\n    }]), e;\n  }(),\n      Si = new WeakMap(),\n      Ii = function () {\n    function e(t) {\n      c(this, e), this.pollId = 0, this.id = 0, this.text = \"\", this.voteCount = 0, this.partialVoters = [], this.createdBy = \"\", this.createdAt = 0, this.updatedAt = 0, Si.set(this, null), this._update(t);\n    }\n\n    return h(e, [{\n      key: \"lastVotedAt\",\n      get: function get() {\n        return Si.get(this);\n      }\n    }, {\n      key: \"update\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.updatePollOption({\n            pollId: n.pollId,\n            optionId: n.id,\n            text: e\n          }, function (e, r) {\n            if (e) t(e, null);else {\n              var i = new (0, x.get(n._iid).Poll)(r);\n              t(null, i);\n            }\n          });\n        }, t);\n      }\n    }, {\n      key: \"delete\",\n      value: function value(e) {\n        var t = this,\n            n = null,\n            r = me.parse(arguments, [new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 2);\n        return n = i[0], e = i[1], oe(this._iid, function (e) {\n          n ? e(n, null) : U.get(t._iid).container.apiClient.deletePollOption({\n            pollId: t.pollId,\n            optionId: t.id\n          }, function (t, n) {\n            e(t || null, null);\n          });\n        }, e);\n      }\n    }, {\n      key: \"_applyEvent\",\n      value: function value(e) {\n        return this.id === e.optionId && this.lastVotedAt < e.votedAt && (this.voteCount = e.voteCount, Si.set(this, e.votedAt), !0);\n      }\n    }, {\n      key: \"_update\",\n      value: function value(e) {\n        var t = x.get(this._iid).User;\n        this.pollId = parseInt(e.poll_id), this.id = parseInt(e.id), this.text = e.text, this.voteCount = parseInt(e.vote_count), e.hasOwnProperty(\"partial_voter_list\") && Array.isArray(e.partial_voter_list) && (this.partialVoters = e.partial_voter_list.map(function (e) {\n          return new t(e);\n        })), this.createdBy = e.created_by, this.createdAt = parseInt(e.created_at), this.updatedAt = parseInt(e.updated_at);\n      }\n    }], [{\n      key: \"VoteAction\",\n      get: function get() {\n        return {\n          CAST: \"cast\",\n          CANCEL: \"cancel\"\n        };\n      }\n    }, {\n      key: \"objectify\",\n      value: function value(e) {\n        var t = x.get(this._iid).User,\n            n = e.pollId,\n            r = void 0 === n ? 0 : n,\n            i = e.id,\n            s = void 0 === i ? 0 : i,\n            a = e.text,\n            o = void 0 === a ? \"\" : a,\n            l = e.voteCount,\n            u = void 0 === l ? 0 : l,\n            c = e.partialVoters,\n            d = void 0 === c ? [] : c,\n            h = e.createdBy,\n            p = void 0 === h ? \"\" : h,\n            f = e.createdAt,\n            _ = void 0 === f ? 0 : f,\n            g = e.updatedAt,\n            y = void 0 === g ? 0 : g,\n            m = {};\n\n        return m.poll_id = r, m.id = s, m.text = o, m.vote_count = u, Array.isArray(d) && (m.partial_voter_list = d.filter(function (e) {\n          return e instanceof t;\n        }).map(function (e) {\n          return t.objectify(e);\n        })), m.created_by = p, m.created_at = _, m.updated_at = y, m;\n      }\n    }, {\n      key: \"get\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"number\"\n        }), new me({\n          type: \"number\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 5);\n        return s = o[0], e = o[1], t = o[2], n = o[3], r = o[4], oe(this._iid, function (r) {\n          s ? r(s, null) : U.get(i._iid).container.apiClient.getPollOption({\n            channelUrl: e,\n            pollId: t,\n            optionId: n\n          }, function (e, t) {\n            if (e) r(e, null);else {\n              var n = new (0, x.get(i._iid).PollOption)(t);\n              r(null, n);\n            }\n          });\n        }, r);\n      }\n    }]), e;\n  }(),\n      Ti = function () {\n    function e(t) {\n      c(this, e), this.restrictionType = null, this.description = null, this.endAt = -1, t && this._update(t);\n    }\n\n    return h(e, [{\n      key: \"_update\",\n      value: function value(e) {\n        e.hasOwnProperty(\"restriction_type\") && (this.restrictionType = e.restriction_type), e.hasOwnProperty(\"description\") ? this.description = e.description : e.hasOwnProperty(\"muted_description\") && (this.description = e.muted_description), e.hasOwnProperty(\"end_at\") ? this.endAt = parseInt(e.end_at) : e.hasOwnProperty(\"muted_end_at\") && (this.endAt = parseInt(e.muted_end_at));\n      }\n    }], [{\n      key: \"objectify\",\n      value: function value(e) {\n        var t = e.restrictionType,\n            n = void 0 === t ? null : t,\n            r = e.description,\n            i = void 0 === r ? null : r,\n            s = e.endAt,\n            a = void 0 === s ? -1 : s,\n            o = {};\n        return o.restriction_type = n, o.description = i, o.end_at = a, o;\n      }\n    }]), e;\n  }(),\n      Oi = function () {\n    function e() {\n      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];\n      c(this, e), this.isLoading = !1, this.hasNext = !0, this.limit = 20, this.userIds = t, this.metaDataKey = \"\", this.metaDataValues = [], this._token = \"\";\n    }\n\n    return h(e, [{\n      key: \"next\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          \"number\" == typeof t.limit && t.limit > 0 && Array.isArray(t.userIds) && \"string\" == typeof t.metaDataKey && Array.isArray(t.metaDataValues) && !!t.metaDataKey == t.metaDataValues.length > 0 ? t.isLoading ? e(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null) : t.hasNext ? (t.isLoading = !0, U.get(t._iid).container.apiClient.loadUserList(l(l({}, t), {}, {\n            userIdsFilter: t.userIds,\n            metaDataKeyFilter: t.metaDataKey,\n            metaDataValuesFilter: t.metaDataValues,\n            token: t._token\n          }), function (n, r) {\n            var i = null;\n\n            if (!n) {\n              var s = x.get(t._iid).User,\n                  a = String(r.next);\n              t._token = a, t.hasNext = !!a, i = r.users.map(function (e) {\n                return new s(e);\n              });\n            }\n\n            t.isLoading = !1, e(n, i);\n          })) : e(null, []) : e(me.error, null);\n        }, e);\n      }\n    }]), e;\n  }(),\n      Ui = new WeakMap(),\n      Mi = function () {\n    function e(t) {\n      c(this, e), this.isLoading = !1, Ui.set(this, t);\n    }\n\n    return h(e, [{\n      key: \"prev\",\n      value: function value(e, t, n, r) {\n        var i = arguments,\n            s = this;\n        return oe(this._iid, function (r) {\n          var a,\n              o = x.get(s._iid).BaseChannel,\n              l = C(me.parse(i, [new me({\n            type: \"number\"\n          }), new me({\n            type: \"number\"\n          }), new me({\n            type: \"boolean\"\n          }), new me({\n            type: \"function\"\n          })]), 5);\n          if (a = l[0], e = l[1], t = l[2], n = l[3], r = l[4], a) r(a, null);else if (s.isLoading) r(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null);else {\n            s.isLoading = !0;\n            var u = Ui.get(s);\n            U.get(s._iid).container.apiClient.getMessageList({\n              channelUrl: u.url,\n              channelType: u.channelType,\n              token: e,\n              tokenType: \"timestamp\",\n              isInclusive: !1,\n              prevResultSize: t,\n              nextResultSize: 0,\n              shouldReverse: n,\n              messageType: \"\",\n              customType: \"\"\n            }).then(function (e) {\n              var t = e.messages.map(function (e) {\n                return o.buildMessage(e, u);\n              });\n              s.isLoading = !1, r(null, t);\n            }).catch(function (e) {\n              s.isLoading = !1, r(e, null);\n            });\n          }\n        }, r);\n      }\n    }, {\n      key: \"next\",\n      value: function value(e, t, n, r) {\n        var i = arguments,\n            s = this;\n        return oe(this._iid, function (r) {\n          var a,\n              o = x.get(s._iid).BaseChannel,\n              l = C(me.parse(i, [new me({\n            type: \"number\"\n          }), new me({\n            type: \"number\"\n          }), new me({\n            type: \"boolean\"\n          }), new me({\n            type: \"function\"\n          })]), 5);\n          if (a = l[0], e = l[1], t = l[2], n = l[3], r = l[4], a) r(a, null);else if (s.isLoading) r(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null);else {\n            s.isLoading = !0;\n            var u = Ui.get(s);\n            U.get(s._iid).container.apiClient.getMessageList({\n              channelUrl: u.url,\n              channelType: u.channelType,\n              token: e,\n              tokenType: \"timestamp\",\n              isInclusive: !1,\n              prevResultSize: 0,\n              nextResultSize: t,\n              shouldReverse: n,\n              messageType: \"\",\n              customType: \"\"\n            }).then(function (e) {\n              var t = e.messages.map(function (e) {\n                return o.buildMessage(e, u);\n              });\n              s.isLoading = !1, r(null, t);\n            }).catch(function (e) {\n              s.isLoading = !1, r(e, null);\n            });\n          }\n        }, r);\n      }\n    }, {\n      key: \"load\",\n      value: function value(e, t, n, r, i) {\n        var s = arguments,\n            a = this;\n        return oe(this._iid, function (i) {\n          var o,\n              l = x.get(a._iid).BaseChannel,\n              u = C(me.parse(s, [new me({\n            type: \"number\"\n          }), new me({\n            type: \"number\"\n          }), new me({\n            type: \"number\"\n          }), new me({\n            type: \"boolean\"\n          }), new me({\n            type: \"callback\"\n          })]), 6);\n          if (o = u[0], e = u[1], t = u[2], n = u[3], r = u[4], i = u[5], o) i(o, null);else if (a.isLoading) i(new H(\"Query in progress.\", H.QUERY_IN_PROGRESS), null);else {\n            a.isLoading = !0;\n            var c = Ui.get(a);\n            U.get(a._iid).container.apiClient.getMessageList({\n              channelUrl: c.url,\n              channelType: c.channelType,\n              token: e,\n              tokenType: \"timestamp\",\n              isInclusive: !1,\n              prevResultSize: t,\n              nextResultSize: n,\n              shouldReverse: r,\n              messageType: \"\",\n              customType: \"\"\n            }).then(function (e) {\n              var t = e.messages.map(function (e) {\n                return l.buildMessage(e, c);\n              });\n              a.isLoading = !1, i(null, t);\n            }).catch(function (e) {\n              a.isLoading = !1, i(e, null);\n            });\n          }\n        }, i);\n      }\n    }]), e;\n  }(),\n      ki = 0,\n      Ri = 1,\n      Li = 2,\n      Pi = function () {\n    function e(t) {\n      var n = this;\n      c(this, e), this.state = ki, this._value = null, this._reason = null;\n\n      var r = function r(e) {\n        n.state === ki && (n.state = Li, n._reason = e);\n      };\n\n      if (\"function\" != typeof t) throw \"Promise resolver \".concat(t, \" is not a function\");\n\n      try {\n        t(function (e) {\n          n.state === ki && (n.state = Ri, n._value = e);\n        }, r);\n      } catch (e) {\n        r(e);\n      }\n    }\n\n    return h(e, [{\n      key: \"length\",\n      get: function get() {\n        return 1;\n      }\n    }, {\n      key: \"then\",\n      value: function value(t, n) {\n        var r = this,\n            i = this;\n\n        switch (this.state) {\n          case ki:\n            setTimeout(function () {\n              return r.then(t, n);\n            }, 2);\n            break;\n\n          case Ri:\n            t && \"function\" == typeof t && (i = t(this._value));\n            break;\n\n          case Li:\n            n && \"function\" == typeof n && (i = n(this._reason));\n        }\n\n        return i instanceof e ? i : this;\n      }\n    }, {\n      key: \"catch\",\n      value: function value(t) {\n        var n = this,\n            r = this;\n\n        switch (this.state) {\n          case ki:\n            setTimeout(function () {\n              return n.catch(t);\n            }, 2);\n            break;\n\n          case Ri:\n            break;\n\n          case Li:\n            r = t(this._reason);\n        }\n\n        return r instanceof e ? r : this;\n      }\n    }, {\n      key: \"finally\",\n      value: function value(t) {\n        var n = this,\n            r = this;\n\n        switch (this.state) {\n          case ki:\n            setTimeout(function () {\n              return n.finally(t);\n            }, 2);\n            break;\n\n          case Ri:\n          case Li:\n            r = t();\n        }\n\n        return r instanceof e ? r : this;\n      }\n    }], [{\n      key: \"all\",\n      value: function value(t) {\n        return new e(function (n, r) {\n          if (Array.isArray(t) || \"string\" == typeof t) {\n            if (t.length > 0) {\n              for (var i = [], s = 0; s < t.length; s++) {\n                t[s] instanceof e ? i.push(t[s]) : i.push(e.resolve(t[s]));\n              }\n\n              var a = new Array(i.length).fill(null),\n                  o = i.length,\n                  l = function l(e, t, i) {\n                t ? r(t) : (o--, a[e] = i, o <= 0 && n(a));\n              };\n\n              i.forEach(function (e, t) {\n                e.then(function (e) {\n                  l(t, null, e);\n                }).catch(function (e) {\n                  l(t, e, null);\n                });\n              });\n            } else n([]);\n          } else r(new Error(\"Uncaught (in promise) TypeError: \".concat(u(t), \" \").concat(t, \" is not iterable\")));\n        });\n      }\n    }, {\n      key: \"resolve\",\n      value: function value(t) {\n        return new e(function (n, r) {\n          t instanceof e ? t.then(function (t) {\n            return e.resolve(t);\n          }).catch(function (e) {\n            return r(e);\n          }) : n(t);\n        });\n      }\n    }, {\n      key: \"reject\",\n      value: function value(t) {\n        return new e(function (e, n) {\n          n(t);\n        });\n      }\n    }]), e;\n  }(),\n      wi = function wi() {\n    \"undefined\" != typeof Promise && Promise.prototype.finally || (\"undefined\" != typeof window ? window.Promise = Pi : \"undefined\" != typeof global ? global.Promise = Pi : \"undefined\" != typeof self ? self.Promise = Pi : \"undefined\" != typeof globalThis && (globalThis.Promise = Pi)), Object.values || (Object.values = function (e) {\n      return Object.keys(e).map(function (t) {\n        return e[t];\n      });\n    }), Number.MAX_SAFE_INTEGER || Object.defineProperty(Number, \"MAX_SAFE_INTEGER\", {\n      value: Math.pow(2, 53) - 1\n    });\n  },\n      Di = 3e5,\n      Hi = null,\n      Fi = {},\n      Gi = !1,\n      xi = null,\n      ji = function () {\n    function e() {\n      var t = this,\n          n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      c(this, e), wi();\n      var r = !1;\n\n      if ((n.newInstance || !Hi || Hi && n.appId !== Hi.getApplicationId() && Hi.getConnectionState() === Hi.ConnectionState.CLOSED) && (r = !0, Hi = this), r) {\n        try {\n          if (!n.hasOwnProperty(\"appId\")) return J.warn(\"Must be set appId.\"), Hi = null, null;\n        } catch (e) {\n          return J.warn(\"Must be set appId.\"), Hi = null, null;\n        }\n\n        var i = Xn.create();\n        Object.defineProperty(this, \"_iid\", {\n          get: function get() {\n            return i;\n          }\n        }), Fi[i] = this, this.customApiHost = null, this.customWsHost = null, this.connecting = !1, this.reconnecting = !1, this.isReconnectingOnError = !1, this.connectionCallbacks = [], this.ConnectionManager = new Ee(this), this.GCMPushToken = \"\", this.APNSPushToken = \"\", this.PUSH_TEMPLATE_DEFAULT = \"default\", this.PUSH_TEMPLATE_ALTERNATIVE = \"alternative\", this.currentUser = null, this.isSessionOpened = !1, this.globalTimer, this.loginTimer, this.reconnectTimer, this.loginHandler = null, this.onLoginTimerCancel, this.onReconnectTimerCancel, this.BaseChannel = {\n          MessageTypeFilter: Rt.MessageTypeFilter\n        }, this.GroupChannelFilter = Zn, this.MessageFilter = Re, this.GroupChannelCollection = {\n          GroupChannelOrder: ot\n        }, this.MessageCollection = {\n          MessageCollectionInitPolicy: Fe\n        }, this.CollectionEventSource = de, this._currentUserId = null;\n        var s = {\n          User: Ot,\n          Member: or,\n          RestrictedUser: ur,\n          GroupChannel: ar,\n          OpenChannel: gr,\n          UserMessage: Nr,\n          FileMessage: Ir,\n          AdminMessage: Tr,\n          GroupChannelListQuery: Dr,\n          MemberListQuery: Hr,\n          GroupChannelParams: ni,\n          OpenChannelParams: ri,\n          BaseMessageParams: br,\n          UserMessageParams: Cr,\n          FileMessageParams: Sr,\n          ScheduledUserMessageParams: ii,\n          GroupChannelTotalUnreadMessageCountParams: ai,\n          GroupChannelTotalUnreadChannelCountParams: oi,\n          MessageRetrievalParams: li,\n          MessageListParams: ui,\n          ThreadedMessageListParams: ci,\n          MessageChangeLogsParams: di,\n          GroupChannelChangeLogsParams: hi,\n          PollParams: pi,\n          PollRetrievalParams: fi,\n          MessageMetaArray: Er,\n          UserEventHandler: gi,\n          SessionHandler: ve,\n          ChannelHandler: yi,\n          ConnectionHandler: _i,\n          AppleCriticalAlertOptions: mr,\n          Poll: Ai,\n          PollOption: Ii\n        },\n            a = {\n          SessionManager: be,\n          BaseChannel: Rt,\n          BaseMessage: Tt,\n          UserListQuery: Oi,\n          ApplicationUserListQuery: Rr,\n          BannedUserListQuery: Lr,\n          BlockedUserListQuery: Pr,\n          FriendListQuery: wr,\n          MutedUserListQuery: Fr,\n          OpenChannelListQuery: Gr,\n          OperatorListQuery: jr,\n          ParticipantListQuery: Vr,\n          MessageListQuery: Mi,\n          PreviousMessageListQuery: Qr,\n          MessageSearchQuery: Kr,\n          PublicGroupChannelListQuery: Wr,\n          PollListQuery: Zr,\n          PollVoterListQuery: ti,\n          ScheduledUserMessage: Or,\n          ThreadInfo: Ei,\n          ThreadInfoUpdateEvent: Ur,\n          OGMetaData: vi,\n          OGImage: bi,\n          Plugin: Ci,\n          Command: Ne,\n          Sender: lr,\n          ReadStatus: mi,\n          Reaction: Ar,\n          ReactionEvent: Ct,\n          Emoji: hr,\n          EmojiCategory: dr,\n          EmojiContainer: cr,\n          PollDetails: Ni,\n          PollUpdateEvent: Mr,\n          PollVoteEvent: kr,\n          RestrictionInfo: Ti,\n          FileMessageQueue: Gt\n        },\n            o = new x(this._iid, l(l({}, s), a));\n        this.BaseMessage = {\n          ReplyType: Tt.ReplyType,\n          getMessage: o.BaseMessage.getMessage.bind(o.BaseMessage)\n        }, Object.keys(o).forEach(function (e) {\n          s[e] && (t[e] = o[e]);\n        });\n        var u = {\n          encrypt: function encrypt(e) {\n            return e;\n          },\n          decrypt: function decrypt(e) {\n            return e;\n          }\n        };\n        U.create(i, {\n          appId: n.appId,\n          pinger: new Z(this),\n          apiClient: new ue(this),\n          wsAdapter: new ye(this),\n          commandHandler: new wt(this),\n          onlineDetector: new Ce(this),\n          ackStateMap: {},\n          subscribedUnreadMessageCount: {\n            all: 0,\n            custom_types: {},\n            ts: 0\n          },\n          maxUnreadCountOfSuperGroupChannel: T.DEFAULT_MAX_UNREAD_COUNT_OF_SUPER_GROUP_CHANNEL,\n          nestdb: null,\n          currentUserId: null,\n          localCacheEnabled: \"boolean\" == typeof n.localCacheEnabled && n.localCacheEnabled,\n          localCacheLock: new X(),\n          debugCache: !1,\n          encryption: u,\n          store: new Hn({\n            encryption: u\n          }),\n          preference: null,\n          auth: new F(),\n          appInfo: null,\n          pingInterval: 15e3,\n          pongTimeout: 5e3,\n          connectedAt: 0,\n          extensions: {},\n          supportedExtensionKeys: [\"sb_uikit\", \"sb_syncmanager\", \"device-os-platform\"],\n          getUserAgentWithExtensions: function getUserAgentWithExtensions(e) {\n            var t = $() ? \"reactnative\" : \"JS\",\n                n = e.sb_syncmanager ? \"s\".concat(e.sb_syncmanager) : \"\",\n                r = e.sb_uikit ? \"u\".concat(e.sb_uikit) : \"\",\n                i = e[\"device-os-platform\"] ? \"o\".concat(e[\"device-os-platform\"]) : \"\";\n            return \"\".concat(t, \"/c\").concat(T.SDK_VERSION, \"/\").concat(n, \"/\").concat(r, \"/\").concat(i);\n          },\n          sessionManager: new o.SessionManager(this),\n          stateChangeEnabled: !0,\n          isInBackground: !1,\n          closedByGoingBackground: !1,\n          isErrorFirstInCallback: !1,\n          autoResendQueue: [],\n          isProcessingAutoResend: !1\n        }), this.userEventHandlers = {}, this.channelHandlers = {}, this.connectionHandlers = {}, this.Options = {\n          _useMemberAsMessageSender: !0,\n\n          get UseMemberAsMessageSender() {\n            return this._useMemberAsMessageSender;\n          },\n\n          set UseMemberAsMessageSender(e) {\n            \"boolean\" == typeof e && (this._useMemberAsMessageSender = e);\n          },\n\n          get useMemberAsMessageSender() {\n            return this._useMemberAsMessageSender;\n          },\n\n          set useMemberAsMessageSender(e) {\n            \"boolean\" == typeof e && (this._useMemberAsMessageSender = e);\n          },\n\n          _typingIndicatorThrottle: 1e3,\n\n          get typingIndicatorThrottle() {\n            return this._typingIndicatorThrottle;\n          },\n\n          set typingIndicatorThrottle(e) {\n            \"number\" == typeof e && e >= 1e3 && e <= 9e3 && (this._typingIndicatorThrottle = e);\n          },\n\n          _websocketResponseTimeout: 1e4,\n\n          get websocketResponseTimeout() {\n            return this._websocketResponseTimeout;\n          },\n\n          set websocketResponseTimeout(e) {\n            \"number\" == typeof e && e >= 5e3 && e <= Di && (this._websocketResponseTimeout = e);\n          },\n\n          includePollDetails: !1\n        };\n        var d = pe.of(i);\n        d.addObserver({\n          onConnect: function onConnect() {\n            t.isCacheEnabled && !t.getIsProcessingAutoResend() && (0 === t.getAutoResendQueue().length ? nt._processAutoResendRegisteredPendingMessages(t).then(function () {\n              nt._processNextAutoResend(t);\n            }) : nt._processNextAutoResend(t));\n          },\n          onDisconnect: function onDisconnect() {}\n        });\n      }\n\n      return Hi;\n    }\n\n    return h(e, [{\n      key: \"ConnectionState\",\n      get: function get() {\n        return {\n          CONNECTING: \"CONNECTING\",\n          OPEN: \"OPEN\",\n          CLOSED: \"CLOSED\"\n        };\n      }\n    }, {\n      key: \"MessageRequestState\",\n      get: function get() {\n        return {\n          NONE: \"none\",\n          PENDING: \"pending\",\n          FAILED: \"failed\",\n          SUCCEEDED: \"succeeded\"\n        };\n      }\n    }, {\n      key: \"MessageSendingStatus\",\n      get: function get() {\n        return {\n          NONE: \"none\",\n          PENDING: \"pending\",\n          FAILED: \"failed\",\n          CANCELED: \"canceled\",\n          SUCCEEDED: \"succeeded\"\n        };\n      }\n    }, {\n      key: \"pushTokenRegistrationState\",\n      get: function get() {\n        return {\n          SUCCESS: \"success\",\n          PENDING: \"pending\",\n          ERROR: \"error\"\n        };\n      }\n    }, {\n      key: \"PushTriggerOption\",\n      get: function get() {\n        return {\n          ALL: \"all\",\n          MENTION_ONLY: \"mention_only\",\n          OFF: \"off\"\n        };\n      }\n    }, {\n      key: \"appInfo\",\n      get: function get() {\n        return U.get(this._iid).container.appInfo;\n      }\n    }, {\n      key: \"isCacheEnabled\",\n      get: function get() {\n        return U.get(this._iid).container.localCacheEnabled;\n      }\n    }, {\n      key: \"ekey\",\n      get: function get() {\n        var e = U.get(this._iid).container.auth;\n        return e ? e.eKey : \"\";\n      }\n    }, {\n      key: \"getApplicationId\",\n      value: function value() {\n        return U.get(this._iid).get(\"appId\");\n      }\n    }, {\n      key: \"getCurrentUserId\",\n      value: function value() {\n        return this.currentUser ? this.currentUser.userId : null;\n      }\n    }, {\n      key: \"getDebugMode\",\n      value: function value() {\n        return Gi;\n      }\n    }, {\n      key: \"setDebugMode\",\n      value: function value(e) {\n        Gi = e, J.mode = e ? J.Mode.DEBUG : J.Mode.PRODUCTION;\n      }\n    }, {\n      key: \"getErrorFirstCallback\",\n      value: function value() {\n        return U.get(this._iid).container.isErrorFirstInCallback;\n      }\n    }, {\n      key: \"setErrorFirstCallback\",\n      value: function value(e) {\n        \"boolean\" == typeof e && U.get(this._iid).set(\"isErrorFirstInCallback\", e);\n      }\n    }, {\n      key: \"getAutoResendQueue\",\n      value: function value() {\n        return U.get(this._iid).container.autoResendQueue;\n      }\n    }, {\n      key: \"getIsProcessingAutoResend\",\n      value: function value() {\n        return U.get(this._iid).container.isProcessingAutoResend;\n      }\n    }, {\n      key: \"setIsProcessingAutoResend\",\n      value: function value(e) {\n        U.get(this._iid).set(\"isProcessingAutoResend\", e);\n      }\n    }, {\n      key: \"getCurrentApiHost\",\n      value: function value() {\n        return this.customApiHost ? this.customApiHost : \"https://api.sendbird.com\";\n      }\n    }, {\n      key: \"clearCurrentApiHost\",\n      value: function value() {\n        this.customApiHost = null;\n      }\n    }, {\n      key: \"getCurrentWsHost\",\n      value: function value() {\n        return this.customWsHost ? this.customWsHost : \"wss://ws.sendbird.com\";\n      }\n    }, {\n      key: \"clearCurrentWsHost\",\n      value: function value() {\n        this.customWsHost = null;\n      }\n    }, {\n      key: \"getConnectionState\",\n      value: function value() {\n        try {\n          var e = U.get(this._iid).container.wsAdapter;\n          return this.connecting || this.reconnecting ? this.ConnectionState.CONNECTING : e.client ? this.connecting || this.reconnecting ? this.ConnectionState.CONNECTING : this.isSessionOpened ? e.client.getConnectionState() : this.ConnectionState.CLOSED : this.ConnectionState.CLOSED;\n        } catch (e) {\n          return this.ConnectionState.CLOSED;\n        }\n      }\n    }, {\n      key: \"getPendingGCMToken\",\n      value: function value() {\n        return this.GCMPushToken;\n      }\n    }, {\n      key: \"getPendingAPNSToken\",\n      value: function value() {\n        return this.APNSPushToken;\n      }\n    }, {\n      key: \"hasLoggedIn\",\n      value: function value() {\n        var e = U.get(this._iid);\n        return this.currentUser && e.get(\"auth\").hasSession();\n      }\n    }, {\n      key: \"getLastConnectedAt\",\n      value: function value() {\n        var e = U.get(this._iid);\n        return this.getConnectionState() === this.ConnectionState.OPEN && this.currentUser ? e.get(\"connectedAt\") : 0;\n      }\n    }, {\n      key: \"setOnlineListener\",\n      value: function value(e) {\n        U.get(this._iid).container.onlineDetector.setOnlineListener(e);\n      }\n    }, {\n      key: \"setOfflineListener\",\n      value: function value(e) {\n        U.get(this._iid).container.onlineDetector.setOfflineListener(e);\n      }\n    }, {\n      key: \"getMemoryStoreForDebugging\",\n      value: function value() {\n        var e = U.get(this._iid);\n        return e.container.debugCache && e.container.store instanceof wn ? e.container.store : null;\n      }\n    }, {\n      key: \"useMemoryAsDatabaseForDebugging\",\n      value: function value() {\n        var e = U.get(this._iid);\n        e.container.debugCache = !0, e.container.store = new wn();\n      }\n    }, {\n      key: \"useAsyncStorageAsDatabase\",\n      value: function value(e) {\n        var t = U.get(this._iid);\n        t.container.store = new Fn({\n          AsyncStorage: e,\n          encryption: t.container.encryption\n        });\n      }\n    }, {\n      key: \"useMMKVAsDatabase\",\n      value: function value(e) {\n        var t = U.get(this._iid);\n        t.container.store = new Gn({\n          MMKV: e,\n          encryption: t.container.encryption\n        });\n      }\n    }, {\n      key: \"initializeDatabase\",\n      value: function value(e, t) {\n        var n = this,\n            r = U.get(this._iid),\n            i = r.container,\n            s = i.appId,\n            a = i.nestdb,\n            o = i.store,\n            l = i.localCacheEnabled;\n        return oe(this._iid, function (t) {\n          if (l) {\n            if (a) t(null);else {\n              var i = r.container.nestdb = new Jn({\n                name: \"sendbird=\".concat(s, \"-\").concat(e, \".db\"),\n                version: 1,\n                store: o\n              });\n              i.on(\"upgrade\", function (e, t) {\n                if (0 === e) i.commitSchema([{\n                  collectionName: \"GroupChannel\",\n                  keyName: \"url\",\n                  index: [Ue.NAME_ALPHABETICAL, Ue.CHRONOLOGICAL, Ue.LATEST_LAST_MESSAGE]\n                }, {\n                  collectionName: \"SucceededMessage\",\n                  keyName: \"messageId\",\n                  index: [Me.LATEST, Me.CHILD_MESSAGE_FIRST]\n                }, {\n                  collectionName: \"UnsentMessage\",\n                  keyName: \"reqId\",\n                  index: [Me.LATEST_UNSENT, Me.CHILD_MESSAGE_FIRST]\n                }]).then(function () {\n                  return t();\n                }).catch(function (e) {\n                  throw e;\n                });else t();\n              }), i.on(\"error\", function (e) {\n                e ? e.code === xt.STORE_NOT_AVAILABLE || e.code === xt.STORE_NOT_AVAILABLE_IN_PRIVATE_BROWSING ? t(null) : (J.error(\"Database initialize failed with an error: \", e), t(e)) : t(null);\n              }), i.on(\"success\", function () {\n                r.container.currentUserId = e, new bt({\n                  iid: n._iid,\n                  collection: i.collection(\"GroupChannel\")\n                }), new Ge({\n                  iid: n._iid,\n                  collections: {\n                    succeeded: i.collection(\"SucceededMessage\"),\n                    unsent: i.collection(\"UnsentMessage\")\n                  }\n                }), J.debug(\"Database initialize succeeded.\"), t(null);\n              }), i.open();\n            }\n          } else r.container.currentUserId = e, new bt({\n            iid: n._iid,\n            collection: null\n          }), new Ge({\n            iid: n._iid,\n            collections: {\n              succeeded: null,\n              unsent: null\n            }\n          }), t(null);\n        }, t);\n      }\n    }, {\n      key: \"clearCachedData\",\n      value: function value() {\n        var e = U.get(this._iid),\n            t = e.container,\n            n = t.localCacheEnabled,\n            r = t.nestdb;\n        return new Promise(function (t, i) {\n          n && r ? (r.close(), r.reset().then(function () {\n            J.debug(\"Database clear succeeded.\"), e.container.nestdb = null, t();\n          }).catch(function (e) {\n            J.error(\"Database clear failed with an error: \", e), i(e);\n          })) : t();\n        });\n      }\n    }, {\n      key: \"connect\",\n      value: function value(e, t, n, r, i) {\n        var s = this,\n            a = U.get(this._iid),\n            o = a.container,\n            l = o.wsAdapter,\n            u = o.onlineDetector,\n            c = o.localCacheEnabled;\n        u && u.start();\n        var d = null,\n            h = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"string\",\n          nullable: !0,\n          ignoreIf: function ignoreIf(e) {\n            return 1 === e.length || 3 === e.length;\n          }\n        }), new me({\n          type: \"string\",\n          nullable: !0,\n          ignoreIf: function ignoreIf(e) {\n            return 1 === e.length || 2 === e.length;\n          }\n        }), new me({\n          type: \"string\",\n          nullable: !0,\n          ignoreIf: function ignoreIf(e) {\n            return 1 === e.length || 2 === e.length;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            p = C(h, 6);\n        return d = p[0], e = p[1], t = p[2], n = p[3], r = p[4], i = p[5], (n || r) && J.debug(\"Please note that apiHost and wsHost are for internal use only.\"), oe(this._iid, function (i) {\n          if (d) i(d, null);else if (s.customApiHost = n, s.customWsHost = r, s.connecting = !0, s.reconnecting = !1, s.isReconnectingOnError = !1, s.reconnectTimer && (clearTimeout(s.reconnectTimer), s.reconnectTimer = null, s.onReconnectTimerCancel = null), s.getConnectionState() === s.ConnectionState.OPEN && s.currentUser && s.currentUser.userId === e) s.connecting = !1, i(null, s.currentUser);else if (c && (s._currentUserId = e), s.connectionCallbacks.push(i), 1 === s.connectionCallbacks.length) {\n            l.disconnect({\n              clearSession: !0,\n              err: null\n            }, null);\n            var o = a.container,\n                u = o.nestdb,\n                h = o.localCacheLock;\n            u ? l.connect(e, t).then(function () {\n              if (c) return nt._processNonAutoResendRegisteredPendingMessages(s);\n            }) : h.lock(function (n) {\n              s.initializeDatabase(e).then(function () {\n                n(), l.connect(e, t);\n              }).then(function () {\n                if (c) return nt._processNonAutoResendRegisteredPendingMessages(s);\n              }).catch(function (e) {\n                a.container.localCacheEnabled = !1, n(), i(e, null);\n              });\n            });\n          }\n        }, i);\n      }\n    }, {\n      key: \"reconnect\",\n      value: function value() {\n        var e = this,\n            t = U.get(this._iid).container,\n            n = t.wsAdapter,\n            r = t.auth,\n            i = t.localCacheLock;\n\n        if (r.sessionKey && this.currentUser) {\n          var s = !0;\n          return n.reconnectCount > 0 && (s = !1), i.lock(function (t) {\n            n.disconnect({\n              clearSession: !1,\n              err: new H(\"Connection has been canceled.\", H.CONNECTION_CANCELED)\n            }, null), n.reconnectCount = 0, n.reconnect(e.currentUser.userId, s), t();\n          }), !0;\n        }\n\n        return !1;\n      }\n    }, {\n      key: \"disconnect\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          var n = U.get(t._iid).container,\n              r = n.localCacheLock,\n              i = n.wsAdapter,\n              s = n.onlineDetector;\n          s && s.stop(), r.lock(function (n) {\n            i.disconnect({\n              clearSession: !0,\n              err: new H(\"Connection has been canceled.\", H.CONNECTION_CANCELED)\n            }, function () {\n              t.clearCachedData().finally(function () {\n                n(), e(null);\n              });\n            });\n          });\n        }, e);\n      }\n    }, {\n      key: \"setBackgroundState\",\n      value: function value() {\n        var e = U.get(this._iid),\n            t = e.container,\n            n = t.wsAdapter,\n            r = t.stateChangeEnabled;\n        !t.isInBackground && r && (e.set(\"isInBackground\", !0), this.getConnectionState() !== this.ConnectionState.CLOSED ? (e.set(\"closedByGoingBackground\", !0), n.disconnect({\n          clearSession: !1,\n          err: new H(\"Websocket connection failed as the app goes background.\", H.WEBSOCKET_CONNECTION_FAILED)\n        }, null), pe.of(this._iid).invokeDisconnect()) : e.set(\"closedByGoingBackground\", !1));\n      }\n    }, {\n      key: \"isInBackground\",\n      get: function get() {\n        return U.get(this._iid).container.isInBackground;\n      }\n    }, {\n      key: \"setForegroundState\",\n      value: function value() {\n        var e = U.get(this._iid),\n            t = e.container,\n            n = t.wsAdapter,\n            r = t.stateChangeEnabled,\n            i = t.isInBackground,\n            s = t.closedByGoingBackground;\n        i && r && (e.set(\"isInBackground\", !1), s && this.currentUser && n.reconnect(this.currentUser.userId, !0));\n      }\n    }, {\n      key: \"enableStateChange\",\n      value: function value() {\n        U.get(this._iid).set(\"enableStateChange\", !0);\n      }\n    }, {\n      key: \"disableStateChange\",\n      value: function value() {\n        U.get(this._iid).set(\"enableStateChange\", !1);\n      }\n    }, {\n      key: \"addExtension\",\n      value: function value(e, t) {\n        var n = U.get(this._iid).container,\n            r = n.extensions;\n        n.supportedExtensionKeys.indexOf(e) > -1 && (r[e] = t);\n      }\n    }, {\n      key: \"createUserListQuery\",\n      value: function value(e) {\n        return new (0, x.get(this._iid).UserListQuery)(e);\n      }\n    }, {\n      key: \"createApplicationUserListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).ApplicationUserListQuery)();\n      }\n    }, {\n      key: \"createBlockedUserListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).BlockedUserListQuery)();\n      }\n    }, {\n      key: \"createFriendListQuery\",\n      value: function value() {\n        return new (0, x.get(this._iid).FriendListQuery)();\n      }\n    }, {\n      key: \"createMessageSearchQuery\",\n      value: function value(e, t) {\n        return new (0, x.get(this._iid).MessageSearchQuery)(e, t);\n      }\n    }, {\n      key: \"sendCommand\",\n      value: function value(e, t) {\n        var n = this;\n        return oe(this._iid, function (t) {\n          n.ConnectionManager.ready(function (r, i) {\n            if (r) t(r, null);else {\n              var s = U.get(n._iid).container,\n                  a = s.wsAdapter,\n                  o = s.ackStateMap;\n              if (null == a || null == a.client || a.client.getConnectionState() !== n.ConnectionState.OPEN || n.getConnectionState() !== n.ConnectionState.OPEN) return void t(new H(\"Connection is not valid. Please reconnect.\", H.WEBSOCKET_CONNECTION_CLOSED), null);\n\n              if (e.isAckRequired) {\n                var l = e.requestId,\n                    u = {\n                  handler: t,\n                  timer: setTimeout(function () {\n                    t(new H(\"Command received no ack.\", H.ACK_TIMEOUT), null), delete o[l];\n                  }, n.Options.websocketResponseTimeout)\n                };\n                o[l] = u, a.client.send(e, function (e) {\n                  e && (clearTimeout(u.timer), t(e, null));\n                });\n              } else a.client.send(e, t);\n            }\n          }, !1);\n        }, t).catch(function (e) {\n          J.error(e);\n        });\n      }\n    }, {\n      key: \"setSessionHandler\",\n      value: function value(e) {\n        U.get(this._iid).container.sessionManager.setHandler(e);\n      }\n    }, {\n      key: \"addUserEventHandler\",\n      value: function value(e, t) {\n        t instanceof x.get(this._iid).UserEventHandler && (this.userEventHandlers[e] = t);\n      }\n    }, {\n      key: \"removeUserEventHandler\",\n      value: function value(e) {\n        delete this.userEventHandlers[e];\n      }\n    }, {\n      key: \"removeAllUserEventHandler\",\n      value: function value() {\n        this.userEventHandlers = {};\n      }\n    }, {\n      key: \"addChannelHandler\",\n      value: function value(e, t) {\n        t instanceof x.get(this._iid).ChannelHandler && (this.channelHandlers[e] = t);\n      }\n    }, {\n      key: \"removeChannelHandler\",\n      value: function value(e) {\n        delete this.channelHandlers[e];\n      }\n    }, {\n      key: \"removeAllChannelHandlers\",\n      value: function value() {\n        this.channelHandlers = {};\n      }\n    }, {\n      key: \"addConnectionHandler\",\n      value: function value(e, t) {\n        t instanceof x.get(this._iid).ConnectionHandler && (this.connectionHandlers[e] = t);\n      }\n    }, {\n      key: \"removeConnectionHandler\",\n      value: function value(e) {\n        delete this.connectionHandlers[e];\n      }\n    }, {\n      key: \"removeAllConnectionHandlers\",\n      value: function value() {\n        this.connectionHandlers = {};\n      }\n    }, {\n      key: \"updateCurrentUserInfo\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"string\",\n          nullable: !0\n        }), new me({\n          type: \"string\",\n          nullable: !0\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return i = a[0], e = a[1], t = a[2], n = a[3], oe(this._iid, function (n) {\n          if (i) n(i, null);else {\n            var s = U.get(r._iid);\n            s.container.apiClient.updateCurrentUserInfo({\n              nickname: e,\n              profileUrl: t\n            }, function (i, a) {\n              var o = null;\n              i || (r.currentUser && (e && (r.currentUser.nickname = e), t && (r.currentUser.plainProfileUrl = t, Object.defineProperty(r.currentUser, \"profileUrl\", {\n                value: r.currentUser.requireAuth ? \"\".concat(r.currentUser.plainProfileUrl, \"?auth=\").concat(s.container.auth.eKey) : r.currentUser.plainProfileUrl,\n                configurable: !0,\n                writable: !1\n              }))), o = r.currentUser), n(i, o);\n            });\n          }\n        }, n);\n      }\n    }, {\n      key: \"updateCurrentUserInfoWithProfileImage\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"string\",\n          nullable: !0\n        }), new me({\n          type: \"file\",\n          nullable: !0\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return i = a[0], e = a[1], t = a[2], n = a[3], oe(this._iid, function (n) {\n          if (i) n(i, null);else {\n            var s = U.get(r._iid);\n            s.container.apiClient.updateCurrentUserInfo({\n              nickname: e,\n              profileImage: t\n            }, function (t, i) {\n              var a = null;\n              t || (r.currentUser && (e && (r.currentUser.nickname = e), i.profile_url && (r.currentUser.plainProfileUrl = i.profile_url, Object.defineProperty(r.currentUser, \"profileUrl\", {\n                value: r.currentUser.requireAuth ? \"\".concat(r.currentUser.plainProfileUrl, \"?auth=\").concat(s.container.auth.eKey) : r.currentUser.plainProfileUrl,\n                configurable: !0,\n                writable: !1\n              }))), a = r.currentUser), n(t, a);\n            });\n          }\n        }, n);\n      }\n    }, {\n      key: \"updateCurrentUserInfoWithPreferredLanguages\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.updateCurrentUserInfo({\n            preferredLanguages: e\n          }, function (r, i) {\n            var s = null;\n            r || (n.currentUser && e && (n.currentUser._preferredLanguages = e), s = n.currentUser), t(r, s);\n          });\n        }, t);\n      }\n    }, {\n      key: \"registerGCMPushTokenForCurrentUser\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, n.pushTokenRegistrationState.ERROR) : n.currentUser ? U.get(n._iid).container.apiClient.registerGCMPushToken({\n            token: e\n          }, function (e, r) {\n            var i = n.pushTokenRegistrationState.ERROR;\n            e || (n.GCMPushToken = \"\", i = n.pushTokenRegistrationState.SUCCESS), t(e, i);\n          }) : (n.GCMPushToken = e, t(null, n.pushTokenRegistrationState.PENDING));\n        }, t);\n      }\n    }, {\n      key: \"unregisterGCMPushTokenForCurrentUser\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : n.currentUser ? U.get(n._iid).container.apiClient.unregisterGCMPushToken({\n            token: e\n          }, function (e, n) {\n            t(e, null);\n          }) : (n.GCMPushToken = e, t(null, n.pushTokenRegistrationState.PENDING));\n        }, t);\n      }\n    }, {\n      key: \"unregisterGCMPushTokenAllForCurrentUser\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.unregisterAllGCMPushTokens({}, function (t, n) {\n            e(t, null);\n          });\n        }, e);\n      }\n    }, {\n      key: \"registerAPNSPushTokenForCurrentUser\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, n.pushTokenRegistrationState.ERROR) : n.currentUser ? U.get(n._iid).container.apiClient.registerAPNSPushToken({\n            token: e\n          }, function (e, r) {\n            var i = n.pushTokenRegistrationState.ERROR;\n            e || (n.APNSPushToken = \"\", i = n.pushTokenRegistrationState.SUCCESS), t(e, i);\n          }) : (n.APNSPushToken = e, t(null, n.pushTokenRegistrationState.PENDING));\n        }, t);\n      }\n    }, {\n      key: \"unregisterAPNSPushTokenForCurrentUser\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e.length > 0;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : n.currentUser ? U.get(n._iid).container.apiClient.unregisterAPNSPushToken({\n            token: e\n          }, function (e, n) {\n            t(e, null);\n          }) : (n.APNSPushToken = e, t(null, n.pushTokenRegistrationState.PENDING));\n        }, t);\n      }\n    }, {\n      key: \"unregisterAPNSPushTokenAllForCurrentUser\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.unregisterAllAPNSPushTokens({}, function (t, n) {\n            e(t, null);\n          });\n        }, e);\n      }\n    }, {\n      key: \"unregisterPushTokenAllForCurrentUser\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.unregisterAllPushTokens({}, function (t, n) {\n            e(t, null);\n          });\n        }, e);\n      }\n    }, {\n      key: \"getMyGroupChannelChangeLogsByToken\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: \"string\",\n          nullable: !0\n        }), new me({\n          type: \"array\",\n          optional: !0,\n          nullable: !0,\n          defaultValue: null\n        }), new me({\n          type: \"boolean\",\n          nullable: !0,\n          optional: !0,\n          defaultValue: null\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 5);\n        s = o[0], e = o[1], t = o[2], n = o[3], r = o[4];\n        var u = x.get(this._iid),\n            c = u.GroupChannelChangeLogsParams,\n            d = null;\n\n        if (s) {\n          var h = me.parse(arguments, [new me({\n            type: \"string\",\n            nullable: !0\n          }), new me({\n            type: c,\n            constraint: function constraint(e) {\n              return e._validate();\n            }\n          }), new me({\n            type: \"callback\"\n          })]),\n              p = C(h, 4);\n          s = p[0], e = p[1], d = p[2], r = p[3];\n        } else (d = new c()).customTypes = t, d.includeEmpty = n, d.includeFrozen = !0;\n\n        return oe(this._iid, function (t) {\n          s ? t(s, null) : U.get(i._iid).container.apiClient.getMyGroupChannelChangeLogs(l({\n            ts: null,\n            token: e\n          }, d)).then(function (e) {\n            var n = x.get(i._iid).GroupChannel,\n                r = e.updated.map(function (e) {\n              return new n(e);\n            }),\n                s = e.deleted,\n                a = e.has_more,\n                o = e.next;\n            t(null, {\n              updatedChannels: r,\n              deletedChannelUrls: s,\n              hasMore: a,\n              token: o\n            });\n          }).catch(function (e) {\n            t(e, null);\n          });\n        }, r);\n      }\n    }, {\n      key: \"getMyGroupChannelChangeLogsByTimestamp\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: \"number\",\n          constraint: function constraint(e) {\n            return e >= 0;\n          }\n        }), new me({\n          type: \"array\",\n          optional: !0,\n          nullable: !0,\n          defaultValue: null\n        }), new me({\n          type: \"boolean\",\n          nullable: !0,\n          optional: !0,\n          defaultValue: null\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 5);\n        s = o[0], e = o[1], t = o[2], n = o[3], r = o[4];\n        var u = x.get(this._iid),\n            c = u.GroupChannelChangeLogsParams,\n            d = null;\n\n        if (s) {\n          var h = me.parse(arguments, [new me({\n            type: \"number\",\n            constraint: function constraint(e) {\n              return e >= 0;\n            }\n          }), new me({\n            type: c,\n            constraint: function constraint(e) {\n              return e._validate();\n            }\n          }), new me({\n            type: \"callback\"\n          })]),\n              p = C(h, 4);\n          s = p[0], e = p[1], d = p[2], r = p[3];\n        } else (d = new c()).customTypes = t, d.includeEmpty = n, d.includeFrozen = !0;\n\n        return oe(this._iid, function (t) {\n          s ? t(s, null) : U.get(i._iid).container.apiClient.getMyGroupChannelChangeLogs(l({\n            ts: e,\n            token: null\n          }, d)).then(function (e) {\n            var n = x.get(i._iid).GroupChannel,\n                r = e.updated.map(function (e) {\n              return new n(e);\n            }),\n                s = e.deleted,\n                a = e.has_more,\n                o = e.next;\n            t(null, {\n              updatedChannels: r,\n              deletedChannelUrls: s,\n              hasMore: a,\n              token: o\n            });\n          }).catch(function (e) {\n            t(e, null);\n          });\n        }, r);\n      }\n    }, {\n      key: \"getChannelInvitationPreference\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.getChannelInvitationPreference({}, function (t, n) {\n            var r = null;\n            t || (r = {\n              autoAccept: n.auto_accept\n            }), e(t, r);\n          });\n        }, e);\n      }\n    }, {\n      key: \"setChannelInvitationPreference\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"boolean\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.setChannelInvitationPreference({\n            isAutoAccept: e\n          }, function (e, n) {\n            var r = null;\n            e || (r = {\n              autoAccept: n.auto_accept\n            }), t(e, r);\n          });\n        }, t);\n      }\n    }, {\n      key: \"getDoNotDisturb\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.getDoNotDisturb({}, function (t, n) {\n            var r = null;\n            t || (r = {\n              doNotDisturbOn: n.do_not_disturb,\n              startHour: n.start_hour,\n              startMin: n.start_min,\n              endHour: n.end_hour,\n              endMin: n.end_min,\n              timezone: n.timezone\n            }), e(t, r);\n          });\n        }, e);\n      }\n    }, {\n      key: \"setDoNotDisturb\",\n      value: function value(e, t, n, r, i, s, a) {\n        var o = this,\n            l = null,\n            u = me.parse(arguments, [new me({\n          type: \"boolean\"\n        }), new me({\n          type: \"number\",\n          constraint: function constraint(e) {\n            return 0 <= e && e <= 23;\n          }\n        }), new me({\n          type: \"number\",\n          constraint: function constraint(e) {\n            return 0 <= e && e <= 59;\n          }\n        }), new me({\n          type: \"number\",\n          constraint: function constraint(e) {\n            return 0 <= e && e <= 23;\n          }\n        }), new me({\n          type: \"number\",\n          constraint: function constraint(e) {\n            return 0 <= e && e <= 59;\n          }\n        }), new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            c = C(u, 8);\n        return l = c[0], e = c[1], t = c[2], n = c[3], r = c[4], i = c[5], s = c[6], a = c[7], oe(this._iid, function (a) {\n          l ? a(l, null) : U.get(o._iid).container.apiClient.setDoNotDisturb({\n            doNotDisturbOn: e,\n            startHour: t,\n            startMin: n,\n            endHour: r,\n            endMin: i,\n            timezone: s\n          }, function (e, t) {\n            var n = null;\n            e || (n = {\n              doNotDisturbOn: t.do_not_disturb,\n              startHour: t.start_hour,\n              startMin: t.start_min,\n              endHour: t.end_hour,\n              endMin: t.end_min,\n              timezone: t.timezone\n            }), a(e, n);\n          });\n        }, a);\n      }\n    }, {\n      key: \"getSnoozePeriod\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.getSnoozePeriod({}, function (t, n) {\n            var r = null;\n            t || (r = {\n              isSnoozeOn: n.snooze_enabled,\n              startTs: n.snooze_start_ts,\n              endTs: n.snooze_end_ts\n            }), e(t, r);\n          });\n        }, e);\n      }\n    }, {\n      key: \"setSnoozePeriod\",\n      value: function value(e, t, n, r) {\n        var i = this,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: \"boolean\"\n        }), new me({\n          type: \"number\",\n          constraint: function constraint(e) {\n            return e > 0;\n          }\n        }), new me({\n          type: \"number\",\n          constraint: function constraint(e) {\n            return e > 0;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 5);\n        return s = o[0], e = o[1], t = o[2], n = o[3], r = o[4], oe(this._iid, function (r) {\n          s ? r(s, null) : U.get(i._iid).container.apiClient.setSnoozePeriod({\n            snoozeOn: e,\n            startTs: t,\n            endTs: n\n          }, function (e, t) {\n            var n = null;\n            e || (n = {\n              isSnoozeOn: t.snooze_enabled,\n              startTs: t.snooze_start_ts,\n              endTs: t.snooze_end_ts\n            }), r(e, n);\n          });\n        }, r);\n      }\n    }, {\n      key: \"blockUser\",\n      value: function value(e, t) {\n        var n = null,\n            r = me.parse(arguments, [new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return e && e.hasOwnProperty(\"userId\");\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 3);\n        return n = i[0], e = i[1], t = i[2], n ? oe(this._iid, function (e) {\n          e(n, null);\n        }, t) : this.blockUserWithUserId(e.userId, t);\n      }\n    }, {\n      key: \"blockUserWithUserId\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e && (!n.currentUser || e !== n.currentUser.userId);\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.blockUser({\n            blockedUserId: e\n          }, function (e, n) {\n            var r = null;\n            e || (r = new Ot(n)), t(e, r);\n          });\n        }, t);\n      }\n    }, {\n      key: \"unblockUser\",\n      value: function value(e, t) {\n        var n = null,\n            r = me.parse(arguments, [new me({\n          type: \"object\",\n          constraint: function constraint(e) {\n            return e && e.hasOwnProperty(\"userId\");\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 3);\n        return n = i[0], e = i[1], t = i[2], n ? oe(this._iid, function (e) {\n          e(n, null);\n        }, t) : this.unblockUserWithUserId(e.userId, t);\n      }\n    }, {\n      key: \"unblockUserWithUserId\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return e && (!n.currentUser || e !== n.currentUser.userId);\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.unblockUser({\n            unblockedUserId: e\n          }, function (e, n) {\n            t(e, null);\n          });\n        }, t);\n      }\n    }, {\n      key: \"getPushTriggerOption\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.getPushTriggerOption({}, function (t, n) {\n            e(t, n ? n.push_trigger_option : null);\n          });\n        }, e);\n      }\n    }, {\n      key: \"setPushTriggerOption\",\n      value: function value(e, t) {\n        var n = this;\n        return oe(this._iid, function (t) {\n          Object.keys(n.PushTriggerOption).map(function (e) {\n            return n.PushTriggerOption[e];\n          }).indexOf(e) > -1 ? U.get(n._iid).container.apiClient.setPushTriggerOption({\n            pushTriggerOption: e\n          }, function (e, n) {\n            t(e, n ? n.push_trigger_option : null);\n          }) : t(me.error, null);\n        }, t);\n      }\n    }, {\n      key: \"getGroupChannelCount\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.GroupChannel,\n            s = null,\n            a = me.parse(arguments, [new me({\n          type: i.MemberStateFilter,\n          optional: !0,\n          defaultValue: i.MemberStateFilter.ALL\n        }), new me({\n          type: \"callback\"\n        })]),\n            o = C(a, 3);\n        return s = o[0], e = o[1], t = o[2], oe(this._iid, function (t) {\n          s ? t(s, null) : U.get(n._iid).container.apiClient.getGroupChannelCount({\n            memberStateFilter: e\n          }, function (e, n) {\n            var r = null;\n            e || (r = parseInt(n.group_channel_count)), t(e, r);\n          });\n        }, t);\n      }\n    }, {\n      key: \"getTotalUnreadChannelCount\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.GroupChannel,\n            s = r.GroupChannelTotalUnreadChannelCountParams,\n            a = null,\n            o = me.parse(arguments, [new me({\n          type: \"object\",\n          optional: !0,\n          defaultValue: null,\n          constraint: function constraint(e) {\n            return e instanceof s;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            l = C(o, 3);\n        return a = l[0], e = l[1], t = l[2], oe(this._iid, function (t) {\n          if (a) t(a, null);else {\n            var r = null,\n                s = i.SuperChannelFilter.ALL;\n            e && (r = e.channelCustomTypesFilter, s = e.superChannelFilter), U.get(n._iid).container.apiClient.getTotalUnreadChannelCount({\n              customTypesFilter: r,\n              superChannelFilter: s\n            }, function (e, n) {\n              var r = null;\n              e || (r = parseInt(n.unread_count)), t(e, r);\n            });\n          }\n        }, t);\n      }\n    }, {\n      key: \"getTotalUnreadMessageCount\",\n      value: function value(e, t) {\n        var n = this,\n            r = x.get(this._iid),\n            i = r.GroupChannel,\n            s = r.GroupChannelTotalUnreadMessageCountParams,\n            a = null,\n            o = me.parse(arguments, [new me({\n          type: \"object\",\n          optional: !0,\n          defaultValue: null,\n          constraint: function constraint(e) {\n            return Array.isArray(e) && e.every(function (e) {\n              return \"string\" == typeof e;\n            }) || e instanceof s;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            l = C(o, 3);\n        return a = l[0], e = l[1], t = l[2], oe(this._iid, function (t) {\n          if (a) t(a, null);else {\n            var r = i.SuperChannelFilter.ALL;\n\n            if (e instanceof s) {\n              var o = e;\n              e = o.channelCustomTypesFilter, r = o.superChannelFilter;\n            }\n\n            U.get(n._iid).container.apiClient.getTotalUnreadMessageCount({\n              customTypesFilter: e,\n              superChannelFilter: r\n            }, function (e, n) {\n              var r = null;\n              e || (r = parseInt(n.unread_count)), t(e, r);\n            });\n          }\n        }, t);\n      }\n    }, {\n      key: \"getUnreadItemCount\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.length > 0 && e.every(function (e) {\n              return Object.keys(ar.UnreadItemKey).map(function (e) {\n                return ar.UnreadItemKey[e];\n              }).indexOf(e) > -1;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          if (r) t(r, null);else {\n            var i = e.filter(function (t, n) {\n              return e.indexOf(t) === n;\n            });\n            U.get(n._iid).container.apiClient.getUnreadItemCount({\n              keys: i\n            }, function (e, n) {\n              t(e, n);\n            });\n          }\n        }, t);\n      }\n    }, {\n      key: \"getSubscribedTotalUnreadMessageCount\",\n      value: function value() {\n        var e = U.get(this._iid).container.subscribedUnreadMessageCount;\n        return e.all >= 0 ? e.all : 0;\n      }\n    }, {\n      key: \"getSubscribedCustomTypeTotalUnreadMessageCount\",\n      value: function value() {\n        var e = U.get(this._iid).container.subscribedUnreadMessageCount;\n\n        if (Object.keys(e.custom_types).length > 0) {\n          var t = 0;\n          return Object.keys(e.custom_types).forEach(function (n) {\n            t += e.custom_types[n];\n          }), t;\n        }\n\n        return 0;\n      }\n    }, {\n      key: \"getSubscribedCustomTypeUnreadMessageCount\",\n      value: function value(e) {\n        if (e && \"string\" == typeof e) {\n          var t = U.get(this._iid).container.subscribedUnreadMessageCount;\n          return t.custom_types.hasOwnProperty(e) ? t.custom_types[e] : 0;\n        }\n\n        return 0;\n      }\n    }, {\n      key: \"getMyPushTokensByToken\",\n      value: function value(e, t, n) {\n        var r = this,\n            i = null,\n            s = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"string\",\n          constraint: function constraint(e) {\n            return [\"gcm\", \"apns\", \"apns_voip\"].indexOf(e) > -1;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            a = C(s, 4);\n        return i = a[0], e = a[1], t = a[2], n = a[3], oe(this._iid, function (n) {\n          i ? n(i, null) : U.get(r._iid).container.apiClient.getPushTokens({\n            ts: null,\n            token: e,\n            type: t\n          }, function (e, t) {\n            if (e) n(e, null);else {\n              var r = t.type;\n              n(null, {\n                deviceTokens: t.device_tokens,\n                type: r ? r.toLowerCase() : \"unknown\",\n                hasMore: t.has_more,\n                token: t.token\n              });\n            }\n          });\n        }, n);\n      }\n    }, {\n      key: \"getPushTemplate\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          U.get(t._iid).container.apiClient.getPushTemplate({}, function (t, n) {\n            var r = null;\n            t || (r = n.name.toString()), e(t, r);\n          });\n        }, e);\n      }\n    }, {\n      key: \"setPushTemplate\",\n      value: function value(e, t) {\n        var n = this;\n        return oe(this._iid, function (t) {\n          [n.PUSH_TEMPLATE_DEFAULT, n.PUSH_TEMPLATE_ALTERNATIVE].indexOf(e) > -1 ? U.get(n._iid).container.apiClient.setPushTemplate({\n            templateName: e\n          }, function (e, n) {\n            var r = null;\n            e || (r = n.name.toString()), t(e, r);\n          }) : t(me.error, null);\n        }, t);\n      }\n    }, {\n      key: \"markAsReadAll\",\n      value: function value(e) {\n        var t = this;\n        return oe(this._iid, function (e) {\n          var n = x.get(t._iid).GroupChannel,\n              r = new Date().getTime();\n          r - n.markAsReadAllLastSentAt < 1e3 ? e(new H(\"MarkAsRead rate limit exceeded.\", H.MARK_AS_READ_RATE_LIMIT_EXCEEDED), null) : (n.markAsReadAllLastSentAt = r, U.get(t._iid).container.apiClient.markAsReadAll({\n            channelUrls: null\n          }, function (i, s) {\n            i || Object.keys(n.cachedChannels).forEach(function (e) {\n              t.currentUser && n.cachedChannels[e].updateReadReceipt(t.currentUser.userId, r), n.cachedChannels[e]._setGroupChannelUnreadCount(0, 0);\n            }), e(i, null);\n          }));\n        }, e);\n      }\n    }, {\n      key: \"markAsReadWithChannelUrls\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          if (r) t(r, null);else {\n            var i = new Date().getTime();\n            U.get(n._iid).container.apiClient.markAsReadAll({\n              channelUrls: e\n            }, function (r, s) {\n              r || e.forEach(function (e) {\n                ar.cachedChannels[e] && (n.currentUser && ar.cachedChannels[e].updateReadReceipt(n.currentUser.userId, i), ar.cachedChannels[e]._setGroupChannelUnreadCount(0, 0));\n              }), t(r, null);\n            });\n          }\n        }, t);\n      }\n    }, {\n      key: \"markAsDelivered\",\n      value: function value(e) {\n        \"string\" == typeof e && x.get(this._iid).GroupChannel.getChannel(e, T.INTERNAL_CALL).then(function (e) {\n          return e.markAsDelivered();\n        }).catch(function (e) {\n          return J.debug(e);\n        });\n      }\n    }, {\n      key: \"getFriendChangeLogsByToken\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\",\n          optional: !0,\n          defaultValue: null\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.getFriendChangeLogsByToken({\n            token: e\n          }, function (e, r) {\n            var i = null;\n\n            if (!e) {\n              var s = x.get(n._iid).User;\n              i = {\n                updatedUsers: r.updated.map(function (e) {\n                  return new s(e);\n                }),\n                deletedUserIds: r.deleted,\n                hasMore: r.has_more,\n                token: r.next\n              };\n            }\n\n            t(e, i);\n          });\n        }, t);\n      }\n    }, {\n      key: \"uploadFriendDiscoveries\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return e.hasOwnProperty(\"friendDiscoveryKey\");\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.uploadFriendDiscoveries({\n            discoveries: e\n          }, function (e, n) {\n            t(e, n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"deleteFriendDiscovery\",\n      value: function value(e, t) {\n        var n = null,\n            r = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 3);\n        return n = i[0], e = i[1], t = i[2], n ? oe(this._iid, function (e) {\n          e(n, null);\n        }, t) : this.deleteFriendDiscoveries([e], t);\n      }\n    }, {\n      key: \"deleteFriendDiscoveries\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.deleteFriendDiscoveries({\n            discoveryKeys: e\n          }, function (e, n) {\n            t(e, n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"addFriends\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.addFriends({\n            userIds: e\n          }, function (e, r) {\n            var i = null;\n\n            if (!e) {\n              var s = x.get(n._iid).User;\n              i = r.users.map(function (e) {\n                return new s(e);\n              });\n            }\n\n            t(e, i);\n          });\n        }, t);\n      }\n    }, {\n      key: \"deleteFriend\",\n      value: function value(e, t) {\n        var n = null,\n            r = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 3);\n        return n = i[0], e = i[1], t = i[2], n ? oe(this._iid, function (e) {\n          e(n, null);\n        }, t) : this.deleteFriends([e], t);\n      }\n    }, {\n      key: \"deleteFriends\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"array\",\n          constraint: function constraint(e) {\n            return e.every(function (e) {\n              return \"string\" == typeof e;\n            });\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.deleteFriends({\n            userIds: e\n          }, function (e, n) {\n            t(e, n);\n          });\n        }, t);\n      }\n    }, {\n      key: \"getAllEmoji\",\n      value: function value(e) {\n        var t = this,\n            n = null,\n            r = me.parse(arguments, [new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 2);\n        return n = i[0], e = i[1], oe(this._iid, function (e) {\n          n ? e(n, null) : U.get(t._iid).container.apiClient.getAllEmoji(function (n, r) {\n            if (n) e(n, null);else {\n              var i = new (0, x.get(t._iid).EmojiContainer)(r);\n              e(null, i);\n            }\n          });\n        }, e);\n      }\n    }, {\n      key: \"getEmojiCategory\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"number\",\n          constraint: function constraint(e) {\n            return e >= 0;\n          }\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.getEmojiCategory({\n            categoryId: e\n          }, function (e, r) {\n            if (e) t(e, null);else {\n              var i = new (0, x.get(n._iid).EmojiCategory)(r);\n              t(null, i);\n            }\n          });\n        }, t);\n      }\n    }, {\n      key: \"getEmoji\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"string\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.getEmoji({\n            emojiKey: e\n          }, function (e, r) {\n            if (e) t(e, null);else {\n              var i = new (0, x.get(n._iid).Emoji)(r);\n              t(null, i);\n            }\n          });\n        }, t);\n      }\n    }, {\n      key: \"getAllowFriendDiscovery\",\n      value: function value(e) {\n        var t = this,\n            n = null,\n            r = me.parse(arguments, [new me({\n          type: \"callback\"\n        })]),\n            i = C(r, 2);\n        return n = i[0], e = i[1], oe(this._iid, function (e) {\n          n ? e(n, null) : U.get(t._iid).container.apiClient.getAllowFriendDiscovery(function (t, n) {\n            var r = n.allow_friend_discovery;\n            t ? e(t, null) : e(null, r);\n          });\n        }, e);\n      }\n    }, {\n      key: \"setAllowFriendDiscovery\",\n      value: function value(e, t) {\n        var n = this,\n            r = null,\n            i = me.parse(arguments, [new me({\n          type: \"boolean\"\n        }), new me({\n          type: \"callback\"\n        })]),\n            s = C(i, 3);\n        return r = s[0], e = s[1], t = s[2], oe(this._iid, function (t) {\n          r ? t(r, null) : U.get(n._iid).container.apiClient.setAllowFriendDiscovery({\n            allowFriendDiscovery: e\n          }, function (n, r) {\n            n ? t(n, null) : t(null, e);\n          });\n        }, t);\n      }\n    }, {\n      key: \"clearCachedMessages\",\n      value: function value(e) {\n        var t = this,\n            n = Ge.of(this._iid);\n\n        if (n) {\n          var r = U.get(this._iid).container.store;\n          return Promise.all(e.map(function (e) {\n            return new Promise(function (i, s) {\n              n.clearByChannelUrl(e).then(function () {\n                var n = Be(t._currentUserId, e);\n                return r.remove(n);\n              }).then(function () {\n                var n = Ke(t._currentUserId, e);\n                return r.remove(n);\n              }).then(function () {\n                i();\n              }).catch(function (e) {\n                s(e);\n              });\n            });\n          }));\n        }\n\n        return Promise.resolve([]);\n      }\n    }, {\n      key: \"_getCurrentUserDataKey\",\n      value: function value() {\n        return \"sendbird:\".concat(this._currentUserId, \"@currentUserData\");\n      }\n    }, {\n      key: \"_populateVaultFromCurrentUserData\",\n      value: function value(e) {\n        var t = U.get(this._iid),\n            n = t.container.auth,\n            r = x.get(this._iid).User,\n            i = e.currentUser,\n            s = e.maxUnreadCountOfSuperGroupChannel,\n            a = e.profileImageEncryption,\n            o = e.sessionKey,\n            l = e.eKey,\n            u = e.appInfo,\n            c = e.connectedAt,\n            d = e.firstConnectedAt,\n            h = e.concurrentCallLimit,\n            p = e.backOffDelay;\n        i && (this.currentUser = r.buildFromSerializedData(i)), s && t.set(\"maxUnreadCountOfSuperGroupChannel\", s), a && t.set(\"profileImageEncryption\", a), n ? (o && (n.sessionKey = o), l && (n.ekey = l)) : J.debug(\"Auth should have been created when populating current user data.\"), u && t.set(\"appInfo\", new Ie(u)), c && t.set(\"connectedAt\", c), d && t.set(\"firstConnectedAt\", d), h && t.set(\"concurrentCallLimit\", h), p && t.set(\"backOffDelay\", p);\n      }\n    }], [{\n      key: \"version\",\n      get: function get() {\n        return T.SDK_VERSION;\n      }\n    }, {\n      key: \"LogLevel\",\n      get: function get() {\n        return J.supportedLogLevels;\n      }\n    }, {\n      key: \"getInstance\",\n      value: function value(e) {\n        return e ? Fi[e] : Hi;\n      }\n    }, {\n      key: \"getLogLevel\",\n      value: function value() {\n        return J.logLevel;\n      }\n    }, {\n      key: \"setLogLevel\",\n      value: function value(e) {\n        var t = Object.values(J.supportedLogLevels);\n        if (t.includes(e)) J.logLevel = e;else {\n          J.logLevel = J.defaultLogLevel;\n          var n = t.map(function (e) {\n            return \"'\".concat(e, \"'\");\n          }).join(\", \");\n          J.warn(\"`logLevel` parameter should be one of\", \"\".concat(n, \",\"), \"not `'\".concat(e, \"'`.\"), \"Set to default log level\", \"`\".concat(J.defaultLogLevel, \"`.\"));\n        }\n      }\n    }, {\n      key: \"getAppVersion\",\n      value: function value() {\n        return xi;\n      }\n    }, {\n      key: \"setAppVersion\",\n      value: function value(e) {\n        \"string\" == typeof e && $() && (xi = e);\n      }\n    }]), e;\n  }();\n\n  return ji;\n});","map":null,"metadata":{},"sourceType":"script"}