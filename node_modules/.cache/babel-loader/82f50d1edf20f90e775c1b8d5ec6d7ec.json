{"ast":null,"code":"import { e as _toConsumableArray, a as _objectSpread2, u as uuidv4, b as _slicedToArray, f as _defineProperty, c as LocalizationContext, h as _inherits, i as _createSuper, j as _createClass, k as _classCallCheck, l as _assertThisInitialized, w as withSendbirdContext } from './LocalizationContext-dfe8b78b.js';\nimport React__default, { useEffect, useCallback, useRef, useMemo, useContext, useState, useLayoutEffect, Component, useReducer } from 'react';\nimport PropTypes from 'prop-types';\nimport { g as format, i as ImageRenderer, I as Icon, c as IconTypes, d as IconColors, e as Loader, L as Label, a as LabelTypography, b as LabelColors, A as Avatar, P as PlaceHolder, j as PlaceHolderTypes, h as LabelStringSet } from './index-fe1a6d27.js';\nimport { m as getOutgoingMessageStates, n as getSendingMessageStatus, o as SEND_USER_MESSAGE, S as SEND_MESSAGE_START, p as SEND_FILE_MESSAGE, l as UPDATE_USER_MESSAGE, D as DELETE_MESSAGE, q as filterMessageListParams, E as EmojiListItems, r as isSentStatus, u as getMessageCreatedAt$1, v as isUserMessage, w as isFailedMessage, x as isPendingMessage, y as isSentMessage, z as getClassName, C as ContextMenu, I as IconButton, b as MenuItems, c as MenuItem, A as copyToClipboard, F as getEmojiListAll, G as getEmojiMapAll, H as isReactedBy, J as getEmojiTooltipString, K as isEditedMessage, N as getUIKitFileType, a as TextButton, t as truncateString, O as isVideoMessage, P as isGifMessage, Q as isUrl, R as getUIKitFileTypes, V as isThumbnailMessage, W as isVideo, X as isGif, Y as isFileMessage, Z as isSupportedFileView, _ as getUIKitMessageTypes, U as UserProfileContext, f as ConnectedUserProfile, $ as getOutgoingMessageState, a0 as getSenderName, a1 as isTextMessage, a2 as isOGMessage, a3 as getUIKitMessageType, M as Modal, d as ButtonTypes, a4 as isImageMessage, a5 as isAudioMessage, h as UserProfileProvider } from './index-cb0d7936.js';\nimport { c as compareIds, L as LinkLabel, D as DateSeparator, M as MessageInput, F as FileViewer } from './index-8312f99e.js';\nimport { i as isSameDay } from './index-0cc16758.js';\nimport { C as ChannelAvatar } from './index-db1485c0.js';\nimport 'react-dom';\nimport './utils-7b22e0fc.js';\nvar RESET_MESSAGES = 'RESET_MESSAGES';\nvar RESET_STATE = 'RESET_STATE';\nvar CLEAR_SENT_MESSAGES = 'CLEAR_SENT_MESSAGES';\nvar GET_PREV_MESSAGES_START = 'GET_PREV_MESSAGES_START';\nvar GET_PREV_MESSAGES_SUCESS = 'GET_PREV_MESSAGES_SUCESS';\nvar GET_NEXT_MESSAGES_SUCESS = 'GET_NEXT_MESSAGES_SUCESS';\nvar GET_NEXT_MESSAGES_FAILURE = 'GET_NEXT_MESSAGES_FAILURE';\nvar SEND_MESSAGEGE_START = 'SEND_MESSAGEGE_START';\nvar SEND_MESSAGEGE_SUCESS = 'SEND_MESSAGEGE_SUCESS';\nvar SEND_MESSAGEGE_FAILURE = 'SEND_MESSAGEGE_FAILURE';\nvar RESEND_MESSAGEGE_START = 'RESEND_MESSAGEGE_START';\nvar ON_MESSAGE_RECEIVED = 'ON_MESSAGE_RECEIVED';\nvar UPDATE_UNREAD_COUNT = 'UPDATE_UNREAD_COUNT';\nvar ON_MESSAGE_UPDATED = 'ON_MESSAGE_UPDATED';\nvar ON_MESSAGE_THREAD_INFO_UPDATED = 'ON_MESSAGE_THREAD_INFO_UPDATED';\nvar ON_MESSAGE_DELETED = 'ON_MESSAGE_DELETED';\nvar ON_MESSAGE_DELETED_BY_REQ_ID = 'ON_MESSAGE_DELETED_BY_REQ_ID';\nvar SET_CURRENT_CHANNEL = 'SET_CURRENT_CHANNEL';\nvar SET_CHANNEL_INVALID = 'SET_CHANNEL_INVALID';\nvar MARK_AS_READ = 'MARK_AS_READ';\nvar ON_REACTION_UPDATED = 'ON_REACTION_UPDATED';\nvar SET_EMOJI_CONTAINER = 'SET_EMOJI_CONTAINER';\nvar MESSAGE_LIST_PARAMS_CHANGED = 'MESSAGE_LIST_PARAMS_CHANGED';\ngetOutgoingMessageStates();\nvar UNDEFINED = 'undefined';\n\nvar _getSendingMessageSta$1 = getSendingMessageStatus(),\n    SUCCEEDED$1 = _getSendingMessageSta$1.SUCCEEDED;\n\n_getSendingMessageSta$1.FAILED;\nvar PENDING$1 = _getSendingMessageSta$1.PENDING;\n\nvar scrollIntoLast = function scrollIntoLast() {\n  var intialTry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var MAX_TRIES = 10;\n  var currentTry = intialTry;\n\n  if (currentTry > MAX_TRIES) {\n    return;\n  }\n\n  try {\n    var scrollDOM = document.querySelector('.sendbird-conversation__scroll-container'); // eslint-disable-next-line no-multi-assign\n\n    scrollDOM.scrollTop = scrollDOM.scrollHeight;\n  } catch (error) {\n    setTimeout(function () {\n      scrollIntoLast(currentTry + 1);\n    }, 500 * currentTry);\n  }\n};\n\nvar pubSubHandleRemover = function pubSubHandleRemover(subscriber) {\n  subscriber.forEach(function (s) {\n    try {\n      s.remove();\n    } catch (_unused) {//\n    }\n  });\n};\n\nvar pubSubHandler = function pubSubHandler(channelUrl, pubSub, dispatcher) {\n  var subscriber = new Map();\n  if (!pubSub || !pubSub.subscribe) return subscriber;\n  subscriber.set(SEND_USER_MESSAGE, pubSub.subscribe(SEND_USER_MESSAGE, function (msg) {\n    var channel = msg.channel,\n        message = msg.message;\n    scrollIntoLast();\n\n    if (channel && channelUrl === channel.url) {\n      dispatcher({\n        type: SEND_MESSAGEGE_SUCESS,\n        payload: message\n      });\n    }\n  }));\n  subscriber.set(SEND_MESSAGE_START, pubSub.subscribe(SEND_MESSAGE_START, function (msg) {\n    var channel = msg.channel,\n        message = msg.message;\n\n    if (channel && channelUrl === channel.url) {\n      dispatcher({\n        type: SEND_MESSAGEGE_START,\n        payload: message\n      });\n    }\n  }));\n  subscriber.set(SEND_FILE_MESSAGE, pubSub.subscribe(SEND_FILE_MESSAGE, function (msg) {\n    var channel = msg.channel,\n        message = msg.message;\n    scrollIntoLast();\n\n    if (channel && channelUrl === channel.url) {\n      dispatcher({\n        type: SEND_MESSAGEGE_SUCESS,\n        payload: message\n      });\n    }\n  }));\n  subscriber.set(UPDATE_USER_MESSAGE, pubSub.subscribe(UPDATE_USER_MESSAGE, function (msg) {\n    var channel = msg.channel,\n        message = msg.message,\n        fromSelector = msg.fromSelector;\n\n    if (fromSelector && channel && channelUrl === channel.url) {\n      dispatcher({\n        type: ON_MESSAGE_UPDATED,\n        payload: {\n          channel: channel,\n          message: message\n        }\n      });\n    }\n  }));\n  subscriber.set(DELETE_MESSAGE, pubSub.subscribe(DELETE_MESSAGE, function (msg) {\n    var channel = msg.channel,\n        messageId = msg.messageId;\n\n    if (channel && channelUrl === channel.url) {\n      dispatcher({\n        type: ON_MESSAGE_DELETED,\n        payload: messageId\n      });\n    }\n  }));\n  return subscriber;\n};\n\nvar isOperator = function isOperator() {\n  var groupChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var myRole = groupChannel.myRole;\n  return myRole === 'operator';\n};\n\nvar isDisabledBecauseFrozen = function isDisabledBecauseFrozen() {\n  var groupChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var isFrozen = groupChannel.isFrozen;\n  return isFrozen && !isOperator(groupChannel);\n};\n\nvar isDisabledBecauseMuted = function isDisabledBecauseMuted() {\n  var groupChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var myMutedState = groupChannel.myMutedState;\n  return myMutedState === 'muted';\n};\n\nvar getEmojiCategoriesFromEmojiContainer$1 = function getEmojiCategoriesFromEmojiContainer() {\n  var emojiContainer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return emojiContainer.emojiCategories ? emojiContainer.emojiCategories : [];\n};\n\nvar getAllEmojisFromEmojiContainer$1 = function getAllEmojisFromEmojiContainer() {\n  var emojiContainer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _emojiContainer$emoji = emojiContainer.emojiCategories,\n      emojiCategories = _emojiContainer$emoji === void 0 ? [] : _emojiContainer$emoji;\n  var allEmojis = [];\n\n  for (var categoryIndex = 0; categoryIndex < emojiCategories.length; categoryIndex += 1) {\n    var emojis = emojiCategories[categoryIndex].emojis;\n\n    for (var emojiIndex = 0; emojiIndex < emojis.length; emojiIndex += 1) {\n      allEmojis.push(emojis[emojiIndex]);\n    }\n  }\n\n  return allEmojis;\n};\n\nvar getEmojisFromEmojiContainer$1 = function getEmojisFromEmojiContainer() {\n  var emojiContainer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var emojiCategoryId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return emojiContainer.emojiCategories ? emojiContainer.emojiCategories.filter(function (emojiCategory) {\n    return emojiCategory.id === emojiCategoryId;\n  })[0].emojis : [];\n};\n\nvar getAllEmojisMapFromEmojiContainer = function getAllEmojisMapFromEmojiContainer() {\n  var emojiContainer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _emojiContainer$emoji2 = emojiContainer.emojiCategories,\n      emojiCategories = _emojiContainer$emoji2 === void 0 ? [] : _emojiContainer$emoji2;\n  var allEmojisMap = new Map();\n\n  for (var categoryIndex = 0; categoryIndex < emojiCategories.length; categoryIndex += 1) {\n    var emojis = emojiCategories[categoryIndex].emojis;\n\n    for (var emojiIndex = 0; emojiIndex < emojis.length; emojiIndex += 1) {\n      var _emojis$emojiIndex = emojis[emojiIndex],\n          key = _emojis$emojiIndex.key,\n          url = _emojis$emojiIndex.url;\n      allEmojisMap.set(key, url);\n    }\n  }\n\n  return allEmojisMap;\n};\n\nvar getNicknamesMapFromMembers = function getNicknamesMapFromMembers() {\n  var members = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var nicknamesMap = new Map();\n\n  for (var memberIndex = 0; memberIndex < members.length; memberIndex += 1) {\n    var _members$memberIndex = members[memberIndex],\n        userId = _members$memberIndex.userId,\n        nickname = _members$memberIndex.nickname;\n    nicknamesMap.set(userId, nickname);\n  }\n\n  return nicknamesMap;\n};\n\nvar getMessageCreatedAt = function getMessageCreatedAt(message) {\n  return format(message.createdAt, 'p');\n};\n\nvar isSameGroup = function isSameGroup(message, comparingMessage) {\n  if (!message || !comparingMessage || !message.sender || !comparingMessage.sender || !message.createdAt || !comparingMessage.createdAt || !message.sender.userId || !comparingMessage.sender.userId) {\n    return false;\n  }\n\n  return message.sendingStatus === comparingMessage.sendingStatus && message.sender.userId === comparingMessage.sender.userId && getMessageCreatedAt(message) === getMessageCreatedAt(comparingMessage);\n};\n\nvar compareMessagesForGrouping = function compareMessagesForGrouping(prevMessage, currMessage, nextMessage) {\n  var sendingStatus = (currMessage === null || currMessage === void 0 ? void 0 : currMessage.sendingStatus) || '';\n  var isAcceptable = sendingStatus !== 'pending' && sendingStatus !== 'failed';\n  return [isSameGroup(prevMessage, currMessage) && isAcceptable, isSameGroup(currMessage, nextMessage) && isAcceptable];\n};\n\nvar hasOwnProperty = function hasOwnProperty(property) {\n  return function (payload) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (payload && payload.hasOwnProperty && payload.hasOwnProperty(property)) {\n      return true;\n    }\n\n    return false;\n  };\n};\n\nvar passUnsuccessfullMessages = function passUnsuccessfullMessages(allMessages, newMessage) {\n  var _newMessage$sendingSt = newMessage.sendingStatus,\n      sendingStatus = _newMessage$sendingSt === void 0 ? UNDEFINED : _newMessage$sendingSt;\n\n  if (sendingStatus === SUCCEEDED$1 || sendingStatus === PENDING$1) {\n    var lastIndexOfSucceededMessage = allMessages.map(function (message) {\n      return message.sendingStatus || (message.isAdminMessage && message.isAdminMessage() ? SUCCEEDED$1 : UNDEFINED);\n    }).lastIndexOf(SUCCEEDED$1);\n\n    if (lastIndexOfSucceededMessage + 1 < allMessages.length) {\n      var messages = _toConsumableArray(allMessages);\n\n      messages.splice(lastIndexOfSucceededMessage + 1, 0, newMessage);\n      return messages;\n    }\n  }\n\n  return [].concat(_toConsumableArray(allMessages), [newMessage]);\n};\n\nvar pxToNumber = function pxToNumber(px) {\n  if (typeof px === 'number') {\n    return px;\n  }\n\n  if (typeof px === 'string') {\n    var parsed = Number.parseFloat(px);\n\n    if (!Number.isNaN(parsed)) {\n      return parsed;\n    }\n  }\n\n  return null;\n};\n\nvar messagesInitialState = {\n  initialized: false,\n  loading: false,\n  allMessages: [],\n  currentGroupChannel: {\n    members: []\n  },\n  // for scrollup\n  hasMore: false,\n  lastMessageTimeStamp: 0,\n  // for scroll down\n  // onScrollDownCallback is added for navigation to different timestamps on messageSearch\n  // hasMoreToBottom, onScrollDownCallback -> scroll down\n  // hasMore, onScrollCallback -> scroll up(default behavior)\n  hasMoreToBottom: false,\n  latestFetchedMessageTimeStamp: 0,\n  emojiContainer: {},\n  unreadCount: 0,\n  unreadSince: null,\n  isInvalid: false,\n  messageListParams: null\n};\n\nvar _getSendingMessageSta = getSendingMessageStatus(),\n    SUCCEEDED = _getSendingMessageSta.SUCCEEDED,\n    FAILED = _getSendingMessageSta.FAILED,\n    PENDING = _getSendingMessageSta.PENDING;\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case RESET_STATE:\n      return messagesInitialState;\n\n    case RESET_MESSAGES:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        // when user switches channel, if the previous channel `hasMore`\n        // the onScroll gets called twice, setting hasMore false prevents this\n        hasMore: false,\n        allMessages: []\n      });\n\n    case GET_PREV_MESSAGES_START:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        loading: true\n      });\n\n    case CLEAR_SENT_MESSAGES:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        allMessages: _toConsumableArray(state.allMessages.filter(function (m) {\n          return m.sendingStatus !== SUCCEEDED;\n        }))\n      });\n\n    case GET_PREV_MESSAGES_SUCESS:\n      {\n        var receivedMessages = action.payload.messages || [];\n        var _action$payload$curre = action.payload.currentGroupChannel,\n            currentGroupChannel = _action$payload$curre === void 0 ? {} : _action$payload$curre;\n        var stateChannel = state.currentGroupChannel || {};\n        var stateChannelUrl = stateChannel.url;\n        var actionChannelUrl = currentGroupChannel.url;\n\n        if (actionChannelUrl !== stateChannelUrl) {\n          return state;\n        } // remove duplicate messages\n\n\n        var duplicatedMessageIds = [];\n        var updatedAllMessages = state.allMessages.map(function (msg) {\n          var duplicatedMessage = receivedMessages.find(function (_ref) {\n            var messageId = _ref.messageId;\n            return compareIds(messageId, msg.messageId);\n          });\n\n          if (!duplicatedMessage) {\n            return msg;\n          }\n\n          duplicatedMessageIds.push(duplicatedMessage.messageId);\n          return duplicatedMessage.updatedAt > msg.updatedAt ? duplicatedMessage : msg;\n        });\n        var filteredNewMessages = duplicatedMessageIds.length > 0 ? receivedMessages.filter(function (msg) {\n          return !duplicatedMessageIds.find(function (messageId) {\n            return compareIds(messageId, msg.messageId);\n          });\n        }) : receivedMessages;\n        var hasHasMoreToBottom = hasOwnProperty('hasMoreToBottom')(action.payload);\n        var hasLatestFetchedMessageTimeStamp = hasOwnProperty('latestFetchedMessageTimeStamp')(action.payload);\n        return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, state), {}, {\n          loading: false,\n          initialized: true,\n          hasMore: action.payload.hasMore,\n          lastMessageTimeStamp: action.payload.lastMessageTimeStamp\n        }, hasHasMoreToBottom && {\n          hasMoreToBottom: action.payload.hasMoreToBottom\n        }), hasLatestFetchedMessageTimeStamp && {\n          latestFetchedMessageTimeStamp: action.payload.latestFetchedMessageTimeStamp\n        }), {}, {\n          allMessages: [].concat(_toConsumableArray(filteredNewMessages), _toConsumableArray(updatedAllMessages))\n        });\n      }\n\n    case GET_NEXT_MESSAGES_SUCESS:\n      {\n        var _receivedMessages = action.payload.messages || [];\n\n        var _action$payload$curre2 = action.payload.currentGroupChannel,\n            _currentGroupChannel = _action$payload$curre2 === void 0 ? {} : _action$payload$curre2;\n\n        var _stateChannel = state.currentGroupChannel || {};\n\n        var _stateChannelUrl = _stateChannel.url;\n        var _actionChannelUrl = _currentGroupChannel.url;\n\n        if (_actionChannelUrl !== _stateChannelUrl) {\n          return state;\n        } // remove duplicate messages\n\n\n        var _duplicatedMessageIds = [];\n\n        var _updatedAllMessages = state.allMessages.map(function (msg) {\n          var duplicatedMessage = _receivedMessages.find(function (_ref2) {\n            var messageId = _ref2.messageId;\n            return compareIds(messageId, msg.messageId);\n          });\n\n          if (!duplicatedMessage) {\n            return msg;\n          }\n\n          _duplicatedMessageIds.push(duplicatedMessage.messageId);\n\n          return duplicatedMessage.updatedAt > msg.updatedAt ? duplicatedMessage : msg;\n        });\n\n        var _filteredNewMessages = _duplicatedMessageIds.length > 0 ? _receivedMessages.filter(function (msg) {\n          return !_duplicatedMessageIds.find(function (messageId) {\n            return compareIds(messageId, msg.messageId);\n          });\n        }) : _receivedMessages;\n\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          loading: false,\n          initialized: true,\n          hasMore: action.payload.hasMore,\n          lastMessageTimeStamp: action.payload.lastMessageTimeStamp,\n          hasMoreToBottom: action.payload.hasMoreToBottom,\n          latestFetchedMessageTimeStamp: action.payload.latestFetchedMessageTimeStamp,\n          allMessages: [].concat(_toConsumableArray(_updatedAllMessages), _toConsumableArray(_filteredNewMessages))\n        });\n      }\n\n    case GET_NEXT_MESSAGES_FAILURE:\n      {\n        return _objectSpread2({}, state);\n      }\n\n    case SEND_MESSAGEGE_START:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        allMessages: [].concat(_toConsumableArray(state.allMessages), [_objectSpread2({}, action.payload)])\n      });\n\n    case SEND_MESSAGEGE_SUCESS:\n      {\n        var newMessages = state.allMessages.map(function (m) {\n          return compareIds(m.reqId, action.payload.reqId) ? action.payload : m;\n        });\n\n        _toConsumableArray(newMessages).sort(function (a, b) {\n          return a.sendingStatus && b.sendingStatus && a.sendingStatus === SUCCEEDED && (b.sendingStatus === PENDING || b.sendingStatus === FAILED) ? -1 : 1;\n        });\n\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allMessages: newMessages\n        });\n      }\n\n    case SEND_MESSAGEGE_FAILURE:\n      {\n        // eslint-disable-next-line no-param-reassign\n        action.payload.failed = true;\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allMessages: state.allMessages.map(function (m) {\n            return compareIds(m.reqId, action.payload.reqId) ? action.payload : m;\n          })\n        });\n      }\n\n    case SET_CURRENT_CHANNEL:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          currentGroupChannel: action.payload,\n          isInvalid: false\n        });\n      }\n\n    case SET_CHANNEL_INVALID:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          isInvalid: true\n        });\n      }\n\n    case UPDATE_UNREAD_COUNT:\n      {\n        var channel = action.payload.channel;\n\n        var _state$currentGroupCh = state.currentGroupChannel,\n            _currentGroupChannel2 = _state$currentGroupCh === void 0 ? {} : _state$currentGroupCh,\n            unreadCount = state.unreadCount;\n\n        var currentGroupChannelUrl = _currentGroupChannel2.url;\n\n        if (!compareIds(channel.url, currentGroupChannelUrl)) {\n          return state;\n        }\n\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          unreadSince: unreadCount + 1\n        });\n      }\n\n    case ON_MESSAGE_RECEIVED:\n      {\n        var _action$payload = action.payload,\n            _channel = _action$payload.channel,\n            message = _action$payload.message,\n            scrollToEnd = _action$payload.scrollToEnd;\n        var _unreadCount = 0;\n\n        var _state$currentGroupCh2 = state.currentGroupChannel,\n            _currentGroupChannel3 = _state$currentGroupCh2 === void 0 ? {} : _state$currentGroupCh2,\n            unreadSince = state.unreadSince;\n\n        var _currentGroupChannelUrl = _currentGroupChannel3.url;\n\n        if (!compareIds(_channel.url, _currentGroupChannelUrl)) {\n          return state;\n        } // Excluded overlapping messages\n\n\n        if (state.allMessages.some(function (msg) {\n          return msg.messageId === message.messageId;\n        })) {\n          return state;\n        } // Filter by userFilledQuery\n\n\n        if (state.messageListParams && !filterMessageListParams(state.messageListParams, message)) {\n          return state;\n        }\n\n        _unreadCount = state.unreadCount + 1; // reset unreadCount if have to scrollToEnd\n\n        if (scrollToEnd) {\n          _unreadCount = 0;\n        }\n\n        if (message.isAdminMessage && message.isAdminMessage()) {\n          return _objectSpread2(_objectSpread2({}, state), {}, {\n            allMessages: passUnsuccessfullMessages(state.allMessages, message)\n          });\n        }\n\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          unreadCount: _unreadCount,\n          unreadSince: _unreadCount === 1 ? format(new Date(), 'p MMM dd') : unreadSince,\n          allMessages: passUnsuccessfullMessages(state.allMessages, message)\n        });\n      }\n\n    case ON_MESSAGE_UPDATED:\n      {\n        var _action$payload2 = action.payload,\n            _channel2 = _action$payload2.channel,\n            _message = _action$payload2.message;\n\n        var _currentGroupChannelUrl2 = state.currentGroupChannel && state.currentGroupChannel.url || '';\n\n        if (!compareIds(_channel2.url, _currentGroupChannelUrl2)) {\n          return state; // Ignore event when it is not for the current channel\n        }\n\n        if (state.messageListParams && !filterMessageListParams(state.messageListParams, _message)) {\n          // Delete the message if it doesn't match to the params anymore\n          return _objectSpread2(_objectSpread2({}, state), {}, {\n            allMessages: state.allMessages.filter(function (m) {\n              return !compareIds(m.messageId, _message === null || _message === void 0 ? void 0 : _message.messageId);\n            })\n          });\n        }\n\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allMessages: state.allMessages.map(function (m) {\n            return compareIds(m.messageId, action.payload.message.messageId) ? action.payload.message : m;\n          })\n        });\n      }\n\n    case ON_MESSAGE_THREAD_INFO_UPDATED:\n      {\n        var _action$payload3 = action.payload,\n            _channel3 = _action$payload3.channel,\n            event = _action$payload3.event;\n        var channelUrl = event.channelUrl,\n            threadInfo = event.threadInfo,\n            targetMessageId = event.targetMessageId;\n\n        var _currentGroupChannelUrl3 = state.currentGroupChannel && state.currentGroupChannel.url || '';\n\n        if (!compareIds(_channel3.url, _currentGroupChannelUrl3) || !compareIds(_channel3.url, channelUrl)) {\n          return state; // Ignore event when it is not for the current channel\n        }\n\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allMessages: state.allMessages.map(function (m) {\n            if (compareIds(m.messageId, targetMessageId)) {\n              // eslint-disable-next-line no-param-reassign\n              m.threadInfo = threadInfo; // Upsert threadInfo to the target message\n            }\n\n            return m;\n          })\n        });\n      }\n\n    case RESEND_MESSAGEGE_START:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        allMessages: state.allMessages.map(function (m) {\n          return compareIds(m.reqId, action.payload.reqId) ? action.payload : m;\n        })\n      });\n\n    case MARK_AS_READ:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        unreadCount: 0,\n        unreadSince: null\n      });\n\n    case ON_MESSAGE_DELETED:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        allMessages: state.allMessages.filter(function (m) {\n          return !compareIds(m.messageId, action.payload);\n        })\n      });\n\n    case ON_MESSAGE_DELETED_BY_REQ_ID:\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        allMessages: state.allMessages.filter(function (m) {\n          return !compareIds(m.reqId, action.payload);\n        })\n      });\n\n    case SET_EMOJI_CONTAINER:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          emojiContainer: action.payload\n        });\n      }\n\n    case ON_REACTION_UPDATED:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allMessages: state.allMessages.map(function (m) {\n            if (compareIds(m.messageId, action.payload.messageId)) {\n              if (m.applyReactionEvent && typeof m.applyReactionEvent === 'function') {\n                m.applyReactionEvent(action.payload);\n              }\n\n              return m;\n            }\n\n            return m;\n          })\n        });\n      }\n\n    case MESSAGE_LIST_PARAMS_CHANGED:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          messageListParams: action.payload\n        });\n      }\n\n    default:\n      return state;\n  }\n}\n/**\n * Handles ChannelEvents and send values to dispatcher using messagesDispatcher\n * messagesDispatcher: Dispatcher\n * sdk: sdkInstance\n * logger: loggerInstance\n * channelUrl: string\n * sdkInit: bool\n */\n\n\nfunction useHandleChannelEvents(_ref, _ref2) {\n  var currentGroupChannel = _ref.currentGroupChannel,\n      sdkInit = _ref.sdkInit,\n      hasMoreToBottom = _ref.hasMoreToBottom;\n  var messagesDispatcher = _ref2.messagesDispatcher,\n      sdk = _ref2.sdk,\n      logger = _ref2.logger,\n      scrollRef = _ref2.scrollRef,\n      setQuoteMessage = _ref2.setQuoteMessage;\n  var channelUrl = currentGroupChannel && currentGroupChannel.url;\n  useEffect(function () {\n    var messageReceiverId = uuidv4();\n\n    if (channelUrl && sdk && sdk.ChannelHandler) {\n      var ChannelHandler = new sdk.ChannelHandler();\n      logger.info('Channel | useHandleChannelEvents: Setup event handler', messageReceiverId);\n\n      ChannelHandler.onMessageReceived = function (channel, message) {\n        // donot update if hasMoreToBottom\n        if (compareIds(channel.url, currentGroupChannel.url) && !hasMoreToBottom) {\n          var scrollToEnd = false;\n\n          try {\n            var current = scrollRef.current;\n            scrollToEnd = current.offsetHeight + current.scrollTop >= current.scrollHeight;\n          } catch (error) {//\n          }\n\n          logger.info('Channel | useHandleChannelEvents: onMessageReceived', message);\n          messagesDispatcher({\n            type: ON_MESSAGE_RECEIVED,\n            payload: {\n              channel: channel,\n              message: message,\n              scrollToEnd: scrollToEnd\n            }\n          });\n\n          if (scrollToEnd) {\n            try {\n              setTimeout(function () {\n                currentGroupChannel.markAsRead();\n                scrollIntoLast();\n              });\n            } catch (error) {\n              logger.warning('Channel | onMessageReceived | scroll to end failed');\n            }\n          }\n        }\n\n        if (compareIds(channel.url, currentGroupChannel.url) && hasMoreToBottom) {\n          messagesDispatcher({\n            type: UPDATE_UNREAD_COUNT,\n            payload: {\n              channel: channel\n            }\n          });\n        }\n      };\n\n      ChannelHandler.onMessageUpdated = function (channel, message) {\n        logger.info('Channel | useHandleChannelEvents: onMessageUpdated', message);\n        messagesDispatcher({\n          type: ON_MESSAGE_UPDATED,\n          payload: {\n            channel: channel,\n            message: message\n          }\n        });\n      };\n\n      ChannelHandler.onThreadInfoUpdated = function (channel, event) {\n        logger.info('Channel | useHandleChannelEvents: onThreadInfoUpdated', event);\n        messagesDispatcher({\n          type: ON_MESSAGE_THREAD_INFO_UPDATED,\n          payload: {\n            channel: channel,\n            event: event\n          }\n        });\n      };\n\n      ChannelHandler.onMessageDeleted = function (_, messageId) {\n        logger.info('Channel | useHandleChannelEvents: onMessageDeleted', messageId);\n        setQuoteMessage(null);\n        messagesDispatcher({\n          type: ON_MESSAGE_DELETED,\n          payload: messageId\n        });\n      };\n\n      ChannelHandler.onReactionUpdated = function (_, reactionEvent) {\n        logger.info('Channel | useHandleChannelEvents: onReactionUpdated', reactionEvent);\n        messagesDispatcher({\n          type: ON_REACTION_UPDATED,\n          payload: reactionEvent\n        });\n      };\n\n      ChannelHandler.onChannelChanged = function (groupChannel) {\n        if (compareIds(groupChannel.url, currentGroupChannel.url)) {\n          logger.info('Channel | useHandleChannelEvents: onChannelChanged', groupChannel);\n          messagesDispatcher({\n            type: SET_CURRENT_CHANNEL,\n            payload: groupChannel\n          });\n        }\n      };\n\n      ChannelHandler.onChannelFrozen = function (groupChannel) {\n        if (compareIds(groupChannel.url, currentGroupChannel.url)) {\n          logger.info('Channel | useHandleChannelEvents: onChannelFrozen', groupChannel);\n          messagesDispatcher({\n            type: SET_CURRENT_CHANNEL,\n            payload: groupChannel\n          });\n        }\n      };\n\n      ChannelHandler.onChannelUnfrozen = function (groupChannel) {\n        if (compareIds(groupChannel.url, currentGroupChannel.url)) {\n          logger.info('Channel | useHandleChannelEvents: onChannelUnFrozen', groupChannel);\n          messagesDispatcher({\n            type: SET_CURRENT_CHANNEL,\n            payload: groupChannel\n          });\n        }\n      };\n\n      ChannelHandler.onUserMuted = function (groupChannel) {\n        if (compareIds(groupChannel.url, currentGroupChannel.url)) {\n          logger.info('Channel | useHandleChannelEvents: onUserMuted', groupChannel);\n          messagesDispatcher({\n            type: SET_CURRENT_CHANNEL,\n            payload: groupChannel\n          });\n        }\n      };\n\n      ChannelHandler.onUserUnmuted = function (groupChannel) {\n        if (compareIds(groupChannel.url, currentGroupChannel.url)) {\n          logger.info('Channel | useHandleChannelEvents: onUserUnmuted', groupChannel);\n          messagesDispatcher({\n            type: SET_CURRENT_CHANNEL,\n            payload: groupChannel\n          });\n        }\n      };\n\n      ChannelHandler.onUserBanned = function (groupChannel) {\n        if (compareIds(groupChannel.url, currentGroupChannel.url)) {\n          logger.info('Channel | useHandleChannelEvents: onUserBanned', groupChannel);\n          messagesDispatcher({\n            type: SET_CURRENT_CHANNEL,\n            payload: groupChannel\n          });\n        }\n      };\n\n      ChannelHandler.onOperatorUpdated = function (groupChannel) {\n        if (compareIds(groupChannel.url, currentGroupChannel.url)) {\n          logger.info('Channel | useHandleChannelEvents: onOperatorUpdated', groupChannel);\n          messagesDispatcher({\n            type: SET_CURRENT_CHANNEL,\n            payload: groupChannel\n          });\n        }\n      }; // Add this channel event handler to the SendBird object.\n\n\n      sdk.addChannelHandler(messageReceiverId, ChannelHandler);\n    }\n\n    return function () {\n      if (sdk && sdk.removeChannelHandler) {\n        logger.info('Channel | useHandleChannelEvents: Removing message reciver handler', messageReceiverId);\n        sdk.removeChannelHandler(messageReceiverId);\n      }\n    };\n  }, [channelUrl, sdkInit]);\n}\n\nfunction useSetChannel(_ref, _ref2) {\n  var channelUrl = _ref.channelUrl,\n      sdkInit = _ref.sdkInit;\n  var messagesDispatcher = _ref2.messagesDispatcher,\n      sdk = _ref2.sdk,\n      logger = _ref2.logger;\n  useEffect(function () {\n    if (channelUrl && sdkInit && sdk && sdk.GroupChannel) {\n      logger.info('Channel | useSetChannel fetching channel', channelUrl);\n      sdk.GroupChannel.getChannel(channelUrl).then(function (groupChannel) {\n        logger.info('Channel | useSetChannel fetched channel', groupChannel);\n        messagesDispatcher({\n          type: SET_CURRENT_CHANNEL,\n          payload: groupChannel\n        });\n        logger.info('Channel: Mark as read', groupChannel); // this order is important - this mark as read should update the event handler up above\n\n        groupChannel.markAsRead();\n      }).catch(function (e) {\n        logger.warning('Channel | useSetChannel fetch channel failed', {\n          channelUrl: channelUrl,\n          e: e\n        });\n        messagesDispatcher({\n          type: SET_CHANNEL_INVALID\n        });\n      });\n      sdk.getAllEmoji(function (emojiContainer_, err) {\n        if (err) {\n          logger.error('Channel: Getting emojis failed', err);\n          return;\n        }\n\n        logger.info('Channel: Getting emojis success', emojiContainer_);\n        messagesDispatcher({\n          type: SET_EMOJI_CONTAINER,\n          payload: emojiContainer_\n        });\n      });\n    }\n  }, [channelUrl, sdkInit]);\n}\n\nvar PREV_RESULT_SIZE = 30;\nvar NEXT_RESULT_SIZE = 10;\n\nvar getLatestMessageTimeStamp = function getLatestMessageTimeStamp() {\n  var messages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var latestMessage = messages[messages.length - 1];\n  return latestMessage && latestMessage.createdAt || null;\n};\n\nfunction useInitialMessagesFetch(_ref, _ref2) {\n  var currentGroupChannel = _ref.currentGroupChannel,\n      userFilledMessageListQuery = _ref.userFilledMessageListQuery,\n      intialTimeStamp = _ref.intialTimeStamp,\n      replyType = _ref.replyType;\n  var sdk = _ref2.sdk,\n      logger = _ref2.logger,\n      messagesDispatcher = _ref2.messagesDispatcher;\n  var channelUrl = currentGroupChannel && currentGroupChannel.url;\n  useEffect(function () {\n    logger.info('Channel useInitialMessagesFetch: Setup started', currentGroupChannel);\n    messagesDispatcher({\n      type: RESET_MESSAGES\n    });\n\n    if (sdk && sdk.MessageListParams && currentGroupChannel && currentGroupChannel.getMessagesByTimestamp) {\n      var messageListParams = new sdk.MessageListParams();\n      messageListParams.prevResultSize = PREV_RESULT_SIZE;\n      messageListParams.isInclusive = true;\n      messageListParams.includeReplies = false;\n      messageListParams.includeReaction = true;\n\n      if (replyType && replyType === 'QUOTE_REPLY') {\n        messageListParams.includeThreadInfo = true;\n        messageListParams.includeParentMessageInfo = true;\n        messageListParams.replyType = 'only_reply_to_channel';\n      }\n\n      if (userFilledMessageListQuery) {\n        Object.keys(userFilledMessageListQuery).forEach(function (key) {\n          messageListParams[key] = userFilledMessageListQuery[key];\n        });\n      }\n\n      if (replyType && replyType === 'QUOTE_REPLY' || userFilledMessageListQuery) {\n        logger.info('Channel useInitialMessagesFetch: Setup messageListParams', messageListParams);\n        messagesDispatcher({\n          type: MESSAGE_LIST_PARAMS_CHANGED,\n          payload: messageListParams\n        });\n      }\n\n      logger.info('Channel: Fetching messages', {\n        currentGroupChannel: currentGroupChannel,\n        userFilledMessageListQuery: userFilledMessageListQuery\n      });\n      messagesDispatcher({\n        type: GET_PREV_MESSAGES_START\n      });\n\n      if (intialTimeStamp) {\n        messageListParams.nextResultSize = NEXT_RESULT_SIZE;\n        currentGroupChannel.getMessagesByTimestamp(intialTimeStamp, messageListParams).then(function (messages) {\n          var hasMore = messages && messages.length > 0;\n          var lastMessageTimeStamp = hasMore ? messages[0].createdAt : null;\n          var latestFetchedMessageTimeStamp = getLatestMessageTimeStamp(messages); // to make sure there are no more messages below\n\n          var nextMessageListParams = new sdk.MessageListParams();\n          nextMessageListParams.nextResultSize = NEXT_RESULT_SIZE;\n          nextMessageListParams.isInclusive = true;\n          nextMessageListParams.includeReplies = false;\n          nextMessageListParams.includeReaction = true;\n\n          if (replyType && replyType === 'QUOTE_REPLY') {\n            nextMessageListParams.includeThreadInfo = true;\n            nextMessageListParams.includeParentMessageInfo = true;\n            nextMessageListParams.replyType = 'only_reply_to_channel';\n          }\n\n          if (userFilledMessageListQuery) {\n            Object.keys(userFilledMessageListQuery).forEach(function (key) {\n              nextMessageListParams[key] = userFilledMessageListQuery[key];\n            });\n          }\n\n          currentGroupChannel.getMessagesByTimestamp(latestFetchedMessageTimeStamp || new Date().getTime(), nextMessageListParams).then(function (nextMessages) {\n            messagesDispatcher({\n              type: GET_PREV_MESSAGES_SUCESS,\n              payload: {\n                messages: messages,\n                hasMore: hasMore,\n                lastMessageTimeStamp: lastMessageTimeStamp,\n                currentGroupChannel: currentGroupChannel,\n                latestFetchedMessageTimeStamp: latestFetchedMessageTimeStamp,\n                hasMoreToBottom: nextMessages && nextMessages.length > 0\n              }\n            });\n          });\n        }).catch(function (error) {\n          logger.error('Channel: Fetching messages failed', error);\n          messagesDispatcher({\n            type: GET_PREV_MESSAGES_SUCESS,\n            payload: {\n              messages: [],\n              hasMore: false,\n              lastMessageTimeStamp: 0,\n              currentGroupChannel: currentGroupChannel\n            }\n          });\n        }).finally(function () {\n          if (!intialTimeStamp) {\n            setTimeout(function () {\n              return scrollIntoLast();\n            });\n          }\n\n          currentGroupChannel.markAsRead();\n        });\n      } else {\n        currentGroupChannel.getMessagesByTimestamp(new Date().getTime(), messageListParams).then(function (messages) {\n          var hasMore = messages && messages.length > 0;\n          var lastMessageTimeStamp = hasMore ? messages[0].createdAt : null;\n          var latestFetchedMessageTimeStamp = getLatestMessageTimeStamp(messages);\n          messagesDispatcher({\n            type: GET_PREV_MESSAGES_SUCESS,\n            payload: {\n              messages: messages,\n              hasMore: hasMore,\n              lastMessageTimeStamp: lastMessageTimeStamp,\n              currentGroupChannel: currentGroupChannel,\n              latestFetchedMessageTimeStamp: latestFetchedMessageTimeStamp,\n              hasMoreToBottom: false\n            }\n          });\n        }).catch(function (error) {\n          logger.error('Channel: Fetching messages failed', error);\n          messagesDispatcher({\n            type: GET_PREV_MESSAGES_SUCESS,\n            payload: {\n              messages: [],\n              hasMore: false,\n              lastMessageTimeStamp: 0,\n              currentGroupChannel: currentGroupChannel\n            }\n          });\n        }).finally(function () {\n          if (!intialTimeStamp) {\n            setTimeout(function () {\n              return scrollIntoLast();\n            });\n          }\n\n          currentGroupChannel.markAsRead();\n        });\n      }\n    }\n  }, [channelUrl, userFilledMessageListQuery, intialTimeStamp]);\n  /**\n   * Note - useEffect(() => {}, [currentGroupChannel])\n   * was buggy, that is why we did\n   * const channelUrl = currentGroupChannel && currentGroupChannel.url;\n   * useEffect(() => {}, [channelUrl])\n   * Again, this hook is supposed to execute when currentGroupChannel changes\n   * The 'channelUrl' here is not the same memory reference from Conversation.props\n   */\n}\n\nfunction useHandleReconnect(_a, _b) {\n  var isOnline = _a.isOnline,\n      replyType = _a.replyType;\n  var logger = _b.logger,\n      sdk = _b.sdk,\n      currentGroupChannel = _b.currentGroupChannel,\n      messagesDispatcher = _b.messagesDispatcher,\n      userFilledMessageListQuery = _b.userFilledMessageListQuery;\n  useEffect(function () {\n    var wasOffline = !isOnline;\n    return function () {\n      var _a; // state changed from offline to online\n\n\n      if (wasOffline && (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url)) {\n        logger.info('Refreshing conversation state');\n        var useReaction = ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.isUsingReaction) || false;\n        var messageListParams_1 = new sdk.MessageListParams();\n        messageListParams_1.prevResultSize = 30;\n        messageListParams_1.isInclusive = true;\n        messageListParams_1.includeReplies = false;\n        messageListParams_1.includeReaction = useReaction;\n\n        if (replyType && replyType === 'QUOTE_REPLY') {\n          messageListParams_1.includeThreadInfo = true;\n          messageListParams_1.includeParentMessageInfo = true;\n          messageListParams_1.replyType = 'only_reply_to_channel';\n        }\n\n        if (userFilledMessageListQuery) {\n          Object.keys(userFilledMessageListQuery).forEach(function (key) {\n            messageListParams_1[key] = userFilledMessageListQuery[key];\n          });\n        }\n\n        logger.info('Channel: Fetching messages', {\n          currentGroupChannel: currentGroupChannel,\n          userFilledMessageListQuery: userFilledMessageListQuery\n        });\n        messagesDispatcher({\n          type: GET_PREV_MESSAGES_START,\n          payload: null\n        });\n        sdk.GroupChannel.getChannel(currentGroupChannel.url).then(function (groupChannel) {\n          var lastMessageTime = new Date().getTime();\n          groupChannel.getMessagesByTimestamp(lastMessageTime, messageListParams_1).then(function (messages) {\n            messagesDispatcher({\n              type: CLEAR_SENT_MESSAGES,\n              payload: null\n            });\n            var hasMore = (messages === null || messages === void 0 ? void 0 : messages.length) > 0;\n            var lastMessageTimeStamp = hasMore ? messages[0].createdAt : null;\n            messagesDispatcher({\n              type: GET_PREV_MESSAGES_SUCESS,\n              payload: {\n                messages: messages,\n                hasMore: hasMore,\n                lastMessageTimeStamp: lastMessageTimeStamp,\n                currentGroupChannel: currentGroupChannel\n              }\n            });\n            setTimeout(function () {\n              return scrollIntoLast();\n            });\n          }).catch(function (error) {\n            logger.error('Channel: Fetching messages failed', error);\n          }).finally(function () {\n            var _a;\n\n            (_a = currentGroupChannel.markAsRead) === null || _a === void 0 ? void 0 : _a.call(currentGroupChannel);\n          });\n        });\n      }\n    };\n  }, [isOnline, replyType]);\n}\n\nfunction useScrollCallback(_ref, _ref2) {\n  var currentGroupChannel = _ref.currentGroupChannel,\n      lastMessageTimeStamp = _ref.lastMessageTimeStamp,\n      userFilledMessageListQuery = _ref.userFilledMessageListQuery,\n      replyType = _ref.replyType;\n  var hasMore = _ref2.hasMore,\n      logger = _ref2.logger,\n      messagesDispatcher = _ref2.messagesDispatcher,\n      sdk = _ref2.sdk;\n  return useCallback(function (cb) {\n    if (!hasMore) {\n      return;\n    }\n\n    var _sdk$appInfo = sdk.appInfo,\n        appInfo = _sdk$appInfo === void 0 ? {} : _sdk$appInfo;\n    var useReaction = appInfo.isUsingReaction || false;\n    var messageListParams = new sdk.MessageListParams();\n    messageListParams.prevResultSize = 30;\n    messageListParams.isInclusive = true;\n    messageListParams.includeReplies = false;\n    messageListParams.includeReaction = useReaction;\n\n    if (replyType && replyType === 'QUOTE_REPLY') {\n      messageListParams.includeThreadInfo = true;\n      messageListParams.includeParentMessageInfo = true;\n      messageListParams.replyType = 'only_reply_to_channel';\n    }\n\n    if (userFilledMessageListQuery) {\n      Object.keys(userFilledMessageListQuery).forEach(function (key) {\n        messageListParams[key] = userFilledMessageListQuery[key];\n      });\n    }\n\n    logger.info('Channel: Fetching messages', {\n      currentGroupChannel: currentGroupChannel,\n      userFilledMessageListQuery: userFilledMessageListQuery\n    });\n    currentGroupChannel.getMessagesByTimestamp(lastMessageTimeStamp || new Date().getTime(), messageListParams).then(function (messages) {\n      var hasMoreMessages = messages && messages.length > 0;\n      var lastMessageTs = hasMoreMessages ? messages[0].createdAt : null;\n      messagesDispatcher({\n        type: GET_PREV_MESSAGES_SUCESS,\n        payload: {\n          messages: messages,\n          hasMore: hasMoreMessages,\n          lastMessageTimeStamp: lastMessageTs,\n          currentGroupChannel: currentGroupChannel\n        }\n      });\n      cb([messages, null]);\n    }).catch(function (error) {\n      logger.error('Channel: Fetching messages failed', error);\n      messagesDispatcher({\n        type: GET_PREV_MESSAGES_SUCESS,\n        payload: {\n          messages: [],\n          hasMore: false,\n          lastMessageTimeStamp: 0,\n          currentGroupChannel: currentGroupChannel\n        }\n      });\n      cb([null, error]);\n    }).finally(function () {\n      currentGroupChannel.markAsRead();\n    });\n  }, [currentGroupChannel, lastMessageTimeStamp, replyType]);\n}\n\nvar RESULT_SIZE = 30;\n\nfunction useScrollDownCallback(_ref, _ref2) {\n  var currentGroupChannel = _ref.currentGroupChannel,\n      latestFetchedMessageTimeStamp = _ref.latestFetchedMessageTimeStamp,\n      userFilledMessageListQuery = _ref.userFilledMessageListQuery,\n      hasMoreToBottom = _ref.hasMoreToBottom,\n      replyType = _ref.replyType;\n  var logger = _ref2.logger,\n      messagesDispatcher = _ref2.messagesDispatcher,\n      sdk = _ref2.sdk;\n  return useCallback(function (cb) {\n    if (!hasMoreToBottom) {\n      return;\n    }\n\n    var _sdk$appInfo = sdk.appInfo,\n        appInfo = _sdk$appInfo === void 0 ? {} : _sdk$appInfo;\n    var useReaction = appInfo.isUsingReaction || false;\n    var messageListParams = new sdk.MessageListParams();\n    messageListParams.nextResultSize = RESULT_SIZE;\n    messageListParams.isInclusive = true;\n    messageListParams.includeReplies = false;\n    messageListParams.includeReaction = useReaction;\n\n    if (replyType && replyType === 'QUOTE_REPLY') {\n      messageListParams.includeThreadInfo = true;\n      messageListParams.includeParentMessageInfo = true;\n      messageListParams.replyType = 'only_reply_to_channel';\n    }\n\n    if (userFilledMessageListQuery) {\n      Object.keys(userFilledMessageListQuery).forEach(function (key) {\n        messageListParams[key] = userFilledMessageListQuery[key];\n      });\n    }\n\n    logger.info('Channel: Fetching later messages', {\n      currentGroupChannel: currentGroupChannel,\n      userFilledMessageListQuery: userFilledMessageListQuery\n    });\n    currentGroupChannel.getMessagesByTimestamp(latestFetchedMessageTimeStamp || new Date().getTime(), messageListParams).then(function (messages) {\n      var messagesLength = messages && messages.length || 0;\n      var hasMoreMessages = messagesLength > 0 && messageListParams.nextResultSize === messagesLength;\n      var lastMessageTs = hasMoreMessages ? messages[messages.length - 1].createdAt : null;\n      messagesDispatcher({\n        type: GET_NEXT_MESSAGES_SUCESS,\n        payload: {\n          messages: messages,\n          hasMoreToBottom: hasMoreMessages,\n          latestFetchedMessageTimeStamp: lastMessageTs,\n          currentGroupChannel: currentGroupChannel\n        }\n      });\n      cb([messages, null]);\n    }).catch(function (error) {\n      logger.error('Channel: Fetching later messages failed', error);\n      messagesDispatcher({\n        type: GET_NEXT_MESSAGES_FAILURE,\n        payload: {\n          messages: [],\n          hasMoreToBottom: false,\n          latestFetchedMessageTimeStamp: 0,\n          currentGroupChannel: currentGroupChannel\n        }\n      });\n      cb([null, error]);\n    }).finally(function () {\n      currentGroupChannel.markAsRead();\n    });\n  }, [currentGroupChannel, latestFetchedMessageTimeStamp, hasMoreToBottom, replyType]);\n}\n\nfunction useDeleteMessageCallback(_ref, _ref2) {\n  var currentGroupChannel = _ref.currentGroupChannel,\n      messagesDispatcher = _ref.messagesDispatcher;\n  var logger = _ref2.logger;\n  return useCallback(function (message, cb) {\n    logger.info('Channel | useDeleteMessageCallback: Deleting message', message);\n    var requestState = message.requestState;\n    logger.info('Channel | useDeleteMessageCallback: Deleting message requestState:', requestState); // Message is only on local\n\n    if (requestState === 'failed' || requestState === 'pending') {\n      logger.info('Channel | useDeleteMessageCallback: Deleted message from local:', message);\n      messagesDispatcher({\n        type: ON_MESSAGE_DELETED_BY_REQ_ID,\n        payload: message.reqId\n      });\n\n      if (cb) {\n        cb();\n      }\n\n      return;\n    } // Message is on server\n\n\n    currentGroupChannel.deleteMessage(message, function (err) {\n      logger.info('Channel | useDeleteMessageCallback: Deleting message from remote:', requestState);\n\n      if (cb) {\n        cb(err);\n      }\n\n      if (!err) {\n        logger.info('Channel | useDeleteMessageCallback: Deleting message success!', message);\n        messagesDispatcher({\n          type: ON_MESSAGE_DELETED,\n          payload: message.messageId\n        });\n      } else {\n        logger.warning('Channel | useDeleteMessageCallback: Deleting message failed!', err);\n      }\n    });\n  }, [currentGroupChannel, messagesDispatcher]);\n}\n\nfunction useUpdateMessageCallback(_ref, _ref2) {\n  var currentGroupChannel = _ref.currentGroupChannel,\n      messagesDispatcher = _ref.messagesDispatcher,\n      onBeforeUpdateUserMessage = _ref.onBeforeUpdateUserMessage;\n  var logger = _ref2.logger,\n      pubSub = _ref2.pubSub,\n      sdk = _ref2.sdk;\n  return useCallback(function (messageId, text, cb) {\n    var createParamsDefault = function createParamsDefault(txt) {\n      var params = new sdk.UserMessageParams();\n      params.message = txt;\n      return params;\n    };\n\n    var createCustomPrams = onBeforeUpdateUserMessage && typeof onBeforeUpdateUserMessage === 'function';\n\n    if (createCustomPrams) {\n      logger.info('Channel: creating params using onBeforeUpdateUserMessage', onBeforeUpdateUserMessage);\n    }\n\n    var params = onBeforeUpdateUserMessage ? onBeforeUpdateUserMessage(text) : createParamsDefault(text);\n    currentGroupChannel.updateUserMessage(messageId, params, function (r, e) {\n      logger.info('Channel: Updating message!', params);\n      var swapParams = sdk.getErrorFirstCallback();\n      var message = r;\n      var err = e;\n\n      if (swapParams) {\n        message = e;\n        err = r;\n      }\n\n      if (cb) {\n        cb(err, message);\n      }\n\n      if (!err) {\n        logger.info('Channel: Updating message success!', message);\n        messagesDispatcher({\n          type: ON_MESSAGE_UPDATED,\n          payload: {\n            channel: currentGroupChannel,\n            message: message\n          }\n        });\n        pubSub.publish(UPDATE_USER_MESSAGE, {\n          message: message,\n          channel: currentGroupChannel\n        });\n      } else {\n        logger.warning('Channel: Updating message failed!', err);\n      }\n    });\n  }, [currentGroupChannel.url, messagesDispatcher, onBeforeUpdateUserMessage]);\n}\n\nfunction useResendMessageCallback(_ref, _ref2) {\n  var currentGroupChannel = _ref.currentGroupChannel,\n      messagesDispatcher = _ref.messagesDispatcher;\n  var logger = _ref2.logger;\n  return useCallback(function (failedMessage) {\n    logger.info('Channel: Resending message has started', failedMessage);\n    var messageType = failedMessage.messageType,\n        file = failedMessage.file;\n\n    if (failedMessage && typeof failedMessage.isResendable === 'function' && failedMessage.isResendable()) {\n      // eslint-disable-next-line no-param-reassign\n      failedMessage.requestState = 'pending';\n      messagesDispatcher({\n        type: RESEND_MESSAGEGE_START,\n        payload: failedMessage\n      }); // userMessage\n\n      if (messageType === 'user') {\n        currentGroupChannel.resendUserMessage(failedMessage).then(function (message) {\n          logger.info('Channel: Resending message success!', {\n            message: message\n          });\n          messagesDispatcher({\n            type: SEND_MESSAGEGE_SUCESS,\n            payload: message\n          });\n        }).catch(function (e) {\n          logger.warning('Channel: Resending message failed!', {\n            e: e\n          }); // eslint-disable-next-line no-param-reassign\n\n          failedMessage.requestState = 'failed';\n          messagesDispatcher({\n            type: SEND_MESSAGEGE_FAILURE,\n            payload: failedMessage\n          });\n        }); // eslint-disable-next-line no-param-reassign\n\n        failedMessage.requestState = 'pending';\n        messagesDispatcher({\n          type: RESEND_MESSAGEGE_START,\n          payload: failedMessage\n        });\n        return;\n      }\n\n      if (messageType === 'file') {\n        currentGroupChannel.resendFileMessage(failedMessage, file).then(function (message) {\n          logger.info('Channel: Resending file message success!', {\n            message: message\n          });\n          messagesDispatcher({\n            type: SEND_MESSAGEGE_SUCESS,\n            payload: message\n          });\n        }).catch(function (e) {\n          logger.warning('Channel: Resending file message failed!', {\n            e: e\n          }); // eslint-disable-next-line no-param-reassign\n\n          failedMessage.requestState = 'failed';\n          messagesDispatcher({\n            type: SEND_MESSAGEGE_FAILURE,\n            payload: failedMessage\n          });\n        }); // eslint-disable-next-line no-param-reassign\n\n        failedMessage.requestState = 'pending';\n        messagesDispatcher({\n          type: RESEND_MESSAGEGE_START,\n          payload: failedMessage\n        });\n      }\n    } else {\n      // to alert user on console\n      // eslint-disable-next-line no-console\n      console.error('Message is not resendable');\n      logger.warning('Message is not resendable', failedMessage);\n    }\n  }, [currentGroupChannel, messagesDispatcher]);\n}\n\nfunction useSendMessageCallback(_ref, _ref2) {\n  var currentGroupChannel = _ref.currentGroupChannel,\n      onBeforeSendUserMessage = _ref.onBeforeSendUserMessage;\n  var sdk = _ref2.sdk,\n      logger = _ref2.logger,\n      pubSub = _ref2.pubSub,\n      messagesDispatcher = _ref2.messagesDispatcher;\n  var messageInputRef = useRef(null);\n  var sendMessage = useCallback(function () {\n    var quoteMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var text = messageInputRef.current.value;\n\n    var createParamsDefault = function createParamsDefault(txt) {\n      var message = typeof txt === 'string' ? txt.trim() : txt;\n      var params = new sdk.UserMessageParams();\n      params.message = message;\n\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n\n      return params;\n    };\n\n    var createCustomPrams = onBeforeSendUserMessage && typeof onBeforeSendUserMessage === 'function';\n\n    if (createCustomPrams) {\n      logger.info('Channel: creating params using onBeforeSendUserMessage', onBeforeSendUserMessage);\n    }\n\n    var params = onBeforeSendUserMessage ? onBeforeSendUserMessage(text, quoteMessage) : createParamsDefault(text);\n    logger.info('Channel: Sending message has started', params);\n    var pendingMsg = currentGroupChannel.sendUserMessage(params, function (res, err) {\n      var swapParams = sdk.getErrorFirstCallback();\n      var message = res;\n      var error = err;\n\n      if (swapParams) {\n        message = err;\n        error = res;\n      } // sending params instead of pending message\n      // to make sure that we can resend the message once it fails\n\n\n      if (error) {\n        logger.warning('Channel: Sending message failed!', {\n          message: message\n        });\n        messagesDispatcher({\n          type: SEND_MESSAGEGE_FAILURE,\n          payload: message\n        });\n        return;\n      }\n\n      logger.info('Channel: Sending message success!', message);\n      messagesDispatcher({\n        type: SEND_MESSAGEGE_SUCESS,\n        payload: message\n      });\n    });\n    pubSub.publish(SEND_MESSAGE_START, {\n      /* pubSub is used instead of messagesDispatcher\n        to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n      message: pendingMsg,\n      channel: currentGroupChannel\n    });\n    setTimeout(function () {\n      return scrollIntoLast();\n    });\n  }, [currentGroupChannel, onBeforeSendUserMessage]);\n  return [messageInputRef, sendMessage];\n}\n\nfunction useSendFileMessageCallback(_ref, _ref2) {\n  var currentGroupChannel = _ref.currentGroupChannel,\n      onBeforeSendFileMessage = _ref.onBeforeSendFileMessage,\n      _ref$imageCompression = _ref.imageCompression,\n      imageCompression = _ref$imageCompression === void 0 ? {} : _ref$imageCompression;\n  var sdk = _ref2.sdk,\n      logger = _ref2.logger,\n      pubSub = _ref2.pubSub,\n      messagesDispatcher = _ref2.messagesDispatcher;\n  var sendMessage = useCallback(function (file) {\n    var quoteMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var compressionRate = imageCompression.compressionRate,\n        resizingWidth = imageCompression.resizingWidth,\n        resizingHeight = imageCompression.resizingHeight;\n    var createCustomParams = onBeforeSendFileMessage && typeof onBeforeSendFileMessage === 'function';\n    var compressibleFileType = file.type === 'image/jpg' || file.type === 'image/png' || file.type === 'image/jpeg';\n    var compressibleRatio = compressionRate > 0 && compressionRate < 1; // pxToNumber returns null if values are invalid\n\n    var compressibleDiamensions = pxToNumber(resizingWidth) || pxToNumber(resizingHeight);\n    var canCompressImage = compressibleFileType && (compressibleRatio || compressibleDiamensions);\n\n    var createParamsDefault = function createParamsDefault(file_) {\n      var params = new sdk.FileMessageParams();\n      params.file = file_;\n\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n\n      return params;\n    };\n\n    if (canCompressImage) {\n      // Using image compression\n      try {\n        var image = document.createElement('img');\n        image.src = URL.createObjectURL(file);\n\n        image.onload = function () {\n          URL.revokeObjectURL(image.src);\n          var canvas = document.createElement('canvas');\n          var imageWdith = image.naturalWidth || image.width;\n          var imageHeight = image.naturalHeight || image.height;\n          var targetWidth = pxToNumber(resizingWidth) || imageWdith;\n          var targetHeight = pxToNumber(resizingHeight) || imageHeight; // In canvas.toBlob(callback, mimeType, qualityArgument)\n          // qualityArgument doesnt work\n          // so in case compressibleDiamensions are not present, we use ratio\n\n          if (file.type === 'image/png' && !compressibleDiamensions) {\n            targetWidth *= compressionRate;\n            targetHeight *= compressionRate;\n          }\n\n          canvas.width = targetWidth;\n          canvas.height = targetHeight;\n          var context = canvas.getContext('2d');\n          context.drawImage(image, 0, 0, targetWidth, targetHeight);\n          context.canvas.toBlob(function (newImageBlob) {\n            var compressedFile = new File([newImageBlob], file.name, {\n              type: file.type\n            });\n\n            if (createCustomParams) {\n              logger.info('Channel: Creating params using onBeforeSendFileMessage', onBeforeSendFileMessage);\n            }\n\n            var params = createCustomParams ? onBeforeSendFileMessage(compressedFile, quoteMessage) : createParamsDefault(compressedFile);\n            logger.info('Channel: Uploading file message start!', params);\n            var pendingMessage = currentGroupChannel.sendFileMessage(params, function (response, err) {\n              var swapParams = sdk.getErrorFirstCallback();\n\n              var _ref3 = swapParams ? [err, response] : [response, err],\n                  _ref4 = _slicedToArray(_ref3, 2),\n                  message = _ref4[0],\n                  error = _ref4[1];\n\n              if (error) {\n                // sending params instead of pending message\n                // to make sure that we can resend the message once it fails\n                logger.error('Channel: Sending file message failed!', {\n                  message: message,\n                  error: error\n                });\n                message.localUrl = URL.createObjectURL(compressedFile);\n                message.file = compressedFile;\n                messagesDispatcher({\n                  type: SEND_MESSAGEGE_FAILURE,\n                  payload: message\n                });\n                return;\n              }\n\n              logger.info('Channel: Sending file message success!', message);\n              messagesDispatcher({\n                type: SEND_MESSAGEGE_SUCESS,\n                payload: message\n              });\n            });\n            pubSub.publish(SEND_MESSAGE_START, {\n              /* pubSub is used instead of messagesDispatcher\n                to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n              message: _objectSpread2(_objectSpread2({}, pendingMessage), {}, {\n                url: URL.createObjectURL(compressedFile),\n                // pending thumbnail message seems to be failed\n                requestState: 'pending'\n              }),\n              channel: currentGroupChannel\n            });\n            setTimeout(function () {\n              return scrollIntoLast();\n            }, 1000);\n          }, file.type, compressionRate);\n        };\n      } catch (error) {\n        logger.error('Channel: Sending file message failed!', error);\n      }\n    } else {\n      // Not using image compression\n      if (createCustomParams) {\n        logger.info('Channel: creating params using onBeforeSendFileMessage', onBeforeSendFileMessage);\n      }\n\n      var params = onBeforeSendFileMessage ? onBeforeSendFileMessage(file) : createParamsDefault(file);\n      logger.info('Channel: Uploading file message start!', params);\n      var pendingMsg = currentGroupChannel.sendFileMessage(params, function (response, err) {\n        var swapParams = sdk.getErrorFirstCallback();\n\n        var _ref5 = swapParams ? [err, response] : [response, err],\n            _ref6 = _slicedToArray(_ref5, 2),\n            message = _ref6[0],\n            error = _ref6[1];\n\n        if (error) {\n          // sending params instead of pending message\n          // to make sure that we can resend the message once it fails\n          logger.error('Channel: Sending file message failed!', {\n            message: message,\n            error: error\n          });\n          message.localUrl = URL.createObjectURL(file);\n          message.file = file;\n          messagesDispatcher({\n            type: SEND_MESSAGEGE_FAILURE,\n            payload: message\n          });\n          return;\n        }\n\n        logger.info('Channel: Sending message success!', message);\n        messagesDispatcher({\n          type: SEND_MESSAGEGE_SUCESS,\n          payload: message\n        });\n      });\n      pubSub.publish(SEND_MESSAGE_START, {\n        /* pubSub is used instead of messagesDispatcher\n          to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n        message: _objectSpread2(_objectSpread2({}, pendingMsg), {}, {\n          url: URL.createObjectURL(file),\n          // pending thumbnail message seems to be failed\n          requestState: 'pending'\n        }),\n        channel: currentGroupChannel\n      });\n      setTimeout(function () {\n        return scrollIntoLast();\n      }, 1000);\n    }\n  }, [currentGroupChannel, onBeforeSendFileMessage, imageCompression]);\n  return [sendMessage];\n}\n\nvar ReactionButton = /*#__PURE__*/React__default.forwardRef(function (props, ref) {\n  var className = props.className,\n      width = props.width,\n      height = props.height,\n      selected = props.selected,\n      _onClick = props.onClick,\n      children = props.children;\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: [].concat(_toConsumableArray(Array.isArray(className) ? className : [className]), [\"sendbird-reaction-button\".concat(selected ? '--selected' : '')]).join(' '),\n    ref: ref,\n    role: \"button\",\n    style: {\n      width: typeof width === 'string' ? \"\".concat(width.slice(0, -2) - 2, \"px\") : \"\".concat(width - 2, \"px\"),\n      height: typeof height === 'string' ? \"\".concat(height.slice(0, -2) - 2, \"px\") : \"\".concat(height - 2, \"px\")\n    },\n    onClick: function onClick(e) {\n      return _onClick(e);\n    },\n    onKeyDown: function onKeyDown(e) {\n      return _onClick(e);\n    },\n    tabIndex: 0\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-reaction-button__inner\"\n  }, children));\n});\nReactionButton.propTypes = {\n  className: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  selected: PropTypes.bool,\n  onClick: PropTypes.func,\n  children: PropTypes.element.isRequired\n};\nReactionButton.defaultProps = {\n  className: '',\n  width: '36px',\n  height: '36px',\n  selected: false,\n  onClick: function onClick() {}\n};\n\nfunction useMemoizedEmojiListItems(_ref, _ref2) {\n  var emojiContainer = _ref.emojiContainer,\n      toggleReaction = _ref.toggleReaction;\n  var useReaction = _ref2.useReaction,\n      logger = _ref2.logger,\n      userId = _ref2.userId,\n      emojiAllList = _ref2.emojiAllList;\n  /* eslint-disable react/prop-types */\n\n  return useMemo(function () {\n    return function (_ref3) {\n      var parentRef = _ref3.parentRef,\n          parentContainRef = _ref3.parentContainRef,\n          message = _ref3.message,\n          closeDropdown = _ref3.closeDropdown,\n          _ref3$spaceFromTrigge = _ref3.spaceFromTrigger,\n          spaceFromTrigger = _ref3$spaceFromTrigge === void 0 ? {} : _ref3$spaceFromTrigge;\n\n      if (!useReaction || !(parentRef || parentContainRef || message || closeDropdown)) {\n        logger.warning('Channel: Invalid Params in memoizedEmojiListItems');\n        return null;\n      }\n\n      return /*#__PURE__*/React__default.createElement(EmojiListItems, {\n        parentRef: parentRef,\n        parentContainRef: parentContainRef,\n        closeDropdown: closeDropdown,\n        spaceFromTrigger: spaceFromTrigger\n      }, emojiAllList.map(function (emoji) {\n        var reactedReaction = message.reactions.filter(function (reaction) {\n          return reaction.key === emoji.key;\n        })[0];\n        var isReacted = reactedReaction ? !(reactedReaction.userIds.indexOf(userId) < 0) : false;\n        return /*#__PURE__*/React__default.createElement(ReactionButton, {\n          key: emoji.key,\n          width: \"36px\",\n          height: \"36px\",\n          selected: isReacted,\n          onClick: function onClick() {\n            closeDropdown();\n            toggleReaction(message, emoji.key, isReacted);\n          }\n        }, /*#__PURE__*/React__default.createElement(ImageRenderer, {\n          url: emoji.url,\n          width: \"28px\",\n          height: \"28px\",\n          defaultComponent: /*#__PURE__*/React__default.createElement(Icon, {\n            width: \"28px\",\n            height: \"28px\",\n            type: IconTypes.QUESTION\n          })\n        }));\n      }));\n    };\n  }, [emojiContainer, toggleReaction]);\n}\n\nfunction useToggleReactionCallback(_ref, _ref2) {\n  var currentGroupChannel = _ref.currentGroupChannel;\n  var logger = _ref2.logger;\n  return useCallback(function (message, key, isReacted) {\n    if (isReacted) {\n      currentGroupChannel.deleteReaction(message, key).then(function (res) {\n        logger.info('Delete reaction success', res);\n      }).catch(function (err) {\n        logger.warning('Delete reaction failed', err);\n      });\n      return;\n    }\n\n    currentGroupChannel.addReaction(message, key).then(function (res) {\n      logger.info('Add reaction success', res);\n    }).catch(function (err) {\n      logger.warning('Add reaction failed', err);\n    });\n  }, [currentGroupChannel]);\n}\n\nfunction useScrollToMessage(_a, _b) {\n  var setIntialTimeStamp = _a.setIntialTimeStamp,\n      setAnimatedMessageId = _a.setAnimatedMessageId,\n      allMessages = _a.allMessages;\n  var logger = _b.logger;\n  return useCallback(function (createdAt, messageId) {\n    var isPresent = allMessages.find(function (m) {\n      return m.messageId === messageId;\n    });\n    setAnimatedMessageId(null);\n    setTimeout(function () {\n      if (isPresent) {\n        logger.info('Channel: scroll to message - message is present');\n        setAnimatedMessageId(messageId);\n      } else {\n        logger.info('Channel: scroll to message - fetching older messages');\n        setIntialTimeStamp(null);\n        setIntialTimeStamp(createdAt);\n        setAnimatedMessageId(messageId);\n      }\n    });\n  }, [setIntialTimeStamp, setAnimatedMessageId, allMessages]);\n}\n\nvar MessageStatusTypes = getOutgoingMessageStates();\n\nfunction MessageStatus(_ref) {\n  var _iconType, _iconColor;\n\n  var className = _ref.className,\n      message = _ref.message,\n      channel = _ref.channel,\n      status = _ref.status;\n  var showMessageStatusIcon = (channel === null || channel === void 0 ? void 0 : channel.isGroupChannel()) && !(channel !== null && channel !== void 0 && channel.isSuper) && !(channel !== null && channel !== void 0 && channel.isPublic) && !(channel !== null && channel !== void 0 && channel.isBroadcast);\n  var iconType = (_iconType = {}, _defineProperty(_iconType, MessageStatusTypes.SENT, IconTypes.DONE), _defineProperty(_iconType, MessageStatusTypes.DELIVERED, IconTypes.DONE_ALL), _defineProperty(_iconType, MessageStatusTypes.READ, IconTypes.DONE_ALL), _defineProperty(_iconType, MessageStatusTypes.FAILED, IconTypes.ERROR), _iconType);\n  var iconColor = (_iconColor = {}, _defineProperty(_iconColor, MessageStatusTypes.SENT, IconColors.SENT), _defineProperty(_iconColor, MessageStatusTypes.DELIVERED, IconColors.SENT), _defineProperty(_iconColor, MessageStatusTypes.READ, IconColors.READ), _defineProperty(_iconColor, MessageStatusTypes.FAILED, IconColors.ERROR), _iconColor);\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: [].concat(_toConsumableArray(Array.isArray(className) ? className : [className]), ['sendbird-message-status']).join(' ')\n  }, showMessageStatusIcon && /*#__PURE__*/React__default.createElement(\"div\", null, status === MessageStatusTypes.PENDING ? /*#__PURE__*/React__default.createElement(Loader, {\n    className: \"sendbird-message-status__icon\",\n    width: \"16px\",\n    height: \"16px\"\n  }, /*#__PURE__*/React__default.createElement(Icon, {\n    type: IconTypes.SPINNER,\n    fillColor: IconColors.PRIMARY,\n    width: \"16px\",\n    height: \"16px\"\n  })) : /*#__PURE__*/React__default.createElement(Icon, {\n    className: \"sendbird-message-status__icon\",\n    type: iconType[status] || IconTypes.ERROR,\n    fillColor: iconColor[status],\n    width: \"16px\",\n    height: \"16px\"\n  })), isSentStatus(status) && /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-message-status__text\",\n    type: LabelTypography.CAPTION_3,\n    color: LabelColors.ONBACKGROUND_2\n  }, getMessageCreatedAt$1(message)));\n}\n\nMessageStatus.propTypes = {\n  className: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n  message: PropTypes.shape({\n    createdAt: PropTypes.number,\n    sender: PropTypes.shape({\n      friendName: PropTypes.string,\n      nickname: PropTypes.string,\n      userId: PropTypes.string,\n      profileUrl: PropTypes.string\n    }),\n    sendingStatus: PropTypes.string\n  }),\n  channel: PropTypes.shape({\n    isGroupChannel: PropTypes.func,\n    isSuper: PropTypes.bool,\n    isBroadcast: PropTypes.bool,\n    isPublic: PropTypes.bool\n  }),\n  status: PropTypes.string\n};\nMessageStatus.defaultProps = {\n  className: '',\n  message: null,\n  channel: null,\n  status: ''\n};\n\nfunction MessageItemMenu(_a) {\n  var _b;\n\n  var className = _a.className,\n      message = _a.message,\n      channel = _a.channel,\n      _c = _a.isByMe,\n      isByMe = _c === void 0 ? false : _c,\n      _d = _a.disabled,\n      disabled = _d === void 0 ? false : _d,\n      replyType = _a.replyType,\n      showEdit = _a.showEdit,\n      showRemove = _a.showRemove,\n      resendMessage = _a.resendMessage,\n      setQuoteMessage = _a.setQuoteMessage,\n      setSupposedHover = _a.setSupposedHover;\n  var stringSet = useContext(LocalizationContext).stringSet;\n  var triggerRef = useRef(null);\n  var containerRef = useRef(null);\n  var showMenuItemCopy = isUserMessage(message);\n  var showMenuItemReply = replyType === 'QUOTE_REPLY' && !isFailedMessage(channel, message) && !isPendingMessage(channel, message);\n  var showMenuItemEdit = isUserMessage(message) && isSentMessage(channel, message) && isByMe;\n  var showMenuItemResend = isFailedMessage(channel, message) && ((_b = message === null || message === void 0 ? void 0 : message.isResendable) === null || _b === void 0 ? void 0 : _b.call(message)) && isByMe;\n  var showMenuItemDelete = !isPendingMessage(channel, message) && isByMe;\n\n  if (!(showMenuItemCopy || showMenuItemReply || showMenuItemEdit || showMenuItemResend || showMenuItemDelete)) {\n    return null;\n  }\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName([className, 'sendbird-message-item-menu']),\n    ref: containerRef\n  }, /*#__PURE__*/React__default.createElement(ContextMenu, {\n    menuTrigger: function menuTrigger(toggleDropdown) {\n      return /*#__PURE__*/React__default.createElement(IconButton, {\n        className: \"sendbird-message-item-menu__trigger\",\n        ref: triggerRef,\n        width: \"32px\",\n        height: \"32px\",\n        onClick: function onClick() {\n          toggleDropdown();\n          setSupposedHover(true);\n        },\n        onBlur: function onBlur() {\n          setSupposedHover(false);\n        }\n      }, /*#__PURE__*/React__default.createElement(Icon, {\n        className: \"sendbird-message-item-menu__trigger__icon\",\n        type: IconTypes.MORE,\n        fillColor: IconColors.CONTENT_INVERSE,\n        width: \"24px\",\n        height: \"24px\"\n      }));\n    },\n    menuItems: function menuItems(close) {\n      var _a;\n\n      var closeDropdown = function closeDropdown() {\n        close();\n        setSupposedHover(false);\n      };\n\n      return /*#__PURE__*/React__default.createElement(MenuItems, {\n        className: \"sendbird-message-item-menu__list\",\n        parentRef: triggerRef,\n        parentContainRef: containerRef,\n        closeDropdown: closeDropdown,\n        openLeft: isByMe\n      }, showMenuItemCopy && /*#__PURE__*/React__default.createElement(MenuItem, {\n        className: \"sendbird-message-item-menu__list__menu-item menu-item-copy\",\n        onClick: function onClick() {\n          var _a;\n\n          copyToClipboard((_a = message) === null || _a === void 0 ? void 0 : _a.message);\n          closeDropdown();\n        }\n      }, stringSet.MESSAGE_MENU__COPY), showMenuItemReply && /*#__PURE__*/React__default.createElement(MenuItem, {\n        className: \"sendbird-message-item-menu__list__menu-item menu-item-reply\",\n        onClick: function onClick() {\n          setQuoteMessage(message);\n          closeDropdown();\n        },\n        disable: (message === null || message === void 0 ? void 0 : message.parentMessageId) > 0\n      }, stringSet.MESSAGE_MENU__REPLY), showMenuItemEdit && /*#__PURE__*/React__default.createElement(MenuItem, {\n        className: \"sendbird-message-item-menu__list__menu-item menu-item-edit\",\n        onClick: function onClick() {\n          if (!disabled) {\n            showEdit(true);\n            closeDropdown();\n          }\n        }\n      }, stringSet.MESSAGE_MENU__EDIT), showMenuItemResend && /*#__PURE__*/React__default.createElement(MenuItem, {\n        className: \"sendbird-message-item-menu__list__menu-item menu-item-resend\",\n        onClick: function onClick() {\n          if (!disabled) {\n            resendMessage(message);\n            closeDropdown();\n          }\n        }\n      }, stringSet.MESSAGE_MENU__RESEND), showMenuItemDelete && /*#__PURE__*/React__default.createElement(MenuItem, {\n        className: \"sendbird-message-item-menu__list__menu-item menu-item-delete\",\n        onClick: function onClick() {\n          if (!disabled) {\n            showRemove(true);\n            closeDropdown();\n          }\n        },\n        disable: ((_a = message === null || message === void 0 ? void 0 : message.threadInfo) === null || _a === void 0 ? void 0 : _a.replyCount) > 0\n      }, stringSet.MESSAGE_MENU__DELETE));\n    }\n  }));\n}\n\nfunction MessageItemReactionMenu(_a) {\n  var className = _a.className,\n      message = _a.message,\n      channel = _a.channel,\n      userId = _a.userId,\n      _b = _a.spaceFromTrigger,\n      spaceFromTrigger = _b === void 0 ? {} : _b,\n      emojiContainer = _a.emojiContainer,\n      toggleReaction = _a.toggleReaction,\n      setSupposedHover = _a.setSupposedHover;\n  var triggerRef = useRef(null);\n  var containerRef = useRef(null);\n\n  if (isPendingMessage(channel, message) || isFailedMessage(channel, message)) {\n    return null;\n  }\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName([className, 'sendbird-message-item-reaction-menu']),\n    ref: containerRef\n  }, /*#__PURE__*/React__default.createElement(ContextMenu, {\n    menuTrigger: function menuTrigger(toggleDropdown) {\n      return /*#__PURE__*/React__default.createElement(IconButton, {\n        className: \"sendbird-message-item-reaction-menu__trigger\",\n        ref: triggerRef,\n        width: \"32px\",\n        height: \"32px\",\n        onClick: function onClick() {\n          toggleDropdown();\n          setSupposedHover(true);\n        },\n        onBlur: function onBlur() {\n          setSupposedHover(false);\n        }\n      }, /*#__PURE__*/React__default.createElement(Icon, {\n        className: \"sendbird-message-item-reaction-menu__trigger__icon\",\n        type: IconTypes.EMOJI_MORE,\n        fillColor: IconColors.CONTENT_INVERSE,\n        width: \"24px\",\n        height: \"24px\"\n      }));\n    },\n    menuItems: function menuItems(close) {\n      var closeDropdown = function closeDropdown() {\n        close();\n        setSupposedHover(false);\n      };\n\n      return /*#__PURE__*/React__default.createElement(EmojiListItems, {\n        parentRef: triggerRef,\n        parentContainRef: containerRef,\n        closeDropdown: closeDropdown,\n        spaceFromTrigger: spaceFromTrigger\n      }, getEmojiListAll(emojiContainer).map(function (emoji) {\n        var _a, _b, _c;\n\n        var isReacted = (_c = (_b = (_a = message === null || message === void 0 ? void 0 : message.reactions) === null || _a === void 0 ? void 0 : _a.filter(function (reaction) {\n          return reaction.key === emoji.key;\n        })[0]) === null || _b === void 0 ? void 0 : _b.userIds) === null || _c === void 0 ? void 0 : _c.some(function (reactorId) {\n          return reactorId === userId;\n        });\n        return /*#__PURE__*/React__default.createElement(ReactionButton, {\n          key: emoji.key,\n          width: \"36px\",\n          height: \"36px\",\n          selected: isReacted,\n          onClick: function onClick() {\n            closeDropdown();\n            toggleReaction(message, emoji.key, isReacted);\n          }\n        }, /*#__PURE__*/React__default.createElement(ImageRenderer, {\n          url: emoji.url,\n          width: \"28px\",\n          height: \"28px\",\n          placeHolder: function placeHolder(style) {\n            return /*#__PURE__*/React__default.createElement(\"div\", {\n              style: style\n            }, /*#__PURE__*/React__default.createElement(Icon, {\n              type: IconTypes.QUESTION,\n              fillColor: IconColors.ON_BACKGROUND_3,\n              width: \"28px\",\n              height: \"28px\"\n            }));\n          }\n        }));\n      }));\n    }\n  }));\n}\n\nfunction Tooltip(_ref) {\n  var className = _ref.className,\n      children = _ref.children;\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: [].concat(_toConsumableArray(Array.isArray(className) ? className : [className]), ['sendbird-tooltip']).join(' ')\n  }, /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-tooltip__text\",\n    type: LabelTypography.CAPTION_2,\n    color: LabelColors.ONCONTENT_1\n  }, children));\n}\n\nTooltip.propTypes = {\n  className: PropTypes.string,\n  children: PropTypes.oneOfType([PropTypes.element, PropTypes.arrayOf(PropTypes.string), PropTypes.string])\n};\nTooltip.defaultProps = {\n  className: '',\n  children: ''\n};\nvar SPACE_FROM_TRIGGER = 8;\n\nfunction TooltipWrapper(_ref) {\n  var className = _ref.className,\n      children = _ref.children,\n      hoverTooltip = _ref.hoverTooltip;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      showHoverTooltip = _useState2[0],\n      setShowHoverTooltip = _useState2[1];\n\n  var childrenRef = useRef(null);\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: [].concat(_toConsumableArray(Array.isArray(className) ? className : [className]), ['sendbird-tooltip-wrapper']).join(' '),\n    onMouseOver: function onMouseOver() {\n      setShowHoverTooltip(true);\n    },\n    onFocus: function onFocus() {\n      setShowHoverTooltip(true);\n    },\n    onMouseOut: function onMouseOut() {\n      setShowHoverTooltip(false);\n    },\n    onBlur: function onBlur() {\n      setShowHoverTooltip(false);\n    }\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-tooltip-wrapper__children\",\n    ref: childrenRef\n  }, children), showHoverTooltip && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-tooltip-wrapper__hover-tooltip\",\n    style: {\n      bottom: \"calc(100% + \".concat(SPACE_FROM_TRIGGER, \"px)\")\n    }\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-tooltip-wrapper__hover-tooltip__inner\"\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-tooltip-wrapper__hover-tooltip__inner__tooltip-container\",\n    style: {\n      left: childrenRef.current && \"calc(\".concat(childrenRef.current.offsetWidth / 2, \"px - 50%)\")\n    }\n  }, hoverTooltip))));\n}\n\nTooltipWrapper.propTypes = {\n  className: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n  children: PropTypes.element.isRequired,\n  hoverTooltip: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired\n};\nTooltipWrapper.defaultProps = {\n  className: ''\n};\nvar ReactionBadge = /*#__PURE__*/React__default.forwardRef(function (props, ref) {\n  var className = props.className,\n      children = props.children,\n      count = props.count,\n      selected = props.selected,\n      isAdd = props.isAdd,\n      onClick = props.onClick;\n\n  var getClassNameTail = function getClassNameTail() {\n    if (selected && !isAdd) {\n      return '--selected';\n    }\n\n    if (isAdd) {\n      return '--is-add';\n    }\n\n    return '';\n  };\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: [].concat(_toConsumableArray(Array.isArray(className) ? className : [className]), [\"sendbird-reaction-badge\".concat(getClassNameTail())]).join(' '),\n    role: \"button\",\n    ref: ref,\n    onClick: onClick,\n    onKeyDown: onClick,\n    tabIndex: 0\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-reaction-badge__inner\"\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-reaction-badge__inner__icon\"\n  }, children), /*#__PURE__*/React__default.createElement(Label, {\n    className: children && count && 'sendbird-reaction-badge__inner__count',\n    type: LabelTypography.CAPTION_3,\n    color: LabelColors.ONBACKGROUND_1\n  }, count)));\n});\nReactionBadge.propTypes = {\n  className: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n  children: PropTypes.element.isRequired,\n  count: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  selected: PropTypes.bool,\n  isAdd: PropTypes.bool,\n  onClick: PropTypes.func\n};\nReactionBadge.defaultProps = {\n  className: '',\n  count: '',\n  selected: false,\n  isAdd: false,\n  onClick: function onClick() {}\n};\n\nfunction EmojiReactions2(_a) {\n  var _b, _c;\n\n  var className = _a.className,\n      userId = _a.userId,\n      message = _a.message,\n      emojiContainer = _a.emojiContainer,\n      memberNicknamesMap = _a.memberNicknamesMap,\n      _d = _a.spaceFromTrigger,\n      spaceFromTrigger = _d === void 0 ? {} : _d,\n      _e = _a.isByMe,\n      isByMe = _e === void 0 ? false : _e,\n      toggleReaction = _a.toggleReaction;\n  var stringSet = useContext(LocalizationContext).stringSet;\n  var emojisMap = getEmojiMapAll(emojiContainer);\n  var addReactionRef = useRef(null);\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName([className, 'sendbird-emoji-reactions', isByMe ? 'outgoing' : 'incoming'])\n  }, ((_b = message === null || message === void 0 ? void 0 : message.reactions) === null || _b === void 0 ? void 0 : _b.length) > 0 && message.reactions.map(function (reaction) {\n    var _a, _b;\n\n    var reactedByMe = isReactedBy(userId, reaction);\n    return /*#__PURE__*/React__default.createElement(TooltipWrapper, {\n      className: \"sendbird-emoji-reactions__reaction-badge\",\n      key: reaction === null || reaction === void 0 ? void 0 : reaction.key,\n      hoverTooltip: ((_a = reaction === null || reaction === void 0 ? void 0 : reaction.userIds) === null || _a === void 0 ? void 0 : _a.length) > 0 && /*#__PURE__*/React__default.createElement(Tooltip, null, getEmojiTooltipString(reaction, userId, memberNicknamesMap, stringSet))\n    }, /*#__PURE__*/React__default.createElement(ReactionBadge, {\n      count: reaction.userIds.length,\n      selected: reactedByMe,\n      onClick: function onClick() {\n        return toggleReaction(message, reaction.key, reactedByMe);\n      }\n    }, /*#__PURE__*/React__default.createElement(ImageRenderer, {\n      circle: true,\n      url: ((_b = emojisMap.get(reaction === null || reaction === void 0 ? void 0 : reaction.key)) === null || _b === void 0 ? void 0 : _b.url) || '',\n      width: \"20px\",\n      height: \"20px\",\n      defaultComponent: /*#__PURE__*/React__default.createElement(Icon, {\n        width: \"20px\",\n        height: \"20px\",\n        type: IconTypes.QUESTION\n      })\n    })));\n  }), ((_c = message === null || message === void 0 ? void 0 : message.reactions) === null || _c === void 0 ? void 0 : _c.length) < emojisMap.size && /*#__PURE__*/React__default.createElement(ContextMenu, {\n    menuTrigger: function menuTrigger(toggleDropdown) {\n      return /*#__PURE__*/React__default.createElement(ReactionBadge, {\n        className: \"sendbird-emoji-reactions__add-reaction-badge\",\n        ref: addReactionRef,\n        isAdd: true,\n        onClick: toggleDropdown\n      }, /*#__PURE__*/React__default.createElement(Icon, {\n        type: IconTypes.EMOJI_MORE,\n        fillColor: IconColors.ON_BACKGROUND_3,\n        width: \"20px\",\n        height: \"20px\"\n      }));\n    },\n    menuItems: function menuItems(closeDropdown) {\n      return /*#__PURE__*/React__default.createElement(EmojiListItems, {\n        parentRef: addReactionRef,\n        parentContainRef: addReactionRef,\n        closeDropdown: closeDropdown,\n        spacefromTrigger: spaceFromTrigger\n      }, getEmojiListAll(emojiContainer).map(function (emoji) {\n        var _a, _b, _c;\n\n        var isReacted = (_c = (_b = (_a = message === null || message === void 0 ? void 0 : message.reactions) === null || _a === void 0 ? void 0 : _a.filter(function (reaction) {\n          return reaction.key === emoji.key;\n        })[0]) === null || _b === void 0 ? void 0 : _b.userIds) === null || _c === void 0 ? void 0 : _c.some(function (reactorId) {\n          return reactorId === userId;\n        });\n        return /*#__PURE__*/React__default.createElement(ReactionButton, {\n          key: emoji.key,\n          width: \"36px\",\n          height: \"36px\",\n          selected: isReacted,\n          onClick: function onClick() {\n            closeDropdown();\n            toggleReaction(message, emoji.key, isReacted);\n          }\n        }, /*#__PURE__*/React__default.createElement(ImageRenderer, {\n          url: (emoji === null || emoji === void 0 ? void 0 : emoji.url) || '',\n          width: \"28px\",\n          height: \"28px\",\n          placeHolder: function placeHolder(style) {\n            return /*#__PURE__*/React__default.createElement(\"div\", {\n              style: style\n            }, /*#__PURE__*/React__default.createElement(Icon, {\n              type: IconTypes.QUESTION,\n              fillColor: IconColors.ON_BACKGROUND_3,\n              width: \"28px\",\n              height: \"28px\"\n            }));\n          }\n        }));\n      }));\n    }\n  }));\n}\n\nfunction AdminMessage(_ref) {\n  var className = _ref.className,\n      message = _ref.message;\n\n  if (!(message.isAdminMessage || message.messageType) || !message.isAdminMessage() || message.messageType !== 'admin') {\n    return null;\n  }\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: [].concat(_toConsumableArray(Array.isArray(className) ? className : [className]), ['sendbird-admin-message']).join(' ')\n  }, /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-admin-message__text\",\n    type: LabelTypography.CAPTION_2,\n    color: LabelColors.ONBACKGROUND_2\n  }, message.message));\n}\n\nAdminMessage.propTypes = {\n  message: PropTypes.shape({\n    message: PropTypes.string,\n    messageType: PropTypes.string,\n    isAdminMessage: PropTypes.func\n  }),\n  className: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)])\n};\nAdminMessage.defaultProps = {\n  message: {},\n  className: ''\n};\n\nfunction TextMessageItemBody(_a) {\n  var _b;\n\n  var className = _a.className,\n      message = _a.message,\n      _c = _a.isByMe,\n      isByMe = _c === void 0 ? false : _c,\n      _d = _a.mouseHover,\n      mouseHover = _d === void 0 ? false : _d;\n  var stringSet = useContext(LocalizationContext).stringSet;\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName([className, 'sendbird-text-message-item-body', isByMe ? 'outgoing' : 'incoming', mouseHover ? 'mouse-hover' : '', ((_b = message === null || message === void 0 ? void 0 : message.reactions) === null || _b === void 0 ? void 0 : _b.length) > 0 ? 'reactions' : ''])\n  }, message === null || message === void 0 ? void 0 : message.message.split(/\\r/).map(function (word) {\n    return word === '' ? /*#__PURE__*/React__default.createElement(\"br\", {\n      key: word\n    }) : /*#__PURE__*/React__default.createElement(Label, {\n      key: word,\n      className: \"sendbird-text-message-item-body__message\",\n      type: LabelTypography.BODY_1,\n      color: isByMe ? LabelColors.ONCONTENT_1 : LabelColors.ONBACKGROUND_1\n    }, word);\n  }), isEditedMessage(message) && /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-text-message-item-body__message edited\",\n    type: LabelTypography.BODY_1,\n    color: isByMe ? LabelColors.ONCONTENT_2 : LabelColors.ONBACKGROUND_2\n  }, \" \" + stringSet.MESSAGE_EDITED + \" \"));\n}\n\nfunction FileMessageItemBody(_a) {\n  var _b;\n\n  var className = _a.className,\n      message = _a.message,\n      _c = _a.isByMe,\n      isByMe = _c === void 0 ? false : _c,\n      _d = _a.mouseHover,\n      mouseHover = _d === void 0 ? false : _d;\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName([className, 'sendbird-file-message-item-body', isByMe ? 'outgoing' : 'incoming', mouseHover ? 'mouse-hover' : '', ((_b = message === null || message === void 0 ? void 0 : message.reactions) === null || _b === void 0 ? void 0 : _b.length) > 0 ? 'reactions' : ''])\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-file-message-item-body__file-icon\"\n  }, /*#__PURE__*/React__default.createElement(Icon, {\n    className: 'sendbird-file-message-item-body__file-icon__icon',\n    type: {\n      IMAGE: IconTypes.PHOTO,\n      VIDEO: IconTypes.PLAY,\n      AUDIO: IconTypes.FILE_AUDIO,\n      GIF: IconTypes.GIF,\n      OTHERS: IconTypes.FILE_DOCUMENT\n    }[getUIKitFileType(message === null || message === void 0 ? void 0 : message.type)],\n    fillColor: IconColors.PRIMARY,\n    width: \"24px\",\n    height: \"24px\"\n  })), /*#__PURE__*/React__default.createElement(TextButton, {\n    className: \"sendbird-file-message-item-body__file-name\",\n    onClick: function onClick() {\n      window.open(message === null || message === void 0 ? void 0 : message.url);\n    },\n    color: isByMe ? LabelColors.ONCONTENT_1 : LabelColors.ONBACKGROUND_1\n  }, /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-file-message-item-body__file-name__text\",\n    type: LabelTypography.BODY_1,\n    color: isByMe ? LabelColors.ONCONTENT_1 : LabelColors.ONBACKGROUND_1\n  }, truncateString((message === null || message === void 0 ? void 0 : message.name) || (message === null || message === void 0 ? void 0 : message.url)))));\n}\n\nfunction ThumbnailMessageItemBody(_a) {\n  var _b, _c;\n\n  var className = _a.className,\n      message = _a.message,\n      _d = _a.isByMe,\n      isByMe = _d === void 0 ? false : _d,\n      _e = _a.mouseHover,\n      mouseHover = _e === void 0 ? false : _e,\n      showFileViewer = _a.showFileViewer;\n  var _f = message.thumbnails,\n      thumbnails = _f === void 0 ? [] : _f;\n  var thumbnailUrl = thumbnails.length > 0 ? (_b = thumbnails[0]) === null || _b === void 0 ? void 0 : _b.url : '';\n\n  var _g = useState(false),\n      imageRendered = _g[0],\n      setImageRendered = _g[1];\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName([className, 'sendbird-thumbnail-message-item-body', isByMe ? 'outgoing' : 'incoming', mouseHover ? 'mouse-hover' : '', ((_c = message === null || message === void 0 ? void 0 : message.reactions) === null || _c === void 0 ? void 0 : _c.length) > 0 ? 'reactions' : '']),\n    onClick: function onClick() {\n      return showFileViewer(true);\n    }\n  }, /*#__PURE__*/React__default.createElement(ImageRenderer, {\n    className: \"sendbird-thumbnail-message-item-body__thumbnail\",\n    url: thumbnailUrl || (message === null || message === void 0 ? void 0 : message.url),\n    alt: message === null || message === void 0 ? void 0 : message.type,\n    width: \"360px\",\n    height: \"270px\",\n    onLoad: function onLoad() {\n      setImageRendered(true);\n    },\n    placeHolder: function placeHolder(style) {\n      return /*#__PURE__*/React__default.createElement(\"div\", {\n        className: \"sendbird-thumbnail-message-item-body__placeholder\",\n        style: style\n      }, /*#__PURE__*/React__default.createElement(\"div\", {\n        className: \"sendbird-thumbnail-message-item-body__placeholder__icon\"\n      }, /*#__PURE__*/React__default.createElement(Icon, {\n        type: isVideoMessage(message) ? IconTypes.PLAY : IconTypes.PHOTO,\n        fillColor: IconColors.ON_BACKGROUND_2,\n        width: \"34px\",\n        height: \"34px\"\n      })));\n    }\n  }), isVideoMessage(message) && !thumbnailUrl && !imageRendered && /*#__PURE__*/React__default.createElement(\"video\", {\n    className: \"sendbird-thumbnail-message-item-body__video\"\n  }, /*#__PURE__*/React__default.createElement(\"source\", {\n    src: message === null || message === void 0 ? void 0 : message.url,\n    type: message === null || message === void 0 ? void 0 : message.type\n  })), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-thumbnail-message-item-body__image-cover\"\n  }), (isVideoMessage(message) || isGifMessage(message)) && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-thumbnail-message-item-body__icon-wrapper\"\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-thumbnail-message-item-body__icon-wrapper__icon\"\n  }, /*#__PURE__*/React__default.createElement(Icon, {\n    type: isVideoMessage(message) ? IconTypes.PLAY : IconTypes.GIF,\n    fillColor: IconColors.GRAY,\n    width: \"34px\",\n    height: \"34px\"\n  }))));\n}\n\nfunction OGMessageItemBody(_a) {\n  var _b, _c, _d, _e, _f, _g, _h, _j;\n\n  var className = _a.className,\n      message = _a.message,\n      _k = _a.isByMe,\n      isByMe = _k === void 0 ? false : _k,\n      _l = _a.mouseHover,\n      mouseHover = _l === void 0 ? false : _l;\n  var stringSet = useContext(LocalizationContext).stringSet;\n\n  var openOGUrl = function openOGUrl() {\n    var _a, _b;\n\n    if ((_a = message === null || message === void 0 ? void 0 : message.ogMetaData) === null || _a === void 0 ? void 0 : _a.url) window.open((_b = message === null || message === void 0 ? void 0 : message.ogMetaData) === null || _b === void 0 ? void 0 : _b.url);\n  };\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName([className, 'sendbird-og-message-item-body', isByMe ? 'outgoing' : 'incoming', mouseHover ? 'mouse-hover' : '', ((_b = message === null || message === void 0 ? void 0 : message.reactions) === null || _b === void 0 ? void 0 : _b.length) > 0 ? 'reactions' : ''])\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-og-message-item-body__text-bubble\"\n  }, message === null || message === void 0 ? void 0 : message.message.split(' ').map(function (word) {\n    return isUrl(word) ? /*#__PURE__*/React__default.createElement(LinkLabel, {\n      className: \"sendbird-og-message-item-body__text-bubble__message\",\n      key: uuidv4(),\n      src: word,\n      type: LabelTypography.BODY_1,\n      color: isByMe ? LabelColors.ONCONTENT_1 : LabelColors.ONBACKGROUND_1\n    }, word) : /*#__PURE__*/React__default.createElement(Label, {\n      className: \"sendbird-og-message-item-body__text-bubble__message\",\n      key: uuidv4(),\n      type: LabelTypography.BODY_1,\n      color: isByMe ? LabelColors.ONCONTENT_1 : LabelColors.ONBACKGROUND_1\n    }, word);\n  }), isEditedMessage(message) && /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-og-message-item-body__text-bubble__message\",\n    type: LabelTypography.BODY_1,\n    color: isByMe ? LabelColors.ONCONTENT_2 : LabelColors.ONBACKGROUND_2\n  }, \" \" + stringSet.MESSAGE_EDITED + \" \")), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-og-message-item-body__og-thumbnail\",\n    onClick: openOGUrl\n  }, /*#__PURE__*/React__default.createElement(ImageRenderer, {\n    className: \"sendbird-og-message-item-body__og-thumbnail__image\",\n    url: ((_d = (_c = message === null || message === void 0 ? void 0 : message.ogMetaData) === null || _c === void 0 ? void 0 : _c.defaultImage) === null || _d === void 0 ? void 0 : _d.url) || '',\n    alt: (_f = (_e = message === null || message === void 0 ? void 0 : message.ogMetaData) === null || _e === void 0 ? void 0 : _e.defaultImage) === null || _f === void 0 ? void 0 : _f.alt // TODO: Change fixing width and height lengths\n    ,\n    width: \"320px\",\n    height: \"180px\",\n    defaultComponent: /*#__PURE__*/React__default.createElement(\"div\", {\n      className: \"sendbird-og-message-item-body__og-thumbnail__place-holder\"\n    }, /*#__PURE__*/React__default.createElement(Icon, {\n      className: \"sendbird-og-message-item-body__og-thumbnail__place-holder__icon\",\n      type: IconTypes.THUMBNAIL_NONE,\n      width: \"56px\",\n      height: \"56px\"\n    }))\n  })), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-og-message-item-body__description\",\n    onClick: openOGUrl\n  }, ((_g = message === null || message === void 0 ? void 0 : message.ogMetaData) === null || _g === void 0 ? void 0 : _g.title) && /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-og-message-item-body__description__title\",\n    type: LabelTypography.SUBTITLE_2,\n    color: LabelColors.ONBACKGROUND_1\n  }, message.ogMetaData.title), ((_h = message === null || message === void 0 ? void 0 : message.ogMetaData) === null || _h === void 0 ? void 0 : _h.description) && /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-og-message-item-body__description__description\",\n    type: LabelTypography.BODY_2,\n    color: LabelColors.ONBACKGROUND_1\n  }, message.ogMetaData.description), ((_j = message === null || message === void 0 ? void 0 : message.ogMetaData) === null || _j === void 0 ? void 0 : _j.url) && /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-og-message-item-body__description__url\",\n    type: LabelTypography.CAPTION_3,\n    color: LabelColors.ONBACKGROUND_2\n  }, message.ogMetaData.url)), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-og-message-item-body__cover\"\n  }));\n}\n\nfunction UnknownMessageItemBody(_a) {\n  var _b;\n\n  var className = _a.className,\n      message = _a.message,\n      _c = _a.isByMe,\n      isByMe = _c === void 0 ? false : _c,\n      _d = _a.mouseHover,\n      mouseHover = _d === void 0 ? false : _d;\n  var stringSet = useContext(LocalizationContext).stringSet;\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName([className, 'sendbird-unknown-message-item-body', isByMe ? 'outgoing' : 'incoming', mouseHover ? 'mouse-hover' : '', ((_b = message === null || message === void 0 ? void 0 : message.reactions) === null || _b === void 0 ? void 0 : _b.length) > 0 ? 'reactions' : ''])\n  }, /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-unknown-message-item-body__header\",\n    type: LabelTypography.BODY_1,\n    color: isByMe ? LabelColors.ONCONTENT_1 : LabelColors.ONBACKGROUND_1\n  }, stringSet.UNKNOWN__UNKNOWN_MESSAGE_TYPE), /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-unknown-message-item-body__description\",\n    type: LabelTypography.BODY_1,\n    color: isByMe ? LabelColors.ONCONTENT_2 : LabelColors.ONBACKGROUND_2\n  }, stringSet.UNKNOWN__CANNOT_READ_MESSAGE));\n}\n\nfunction QuoteMessage(_a) {\n  var _b;\n\n  var _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n\n  var message = _a.message,\n      _p = _a.userId,\n      userId = _p === void 0 ? '' : _p,\n      _q = _a.isByMe,\n      isByMe = _q === void 0 ? false : _q,\n      className = _a.className,\n      _onClick = _a.onClick;\n  var stringSet = useContext(LocalizationContext).stringSet;\n  var parentMessage = message.parentMessage;\n  var parentMessageSender = (_c = parentMessage) === null || _c === void 0 ? void 0 : _c.sender;\n  var parentMessageSenderNickname = userId === (parentMessageSender === null || parentMessageSender === void 0 ? void 0 : parentMessageSender.userId) ? stringSet.QUOTED_MESSAGE__CURRENT_USER : parentMessageSender === null || parentMessageSender === void 0 ? void 0 : parentMessageSender.nickname;\n  var parentMessageUrl = ((_d = parentMessage) === null || _d === void 0 ? void 0 : _d.url) || '';\n  var parentMessageType = (_e = parentMessage) === null || _e === void 0 ? void 0 : _e.type;\n  var currentMessageSenderNickname = userId === ((_f = message === null || message === void 0 ? void 0 : message.sender) === null || _f === void 0 ? void 0 : _f.userId) ? stringSet.QUOTED_MESSAGE__CURRENT_USER : (_g = message === null || message === void 0 ? void 0 : message.sender) === null || _g === void 0 ? void 0 : _g.nickname;\n\n  var _r = useState(false),\n      isThumbnailLoaded = _r[0],\n      setThumbnailLoaded = _r[1];\n\n  var uikitFileTypes = getUIKitFileTypes();\n  var splitFileName = ((_h = parentMessage) === null || _h === void 0 ? void 0 : _h.name) ? parentMessage.name.split('/') : parentMessageUrl.split('/');\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName([className, 'sendbird-quote-message', isByMe ? 'outgoing' : 'incoming']),\n    key: parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId,\n    onClick: function onClick() {\n      if (_onClick) _onClick();\n    }\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-quote-message__replied-to\"\n  }, /*#__PURE__*/React__default.createElement(Icon, {\n    className: \"sendbird-quote-message__replied-to__icon\",\n    type: IconTypes.REPLY,\n    fillColor: IconColors.ON_BACKGROUND_3,\n    width: \"12px\",\n    height: \"12px\"\n  }), /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-quote-message__replied-to__text\",\n    type: LabelTypography.CAPTION_2,\n    color: LabelColors.ONBACKGROUND_3\n  }, currentMessageSenderNickname + \" \" + stringSet.QUOTED_MESSAGE__REPLIED_TO + \" \" + parentMessageSenderNickname)), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-quote-message__replied-message\"\n  }, isUserMessage(parentMessage) && ((_k = (_j = parentMessage) === null || _j === void 0 ? void 0 : _j.message) === null || _k === void 0 ? void 0 : _k.length) > 0 && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-quote-message__replied-message__text-message\"\n  }, /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-quote-message__replied-message__text-message__word\",\n    type: LabelTypography.BODY_2,\n    color: LabelColors.ONBACKGROUND_1\n  }, (_l = parentMessage) === null || _l === void 0 ? void 0 : _l.message)), isThumbnailMessage(parentMessage) && parentMessageUrl && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-quote-message__replied-message__thumbnail-message\"\n  }, /*#__PURE__*/React__default.createElement(ImageRenderer, {\n    className: \"sendbird-quote-message__replied-message__thumbnail-message__image\",\n    url: parentMessageUrl,\n    alt: parentMessageType,\n    width: \"144px\",\n    height: \"108px\",\n    onLoad: function onLoad() {\n      return setThumbnailLoaded(true);\n    },\n    defaultComponent: /*#__PURE__*/React__default.createElement(\"div\", {\n      className: \"sendbird-quote-message__replied-message__thumbnail-message__placeholder\"\n    }, /*#__PURE__*/React__default.createElement(\"div\", {\n      className: \"sendbird-quote-message__replied-message__thumbnail-message__placeholder__icon\"\n    }, /*#__PURE__*/React__default.createElement(Icon, {\n      type: isVideo(parentMessageType) ? IconTypes.PLAY : IconTypes.PHOTO,\n      fillColor: IconColors.ON_BACKGROUND_2,\n      width: \"22px\",\n      height: \"22px\"\n    })))\n  }), isVideo(parentMessageType) && !(((_o = (_m = parentMessage) === null || _m === void 0 ? void 0 : _m.thumbnails) === null || _o === void 0 ? void 0 : _o.length) > 0) && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(\"video\", {\n    className: \"sendbird-quote-message__replied-message__thumbnail-message__video\"\n  }, /*#__PURE__*/React__default.createElement(\"source\", {\n    src: parentMessageUrl,\n    type: parentMessageType\n  })), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-quote-message__replied-message__thumbnail-message__cover\"\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-quote-message__replied-message__thumbnail-message__cover__icon\"\n  }, /*#__PURE__*/React__default.createElement(Icon, {\n    type: IconTypes.PLAY,\n    fillColor: IconColors.GRAY,\n    width: \"14px\",\n    height: \"14px\"\n  })))), isThumbnailLoaded && isGif(parentMessageType) && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-quote-message__replied-message__thumbnail-message__cover\"\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-quote-message__replied-message__thumbnail-message__cover__icon\"\n  }, /*#__PURE__*/React__default.createElement(Icon, {\n    type: IconTypes.GIF,\n    fillColor: IconColors.GRAY,\n    width: \"14px\",\n    height: \"14px\"\n  })))), isFileMessage(parentMessage) && !isSupportedFileView(parentMessage.type) && parentMessageUrl && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-quote-message__replied-message__file-message\"\n  }, /*#__PURE__*/React__default.createElement(Icon, {\n    className: \"sendbird-quote-message__replied-message__file-message__type-icon\",\n    type: (_b = {}, _b[uikitFileTypes.IMAGE] = IconTypes.PHOTO, _b[uikitFileTypes.VIDEO] = IconTypes.PLAY, _b[uikitFileTypes.AUDIO] = IconTypes.FILE_AUDIO, _b[uikitFileTypes.GIF] = IconTypes.GIF, _b[uikitFileTypes.OTHERS] = IconTypes.FILE_DOCUMENT, _b)[getUIKitFileType(parentMessageType)],\n    fillColor: IconColors.ON_BACKGROUND_3,\n    width: \"16px\",\n    height: \"16px\"\n  }), /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-quote-message__replied-message__file-message__file-name\",\n    type: LabelTypography.BODY_2,\n    color: LabelColors.ONBACKGROUND_3\n  }, truncateString(splitFileName[splitFileName.length - 1])))));\n}\n\nfunction MessageContent(_a) {\n  var _b, _c, _d, _e;\n\n  var className = _a.className,\n      userId = _a.userId,\n      channel = _a.channel,\n      message = _a.message,\n      _f = _a.disabled,\n      disabled = _f === void 0 ? false : _f,\n      _g = _a.chainTop,\n      chainTop = _g === void 0 ? false : _g,\n      _h = _a.chainBottom,\n      chainBottom = _h === void 0 ? false : _h,\n      _j = _a.useReaction,\n      useReaction = _j === void 0 ? false : _j,\n      replyType = _a.replyType,\n      nicknamesMap = _a.nicknamesMap,\n      emojiContainer = _a.emojiContainer,\n      scrollToMessage = _a.scrollToMessage,\n      showEdit = _a.showEdit,\n      showRemove = _a.showRemove,\n      showFileViewer = _a.showFileViewer,\n      resendMessage = _a.resendMessage,\n      toggleReaction = _a.toggleReaction,\n      setQuoteMessage = _a.setQuoteMessage;\n  var messageTypes = getUIKitMessageTypes();\n\n  var _k = useContext(UserProfileContext),\n      disableUserProfile = _k.disableUserProfile,\n      renderUserProfile = _k.renderUserProfile;\n\n  var avatarRef = useRef(null);\n\n  var _l = useState(false),\n      mouseHover = _l[0],\n      setMouseHover = _l[1];\n\n  var _m = useState(false),\n      supposedHover = _m[0],\n      setSupposedHover = _m[1];\n\n  var isByMe = userId === ((_c = (_b = message) === null || _b === void 0 ? void 0 : _b.sender) === null || _c === void 0 ? void 0 : _c.userId) || message.sendingStatus === 'pending' || message.sendingStatus === 'failed';\n  var isByMeClassName = isByMe ? 'outgoing' : 'incoming';\n  var chainTopClassName = chainTop ? 'chain-top' : '';\n  var useReactionClassName = useReaction ? 'use-reactions' : '';\n  var supposedHoverClassName = supposedHover ? 'supposed-hover' : '';\n  var useReplying = !!(replyType === 'QUOTE_REPLY' && (message === null || message === void 0 ? void 0 : message.parentMessageId) && (message === null || message === void 0 ? void 0 : message.parentMessage));\n  var useReplyingClassName = useReplying ? 'use-quote' : '';\n\n  if (((_d = message === null || message === void 0 ? void 0 : message.isAdminMessage) === null || _d === void 0 ? void 0 : _d.call(message)) || (message === null || message === void 0 ? void 0 : message.messageType) === 'admin') {\n    return /*#__PURE__*/React__default.createElement(AdminMessage, {\n      message: message\n    });\n  }\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName([className, 'sendbird-message-content', isByMeClassName]),\n    onMouseOver: function onMouseOver() {\n      return setMouseHover(true);\n    },\n    onMouseLeave: function onMouseLeave() {\n      return setMouseHover(false);\n    }\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName(['sendbird-message-content__left', useReactionClassName, isByMeClassName, useReplyingClassName])\n  }, !isByMe && !chainBottom &&\n  /*#__PURE__*/\n\n  /** user profile */\n  React__default.createElement(ContextMenu, {\n    menuTrigger: function menuTrigger(toggleDropdown) {\n      var _a;\n\n      return /*#__PURE__*/React__default.createElement(Avatar, {\n        className: \"sendbird-message-content__left__avatar\",\n        src: ((_a = message === null || message === void 0 ? void 0 : message.sender) === null || _a === void 0 ? void 0 : _a.profileUrl) || '',\n        ref: avatarRef,\n        width: \"28px\",\n        height: \"28px\",\n        onClick: function onClick() {\n          if (!disableUserProfile) toggleDropdown();\n        }\n      });\n    },\n    menuItems: function menuItems(closeDropdown) {\n      return /*#__PURE__*/React__default.createElement(MenuItems\n      /**\n      * parentRef: For catching location(x, y) of MenuItems\n      * parentContainRef: For toggling more options(menus & reactions)\n      */\n      , {\n        parentRef: avatarRef,\n        parentContainRef: avatarRef,\n        closeDropdown: closeDropdown,\n        style: {\n          paddingTop: 0,\n          paddingBottom: 0\n        }\n      }, renderUserProfile ? renderUserProfile({\n        user: message === null || message === void 0 ? void 0 : message.sender,\n        close: closeDropdown\n      }) : /*#__PURE__*/React__default.createElement(ConnectedUserProfile, {\n        user: message.sender,\n        onSuccess: closeDropdown\n      }));\n    }\n  }), isByMe && !chainBottom && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName(['sendbird-message-content__left__created-at', supposedHoverClassName])\n  }, /*#__PURE__*/React__default.createElement(MessageStatus, {\n    message: message,\n    channel: channel,\n    status: getOutgoingMessageState(channel, message)\n  })), isByMe && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName(['sendbird-message-content-menu', useReactionClassName, supposedHoverClassName, isByMeClassName])\n  }, /*#__PURE__*/React__default.createElement(MessageItemMenu, {\n    className: \"sendbird-message-content-menu__normal-menu\",\n    channel: channel,\n    message: message,\n    isByMe: isByMe,\n    replyType: replyType,\n    disabled: disabled,\n    showEdit: showEdit,\n    showRemove: showRemove,\n    resendMessage: resendMessage,\n    setQuoteMessage: setQuoteMessage,\n    setSupposedHover: setSupposedHover\n  }), useReaction && /*#__PURE__*/React__default.createElement(MessageItemReactionMenu, {\n    className: \"sendbird-message-content-menu__reaction-menu\",\n    message: message,\n    channel: channel,\n    userId: userId,\n    spaceFromTrigger: {},\n    emojiContainer: emojiContainer,\n    toggleReaction: toggleReaction,\n    setSupposedHover: setSupposedHover\n  }))), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-message-content__middle\"\n  }, !isByMe && !chainTop && !useReplying && /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-message-content__middle__sender-name\",\n    type: LabelTypography.CAPTION_2,\n    color: LabelColors.ONBACKGROUND_2\n  }, getSenderName(message)), useReplying ? /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName(['sendbird-message-content__middle__quote-message', isByMe ? 'outgoing' : 'incoming', useReplyingClassName])\n  }, /*#__PURE__*/React__default.createElement(QuoteMessage, {\n    message: message,\n    userId: userId,\n    isByMe: isByMe,\n    onClick: function onClick() {\n      var _a;\n\n      if (((_a = message === null || message === void 0 ? void 0 : message.parentMessage) === null || _a === void 0 ? void 0 : _a.createdAt) && (message === null || message === void 0 ? void 0 : message.parentMessageId)) {\n        scrollToMessage(message.parentMessage.createdAt, message.parentMessageId);\n      }\n    }\n  })) : null, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName(['sendbird-message-content__middle__body-container'])\n  }, isTextMessage(message) && /*#__PURE__*/React__default.createElement(TextMessageItemBody, {\n    className: \"sendbird-message-content__middle__message-item-body\",\n    message: message,\n    isByMe: isByMe,\n    mouseHover: mouseHover\n  }), isOGMessage(message) && /*#__PURE__*/React__default.createElement(OGMessageItemBody, {\n    className: \"sendbird-message-content__middle__message-item-body\",\n    message: message,\n    isByMe: isByMe,\n    mouseHover: mouseHover\n  }), getUIKitMessageType(message) === messageTypes.FILE && /*#__PURE__*/React__default.createElement(FileMessageItemBody, {\n    className: \"sendbird-message-content__middle__message-item-body\",\n    message: message,\n    isByMe: isByMe,\n    mouseHover: mouseHover\n  }), isThumbnailMessage(message) && /*#__PURE__*/React__default.createElement(ThumbnailMessageItemBody, {\n    className: \"sendbird-message-content__middle__message-item-body\",\n    message: message,\n    isByMe: isByMe,\n    mouseHover: mouseHover,\n    showFileViewer: showFileViewer\n  }), getUIKitMessageType(message) === messageTypes.UNKNOWN && /*#__PURE__*/React__default.createElement(UnknownMessageItemBody, {\n    className: \"sendbird-message-content__middle__message-item-body\",\n    message: message,\n    isByMe: isByMe,\n    mouseHover: mouseHover\n  }), useReaction && ((_e = message === null || message === void 0 ? void 0 : message.reactions) === null || _e === void 0 ? void 0 : _e.length) > 0 && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName(['sendbird-message-content-reactions', !isByMe || isThumbnailMessage(message) || isOGMessage(message) ? '' : 'primary', mouseHover ? 'mouse-hover' : ''])\n  }, /*#__PURE__*/React__default.createElement(EmojiReactions2, {\n    userId: userId,\n    message: message,\n    isByMe: isByMe,\n    emojiContainer: emojiContainer,\n    memberNicknamesMap: nicknamesMap,\n    toggleReaction: toggleReaction\n  })))), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName(['sendbird-message-content__right', chainTopClassName, useReactionClassName, useReplyingClassName])\n  }, !isByMe && !chainBottom && /*#__PURE__*/React__default.createElement(Label, {\n    className: getClassName(['sendbird-message-content__right__created-at', supposedHoverClassName]),\n    type: LabelTypography.CAPTION_3,\n    color: LabelColors.ONBACKGROUND_2\n  }, getMessageCreatedAt$1(message)), !isByMe && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName(['sendbird-message-content-menu', chainTopClassName, supposedHoverClassName, isByMeClassName])\n  }, useReaction && /*#__PURE__*/React__default.createElement(MessageItemReactionMenu, {\n    className: \"sendbird-message-content-menu__reaction-menu\",\n    message: message,\n    channel: channel,\n    userId: userId,\n    spaceFromTrigger: {},\n    emojiContainer: emojiContainer,\n    toggleReaction: toggleReaction,\n    setSupposedHover: setSupposedHover\n  }), /*#__PURE__*/React__default.createElement(MessageItemMenu, {\n    className: \"sendbird-message-content-menu__normal-menu\",\n    channel: channel,\n    message: message,\n    isByMe: isByMe,\n    replyType: replyType,\n    disabled: disabled,\n    showEdit: showEdit,\n    showRemove: showRemove,\n    resendMessage: resendMessage,\n    setQuoteMessage: setQuoteMessage,\n    setSupposedHover: setSupposedHover\n  }))));\n}\n\nvar RemoveMessage = function RemoveMessage(props) {\n  var _message$threadInfo;\n\n  var onCloseModal = props.onCloseModal,\n      onDeleteMessage = props.onDeleteMessage,\n      message = props.message;\n\n  var _useContext = useContext(LocalizationContext),\n      stringSet = _useContext.stringSet;\n\n  return /*#__PURE__*/React__default.createElement(Modal, {\n    type: ButtonTypes.DANGER,\n    disabled: (message === null || message === void 0 ? void 0 : (_message$threadInfo = message.threadInfo) === null || _message$threadInfo === void 0 ? void 0 : _message$threadInfo.replyCount) > 0,\n    onCancel: onCloseModal,\n    onSubmit: onDeleteMessage,\n    submitText: \"Delete\",\n    titleText: stringSet.MODAL__DELETE_MESSAGE__TITLE\n  });\n};\n\nRemoveMessage.propTypes = {\n  onCloseModal: PropTypes.func.isRequired,\n  onDeleteMessage: PropTypes.func.isRequired,\n  message: PropTypes.shape({\n    threadInfo: PropTypes.shape({\n      replyCount: PropTypes.number\n    })\n  }).isRequired\n};\n\nfunction MessageHoc(_ref) {\n  var message = _ref.message,\n      userId = _ref.userId,\n      disabled = _ref.disabled,\n      editDisabled = _ref.editDisabled,\n      hasSeparator = _ref.hasSeparator,\n      deleteMessage = _ref.deleteMessage,\n      updateMessage = _ref.updateMessage,\n      scrollToMessage = _ref.scrollToMessage,\n      resendMessage = _ref.resendMessage,\n      useReaction = _ref.useReaction,\n      replyType = _ref.replyType,\n      chainTop = _ref.chainTop,\n      chainBottom = _ref.chainBottom,\n      membersMap = _ref.membersMap,\n      emojiContainer = _ref.emojiContainer,\n      animatedMessageId = _ref.animatedMessageId,\n      highLightedMessageId = _ref.highLightedMessageId,\n      toggleReaction = _ref.toggleReaction,\n      quoteMessage = _ref.quoteMessage,\n      setQuoteMessage = _ref.setQuoteMessage,\n      renderCustomMessage = _ref.renderCustomMessage,\n      currentGroupChannel = _ref.currentGroupChannel;\n  var _message$sender = message.sender,\n      sender = _message$sender === void 0 ? {} : _message$sender;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      showEdit = _useState2[0],\n      setShowEdit = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      showRemove = _useState4[0],\n      setShowRemove = _useState4[1];\n\n  var _useState5 = useState(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      showFileViewer = _useState6[0],\n      setShowFileViewer = _useState6[1];\n\n  var _useState7 = useState(false),\n      _useState8 = _slicedToArray(_useState7, 2),\n      isAnimated = _useState8[0],\n      setIsAnimated = _useState8[1];\n\n  var _useState9 = useState(false),\n      _useState10 = _slicedToArray(_useState9, 2),\n      isHighlighted = _useState10[0],\n      setIsHighlighted = _useState10[1];\n\n  var editMessageInputRef = useRef(null);\n  var useMessageScrollRef = useRef(null);\n  useLayoutEffect(function () {\n    if (highLightedMessageId === message.messageId) {\n      if (useMessageScrollRef && useMessageScrollRef.current) {\n        useMessageScrollRef.current.scrollIntoView({\n          block: 'center',\n          inline: 'center'\n        });\n        setIsAnimated(false);\n        setTimeout(function () {\n          setIsHighlighted(true);\n        }, 500);\n      }\n    } else {\n      setIsHighlighted(false);\n    }\n  }, [highLightedMessageId, useMessageScrollRef.current, message.messageId]);\n  useLayoutEffect(function () {\n    if (animatedMessageId === message.messageId) {\n      if (useMessageScrollRef && useMessageScrollRef.current) {\n        useMessageScrollRef.current.scrollIntoView({\n          block: 'center',\n          inline: 'center'\n        });\n        setIsHighlighted(false);\n        setTimeout(function () {\n          setIsAnimated(true);\n        }, 500);\n      }\n    } else {\n      setIsAnimated(false);\n    }\n  }, [animatedMessageId, useMessageScrollRef.current, message.messageId]);\n  var RenderedMessage = useMemo(function () {\n    if (renderCustomMessage) {\n      return renderCustomMessage(message, currentGroupChannel, chainTop, chainBottom); // TODO: Let's change this to object type on next major version up\n      // and add params 'hasSeparator' and 'menuDisabled', scrollToMessage\n    }\n\n    return null;\n  }, [message, message.message, renderCustomMessage]);\n  var isByMe = userId === sender.userId || message.requestState === 'pending' || message.requestState === 'failed';\n\n  if (RenderedMessage) {\n    return /*#__PURE__*/React__default.createElement(\"div\", {\n      ref: useMessageScrollRef,\n      className: getClassName(['sendbird-msg-hoc sendbird-msg--scroll-ref', isAnimated ? 'sendbird-msg-hoc__animated' : '', isHighlighted ? 'sendbird-msg-hoc__highlighted' : ''])\n    }, hasSeparator && /*#__PURE__*/React__default.createElement(DateSeparator, null, /*#__PURE__*/React__default.createElement(Label, {\n      type: LabelTypography.CAPTION_2,\n      color: LabelColors.ONBACKGROUND_2\n    }, format(message.createdAt, 'MMMM dd, yyyy'))), /*#__PURE__*/React__default.createElement(RenderedMessage, {\n      message: message\n    }));\n  }\n\n  if (showEdit) {\n    return /*#__PURE__*/React__default.createElement(MessageInput, {\n      isEdit: true,\n      disabled: editDisabled,\n      ref: editMessageInputRef,\n      name: message.messageId,\n      onSendMessage: updateMessage,\n      onCancelEdit: function onCancelEdit() {\n        setShowEdit(false);\n      },\n      value: message.message\n    });\n  }\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    ref: useMessageScrollRef,\n    className: getClassName(['sendbird-msg-hoc sendbird-msg--scroll-ref', isAnimated ? 'sendbird-msg-hoc__animated' : '', isHighlighted ? 'sendbird-msg-hoc__highlighted' : '']),\n    style: {\n      marginBottom: '2px'\n    }\n  }, hasSeparator && /*#__PURE__*/React__default.createElement(DateSeparator, null, /*#__PURE__*/React__default.createElement(Label, {\n    type: LabelTypography.CAPTION_2,\n    color: LabelColors.ONBACKGROUND_2\n  }, format(message.createdAt, 'MMMM dd, yyyy'))), /*#__PURE__*/React__default.createElement(MessageContent, {\n    className: \"sendbird-message-hoc__message-content\",\n    userId: userId,\n    scrollToMessage: scrollToMessage,\n    channel: currentGroupChannel,\n    message: message,\n    disabled: disabled,\n    chainTop: chainTop,\n    chainBottom: chainBottom,\n    useReaction: useReaction,\n    replyType: replyType,\n    nicknamesMap: membersMap,\n    emojiContainer: emojiContainer,\n    showEdit: setShowEdit,\n    showRemove: setShowRemove,\n    showFileViewer: setShowFileViewer,\n    resendMessage: resendMessage,\n    toggleReaction: toggleReaction,\n    quoteMessage: quoteMessage,\n    setQuoteMessage: setQuoteMessage\n  }), showRemove && /*#__PURE__*/React__default.createElement(RemoveMessage, {\n    message: message,\n    onCloseModal: function onCloseModal() {\n      return setShowRemove(false);\n    },\n    onDeleteMessage: function onDeleteMessage() {\n      deleteMessage(message);\n\n      if ((message === null || message === void 0 ? void 0 : message.messageId) === (quoteMessage === null || quoteMessage === void 0 ? void 0 : quoteMessage.messageId)) {\n        setQuoteMessage(null);\n      }\n    }\n  }), showFileViewer && /*#__PURE__*/React__default.createElement(FileViewer, {\n    onClose: function onClose() {\n      return setShowFileViewer(false);\n    },\n    message: message,\n    onDelete: function onDelete() {\n      deleteMessage(message, function () {\n        setShowFileViewer(false);\n      });\n    },\n    isByMe: isByMe\n  }));\n}\n\nMessageHoc.propTypes = {\n  userId: PropTypes.string,\n  message: PropTypes.shape({\n    isFileMessage: PropTypes.func,\n    isAdminMessage: PropTypes.func,\n    isUserMessage: PropTypes.func,\n    isDateseparator: PropTypes.func,\n    // should be a number, but there's a bug in SDK shich returns string\n    messageId: PropTypes.number,\n    type: PropTypes.string,\n    createdAt: PropTypes.number,\n    message: PropTypes.string,\n    requestState: PropTypes.string,\n    messageType: PropTypes.string,\n    sender: PropTypes.shape({\n      userId: PropTypes.string\n    }),\n    ogMetaData: PropTypes.shape({}),\n    parentMessageId: PropTypes.number\n  }),\n  animatedMessageId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  highLightedMessageId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  renderCustomMessage: PropTypes.func,\n  currentGroupChannel: PropTypes.shape({}),\n  hasSeparator: PropTypes.bool,\n  disabled: PropTypes.bool,\n  editDisabled: PropTypes.bool,\n  deleteMessage: PropTypes.func.isRequired,\n  scrollToMessage: PropTypes.func,\n  updateMessage: PropTypes.func.isRequired,\n  resendMessage: PropTypes.func.isRequired,\n  useReaction: PropTypes.bool.isRequired,\n  replyType: PropTypes.oneOf(['NONE', 'QUOTE_REPLY', 'THREAD']).isRequired,\n  chainTop: PropTypes.bool.isRequired,\n  chainBottom: PropTypes.bool.isRequired,\n  membersMap: PropTypes.instanceOf(Map).isRequired,\n  emojiContainer: PropTypes.shape({\n    emojiCategories: PropTypes.arrayOf(PropTypes.shape({\n      emojis: PropTypes.arrayOf(PropTypes.shape({\n        key: PropTypes.string,\n        url: PropTypes.string\n      }))\n    }))\n  }),\n  toggleReaction: PropTypes.func,\n  quoteMessage: PropTypes.shape({\n    messageId: PropTypes.string\n  }),\n  setQuoteMessage: PropTypes.func.isRequired\n};\nMessageHoc.defaultProps = {\n  userId: '',\n  editDisabled: false,\n  renderCustomMessage: null,\n  currentGroupChannel: {},\n  message: {},\n  hasSeparator: false,\n  disabled: false,\n  animatedMessageId: null,\n  highLightedMessageId: null,\n  toggleReaction: function toggleReaction() {},\n  scrollToMessage: function scrollToMessage() {},\n  emojiContainer: {},\n  quoteMessage: null\n};\n\nvar ConversationScroll = /*#__PURE__*/function (_Component) {\n  _inherits(ConversationScroll, _Component);\n\n  var _super = _createSuper(ConversationScroll);\n\n  function ConversationScroll() {\n    var _this;\n\n    _classCallCheck(this, ConversationScroll);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"onScroll\", function (e) {\n      var _this$props = _this.props,\n          scrollRef = _this$props.scrollRef,\n          hasMore = _this$props.hasMore,\n          messagesDispatcher = _this$props.messagesDispatcher,\n          onScroll = _this$props.onScroll,\n          onScrollDown = _this$props.onScrollDown,\n          currentGroupChannel = _this$props.currentGroupChannel;\n      var element = e.target;\n      var scrollTop = element.scrollTop,\n          clientHeight = element.clientHeight,\n          scrollHeight = element.scrollHeight;\n\n      if (scrollTop === 0) {\n        if (!hasMore) {\n          return;\n        }\n\n        var nodes = scrollRef.current.querySelectorAll('.sendbird-msg--scroll-ref');\n        var first = nodes && nodes[0];\n        onScroll(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 1),\n              messages = _ref2[0];\n\n          if (messages) {\n            // https://github.com/scabbiaza/react-scroll-position-on-updating-dom\n            try {\n              first.scrollIntoView();\n            } catch (error) {//\n            }\n          }\n        });\n      }\n\n      if (clientHeight + scrollTop === scrollHeight) {\n        var _nodes = scrollRef.current.querySelectorAll('.sendbird-msg--scroll-ref');\n\n        var last = _nodes && _nodes[_nodes.length - 1];\n        onScrollDown(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 1),\n              messages = _ref4[0];\n\n          if (messages) {\n            // https://github.com/scabbiaza/react-scroll-position-on-updating-dom\n            try {\n              last.scrollIntoView();\n            } catch (error) {//\n            }\n          }\n        });\n      } // do this later\n\n\n      setTimeout(function () {\n        // mark as read if scroll is at end\n        if (clientHeight + scrollTop === scrollHeight) {\n          messagesDispatcher({\n            type: MARK_AS_READ\n          });\n          currentGroupChannel.markAsRead();\n        }\n      }, 500);\n    });\n\n    return _this;\n  }\n\n  _createClass(ConversationScroll, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          userId = _this$props2.userId,\n          disabled = _this$props2.disabled,\n          scrollRef = _this$props2.scrollRef,\n          membersMap = _this$props2.membersMap,\n          allMessages = _this$props2.allMessages,\n          scrollToMessage = _this$props2.scrollToMessage,\n          useReaction = _this$props2.useReaction,\n          replyType = _this$props2.replyType,\n          emojiAllMap = _this$props2.emojiAllMap,\n          editDisabled = _this$props2.editDisabled,\n          deleteMessage = _this$props2.deleteMessage,\n          updateMessage = _this$props2.updateMessage,\n          resendMessage = _this$props2.resendMessage,\n          renderCustomMessage = _this$props2.renderCustomMessage,\n          renderChatItem = _this$props2.renderChatItem,\n          animatedMessageId = _this$props2.animatedMessageId,\n          highLightedMessageId = _this$props2.highLightedMessageId,\n          emojiContainer = _this$props2.emojiContainer,\n          toggleReaction = _this$props2.toggleReaction,\n          useMessageGrouping = _this$props2.useMessageGrouping,\n          currentGroupChannel = _this$props2.currentGroupChannel,\n          memoizedEmojiListItems = _this$props2.memoizedEmojiListItems,\n          showScrollBot = _this$props2.showScrollBot,\n          onClickScrollBot = _this$props2.onClickScrollBot,\n          quoteMessage = _this$props2.quoteMessage,\n          setQuoteMessage = _this$props2.setQuoteMessage;\n\n      if (allMessages.length < 1) {\n        return /*#__PURE__*/React__default.createElement(PlaceHolder, {\n          className: \"sendbird-conversation__no-messages\",\n          type: PlaceHolderTypes.NO_MESSAGES\n        });\n      }\n\n      return /*#__PURE__*/React__default.createElement(\"div\", {\n        className: \"sendbird-conversation__messages\"\n      }, /*#__PURE__*/React__default.createElement(\"div\", {\n        ref: scrollRef,\n        className: \"sendbird-conversation__scroll-container\",\n        onScroll: this.onScroll\n      }, /*#__PURE__*/React__default.createElement(\"div\", {\n        className: \"sendbird-conversation__padding\"\n      }), /*#__PURE__*/React__default.createElement(\"div\", {\n        className: \"sendbird-conversation__messages-padding\"\n      }, allMessages.map(function (m, idx) {\n        var previousMessage = allMessages[idx - 1];\n        var nextMessage = allMessages[idx + 1];\n\n        var _ref5 = useMessageGrouping ? compareMessagesForGrouping(previousMessage, m, nextMessage) : [false, false],\n            _ref6 = _slicedToArray(_ref5, 2),\n            chainTop = _ref6[0],\n            chainBottom = _ref6[1];\n\n        var previousMessageCreatedAt = previousMessage && previousMessage.createdAt;\n        var currentCreatedAt = m.createdAt; // https://stackoverflow.com/a/41855608\n\n        var hasSeparator = !(previousMessageCreatedAt && isSameDay(currentCreatedAt, previousMessageCreatedAt));\n\n        if (renderChatItem) {\n          return /*#__PURE__*/React__default.createElement(\"div\", {\n            key: m.messageId || m.reqId,\n            className: \"sendbird-msg--scroll-ref\"\n          }, renderChatItem({\n            message: m,\n            animatedMessageId: animatedMessageId,\n            highLightedMessageId: highLightedMessageId,\n            channel: currentGroupChannel,\n            onDeleteMessage: deleteMessage,\n            onUpdateMessage: updateMessage,\n            onResendMessage: resendMessage,\n            onScrollToMessage: scrollToMessage,\n            onReplyMessage: setQuoteMessage,\n            emojiContainer: emojiContainer,\n            chainTop: chainTop,\n            chainBottom: chainBottom,\n            hasSeparator: hasSeparator,\n            menuDisabled: disabled\n          }));\n        }\n\n        return /*#__PURE__*/React__default.createElement(MessageHoc, {\n          animatedMessageId: animatedMessageId,\n          highLightedMessageId: highLightedMessageId,\n          renderCustomMessage: renderCustomMessage,\n          key: m.messageId || m.reqId,\n          userId: userId // show status for pending/failed messages\n          ,\n          message: m,\n          quoteMessage: quoteMessage,\n          scrollToMessage: scrollToMessage,\n          currentGroupChannel: currentGroupChannel,\n          disabled: disabled,\n          membersMap: membersMap,\n          chainTop: chainTop,\n          useReaction: useReaction,\n          replyType: replyType,\n          emojiAllMap: emojiAllMap,\n          emojiContainer: emojiContainer,\n          editDisabled: editDisabled,\n          hasSeparator: hasSeparator,\n          chainBottom: chainBottom,\n          updateMessage: updateMessage,\n          deleteMessage: deleteMessage,\n          resendMessage: resendMessage,\n          toggleReaction: toggleReaction,\n          setQuoteMessage: setQuoteMessage,\n          memoizedEmojiListItems: memoizedEmojiListItems\n        });\n      }))), showScrollBot && /*#__PURE__*/React__default.createElement(\"div\", {\n        className: \"sendbird-conversation__scroll-bottom-button\",\n        onClick: onClickScrollBot,\n        onKeyDown: onClickScrollBot,\n        tabIndex: 0,\n        role: \"button\"\n      }, /*#__PURE__*/React__default.createElement(Icon, {\n        width: \"24px\",\n        height: \"24px\",\n        type: IconTypes.CHEVRON_DOWN,\n        fillColor: IconColors.PRIMARY\n      })));\n    }\n  }]);\n\n  return ConversationScroll;\n}(Component);\n\nConversationScroll.propTypes = {\n  // https://stackoverflow.com/a/52646941\n  scrollRef: PropTypes.shape({\n    current: PropTypes.oneOfType([PropTypes.element, PropTypes.shape({})])\n  }).isRequired,\n  hasMore: PropTypes.bool,\n  messagesDispatcher: PropTypes.func.isRequired,\n  onScroll: PropTypes.func,\n  onScrollDown: PropTypes.func,\n  editDisabled: PropTypes.bool,\n  disabled: PropTypes.bool,\n  userId: PropTypes.string,\n  allMessages: PropTypes.arrayOf(PropTypes.shape({\n    createdAt: PropTypes.number\n  })).isRequired,\n  deleteMessage: PropTypes.func.isRequired,\n  resendMessage: PropTypes.func.isRequired,\n  updateMessage: PropTypes.func.isRequired,\n  currentGroupChannel: PropTypes.shape({\n    markAsRead: PropTypes.func,\n    members: PropTypes.arrayOf(PropTypes.shape({}))\n  }).isRequired,\n  animatedMessageId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  highLightedMessageId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  renderChatItem: PropTypes.element,\n  renderCustomMessage: PropTypes.func,\n  scrollToMessage: PropTypes.func,\n  useReaction: PropTypes.bool,\n  replyType: PropTypes.oneOf(['NONE', 'QUOTE_REPLY', 'THREAD']),\n  showScrollBot: PropTypes.bool,\n  onClickScrollBot: PropTypes.func,\n  emojiContainer: PropTypes.shape({}),\n  emojiAllMap: PropTypes.instanceOf(Map),\n  membersMap: PropTypes.instanceOf(Map),\n  useMessageGrouping: PropTypes.bool,\n  toggleReaction: PropTypes.func,\n  memoizedEmojiListItems: PropTypes.func,\n  quoteMessage: PropTypes.shape({}),\n  setQuoteMessage: PropTypes.func.isRequired\n};\nConversationScroll.defaultProps = {\n  hasMore: false,\n  editDisabled: false,\n  disabled: false,\n  userId: '',\n  renderCustomMessage: null,\n  renderChatItem: null,\n  animatedMessageId: null,\n  highLightedMessageId: null,\n  onScroll: null,\n  onScrollDown: null,\n  useReaction: true,\n  replyType: 'NONE',\n  emojiContainer: {},\n  showScrollBot: false,\n  onClickScrollBot: function onClickScrollBot() {},\n  scrollToMessage: function scrollToMessage() {},\n  emojiAllMap: new Map(),\n  membersMap: new Map(),\n  useMessageGrouping: true,\n  toggleReaction: function toggleReaction() {},\n  memoizedEmojiListItems: function memoizedEmojiListItems() {\n    return '';\n  },\n  quoteMessage: null\n};\n\nfunction Notification(_ref) {\n  var count = _ref.count,\n      time = _ref.time,\n      onClick = _ref.onClick;\n\n  var _useContext = useContext(LocalizationContext),\n      stringSet = _useContext.stringSet;\n\n  var timeArray = time.split(' ');\n  timeArray.splice(-2, 0, stringSet.CHANNEL__MESSAGE_LIST__NOTIFICATION__ON);\n  return (\n    /*#__PURE__*/\n    // eslint-disable-next-line\n    React__default.createElement(\"div\", {\n      className: \"sendbird-notification\",\n      onClick: onClick\n    }, /*#__PURE__*/React__default.createElement(Label, {\n      className: \"sendbird-notification__text\",\n      color: LabelColors.ONCONTENT_1,\n      type: LabelTypography.CAPTION_2\n    }, \"\".concat(count, \" \"), stringSet.CHANNEL__MESSAGE_LIST__NOTIFICATION__NEW_MESSAGE, \" \".concat(timeArray.join(' '))), /*#__PURE__*/React__default.createElement(Icon, {\n      width: \"24px\",\n      height: \"24px\",\n      type: IconTypes.CHEVRON_DOWN,\n      fillColor: IconColors.CONTENT\n    }))\n  );\n}\n\nNotification.propTypes = {\n  count: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  time: PropTypes.string,\n  onClick: PropTypes.func.isRequired\n};\nNotification.defaultProps = {\n  count: 0,\n  time: ''\n};\n\nvar FrozenNotification = function FrozenNotification() {\n  var stringSet = useContext(LocalizationContext).stringSet;\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-notification sendbird-notification--frozen\"\n  }, /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-notification__text\",\n    type: LabelTypography.CAPTION_2\n  }, stringSet.CHANNEL_FROZEN));\n};\n\nvar TypingIndicatorText = function TypingIndicatorText(_ref) {\n  var members = _ref.members;\n\n  var _useContext = useContext(LocalizationContext),\n      stringSet = _useContext.stringSet;\n\n  if (!members || members.length === 0) {\n    return '';\n  }\n\n  if (members && members.length === 1) {\n    return \"\".concat(members[0].nickname, \" \").concat(stringSet.TYPING_INDICATOR__IS_TYPING);\n  }\n\n  if (members && members.length === 2) {\n    return \"\".concat(members[0].nickname, \" \").concat(stringSet.TYPING_INDICATOR__AND, \" \").concat(members[1].nickname, \" \").concat(stringSet.TYPING_INDICATOR__ARE_TYPING);\n  }\n\n  return stringSet.TYPING_INDICATOR__MULTIPLE_TYPING;\n};\n\nfunction TypingIndicator(props) {\n  var className = props.className,\n      channelUrl = props.channelUrl,\n      sb = props.sb,\n      logger = props.logger;\n\n  var _useState = useState(uuidv4()),\n      _useState2 = _slicedToArray(_useState, 2),\n      handlerId = _useState2[0],\n      setHandlerId = _useState2[1];\n\n  var _useState3 = useState([]),\n      _useState4 = _slicedToArray(_useState3, 2),\n      typingMembers = _useState4[0],\n      setTypingMembers = _useState4[1];\n\n  useEffect(function () {\n    if (sb && sb.ChannelHandler) {\n      sb.removeChannelHandler(handlerId);\n      var newHandlerId = uuidv4();\n      var handler = new sb.ChannelHandler(); // there is a possible warning in here - setState called after unmount\n\n      handler.onTypingStatusUpdated = function (groupChannel) {\n        logger.info('Channel > Typing Indicator: onTypingStatusUpdated', groupChannel);\n        var members = groupChannel.getTypingMembers();\n\n        if (groupChannel.url === channelUrl) {\n          setTypingMembers(members);\n        }\n      };\n\n      sb.addChannelHandler(newHandlerId, handler);\n      setHandlerId(newHandlerId);\n    }\n\n    return function () {\n      setTypingMembers([]);\n\n      if (sb && sb.removeChannelHandler) {\n        sb.removeChannelHandler(handlerId);\n      }\n    };\n  }, [channelUrl]);\n  return /*#__PURE__*/React__default.createElement(Label, {\n    className: className,\n    type: LabelTypography.CAPTION_2,\n    color: LabelColors.ONBACKGROUND_2\n  }, /*#__PURE__*/React__default.createElement(TypingIndicatorText, {\n    members: typingMembers\n  }));\n}\n\nTypingIndicator.propTypes = {\n  className: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n  channelUrl: PropTypes.string.isRequired,\n  sb: PropTypes.shape({\n    ChannelHandler: PropTypes.func,\n    removeChannelHandler: PropTypes.func,\n    addChannelHandler: PropTypes.func\n  }).isRequired,\n  logger: PropTypes.shape({\n    info: PropTypes.func\n  }).isRequired\n};\nTypingIndicator.defaultProps = {\n  className: ''\n};\nvar componentClassname = 'sendbird-quote_message_input__avatar';\n\nfunction QuoteMessageThumbnail(_a) {\n  var message = _a.message;\n\n  if (!isFileMessage(message)) {\n    return null;\n  }\n\n  var thumbnailUrl = message.thumbnails && message.thumbnails.length > 0 && message.thumbnails[0].url || isImageMessage(message) && message.url;\n\n  if (isThumbnailMessage(message) && thumbnailUrl) {\n    return /*#__PURE__*/React__default.createElement(ImageRenderer, {\n      className: componentClassname,\n      url: thumbnailUrl,\n      alt: message.type,\n      width: \"44px\",\n      height: \"44px\",\n      fixedSize: true\n    });\n  } else if (isAudioMessage(message)) {\n    return /*#__PURE__*/React__default.createElement(\"div\", {\n      className: componentClassname\n    }, /*#__PURE__*/React__default.createElement(Icon, {\n      type: IconTypes.FILE_AUDIO,\n      fillColor: IconColors.ON_BACKGROUND_2,\n      width: \"24px\",\n      height: \"24px\"\n    }));\n  } else {\n    return /*#__PURE__*/React__default.createElement(\"div\", {\n      className: componentClassname\n    }, /*#__PURE__*/React__default.createElement(Icon, {\n      type: IconTypes.FILE_DOCUMENT,\n      fillColor: IconColors.ON_BACKGROUND_2,\n      width: \"24px\",\n      height: \"24px\"\n    }));\n  }\n}\n\nfunction QuoteMessageInput(_a) {\n  var _b;\n\n  var className = _a.className,\n      replyingMessage = _a.replyingMessage,\n      onClose = _a.onClose;\n  var stringSet = useContext(LocalizationContext).stringSet;\n  var fileMessage = replyingMessage;\n  var sender = (_b = replyingMessage) === null || _b === void 0 ? void 0 : _b.sender;\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: getClassName(['sendbird-quote_message_input', className])\n  }, /*#__PURE__*/React__default.createElement(QuoteMessageThumbnail, {\n    message: fileMessage\n  }), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-quote_message_input__body\",\n    style: {\n      width: \"calc(100% - \" + (fileMessage.isFileMessage() ? '164px' : '120px') + \")\",\n      left: fileMessage.isFileMessage() ? '92px' : '40px'\n    }\n  }, /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-quote_message_input__body__sender-name\",\n    type: LabelTypography.CAPTION_1,\n    color: LabelColors.ONBACKGROUND_1\n  }, stringSet.QUOTE_MESSAGE_INPUT__REPLY_TO + \" \" + (sender && sender.nickname ? sender.nickname : stringSet.NO_NAME)), /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-quote_message_input__body__message-content\",\n    type: LabelTypography.BODY_2,\n    color: LabelColors.ONBACKGROUND_3\n  }, isImageMessage(fileMessage) && !isGifMessage(fileMessage) && stringSet.QUOTE_MESSAGE_INPUT__FILE_TYPE_IMAGE, isVideoMessage(fileMessage) && stringSet.QUOTE_MESSAGE_INPUT__FILE_TYPE__VIDEO, isGifMessage(fileMessage) && stringSet.QUOTE_MESSAGE_INPUT__FILE_TYPE_GIF, isUserMessage(replyingMessage) && replyingMessage.message, isFileMessage(fileMessage) && !isThumbnailMessage(fileMessage) && fileMessage.name)), /*#__PURE__*/React__default.createElement(Icon, {\n    className: \"sendbird-quote_message_input__close-button\",\n    type: IconTypes.CLOSE,\n    fillColor: IconColors.ON_BACKGROUND_2,\n    width: \"24px\",\n    height: \"24px\",\n    onClick: function onClick() {\n      return onClose(replyingMessage);\n    }\n  }));\n} // Logic required to handle message input rendering\n\n\nvar MessageInputWrapper = function MessageInputWrapper(_a, ref) {\n  var channel = _a.channel,\n      user = _a.user,\n      isOnline = _a.isOnline,\n      initialized = _a.initialized,\n      quoteMessage = _a.quoteMessage,\n      _onSendMessage = _a.onSendMessage,\n      _onFileUpload = _a.onFileUpload,\n      setQuoteMessage = _a.setQuoteMessage,\n      renderMessageInput = _a.renderMessageInput;\n  var stringSet = useContext(LocalizationContext).stringSet;\n  var disabled = !initialized || isDisabledBecauseFrozen(channel) || isDisabledBecauseMuted(channel) || !isOnline;\n  var isOperator$1 = isOperator(channel);\n  var isBroadcast = channel.isBroadcast; // custom message\n\n  if (renderMessageInput) {\n    return renderMessageInput({\n      channel: channel,\n      user: user,\n      disabled: disabled,\n      quoteMessage: quoteMessage\n    });\n  } // broadcast channel + not operator\n\n\n  if (isBroadcast && !isOperator$1) {\n    return null;\n  } // other conditions\n\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-message-input-wrapper\"\n  }, quoteMessage && /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-message-input-wrapper__quote-message-input\"\n  }, /*#__PURE__*/React__default.createElement(QuoteMessageInput, {\n    replyingMessage: quoteMessage,\n    onClose: function onClose() {\n      return setQuoteMessage(null);\n    }\n  })), /*#__PURE__*/React__default.createElement(MessageInput, {\n    className: \"sendbird-message-input-wrapper__message-input\",\n    channelUrl: channel === null || channel === void 0 ? void 0 : channel.url,\n    placeholder: quoteMessage && stringSet.MESSAGE_INPUT__QUOTE_REPLY__PLACE_HOLDER || isDisabledBecauseFrozen(channel) && stringSet.MESSAGE_INPUT__PLACE_HOLDER__DISABLED || isDisabledBecauseMuted(channel) && stringSet.MESSAGE_INPUT__PLACE_HOLDER__MUTED,\n    ref: ref,\n    disabled: disabled,\n    onStartTyping: function onStartTyping() {\n      channel.startTyping();\n    },\n    onSendMessage: function onSendMessage() {\n      _onSendMessage(quoteMessage);\n\n      setQuoteMessage(null);\n    },\n    onFileUpload: function onFileUpload(file) {\n      _onFileUpload(file, quoteMessage);\n\n      setQuoteMessage(null);\n    }\n  }));\n};\n\nvar MessageInputWrapper$1 = /*#__PURE__*/React__default.forwardRef(MessageInputWrapper);\n\nfunction ConnectionStatus() {\n  var _useContext = useContext(LocalizationContext),\n      stringSet = _useContext.stringSet;\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-connection-status\"\n  }, /*#__PURE__*/React__default.createElement(Label, {\n    type: LabelTypography.BODY_2,\n    color: LabelColors.ONBACKGROUND_2\n  }, stringSet.TRYING_TO_CONNECT), /*#__PURE__*/React__default.createElement(Icon, {\n    type: IconTypes.DISCONNECTED,\n    fillColor: IconColors.SENT,\n    width: \"14px\",\n    height: \"14px\"\n  }));\n}\n\nvar getChannelTitle = function getChannelTitle() {\n  var channel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var currentUserId = arguments.length > 1 ? arguments[1] : undefined;\n  var stringSet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : LabelStringSet;\n\n  if (!channel || !channel.name && !channel.members) {\n    return stringSet.NO_TITLE;\n  }\n\n  if (channel.name && channel.name !== 'Group Channel') {\n    return channel.name;\n  }\n\n  if (channel.members.length === 1) {\n    return stringSet.NO_MEMBERS;\n  }\n\n  return channel.members.filter(function (_ref) {\n    var userId = _ref.userId;\n    return userId !== currentUserId;\n  }).map(function (_ref2) {\n    var nickname = _ref2.nickname;\n    return nickname || stringSet.NO_NAME;\n  }).join(', ');\n};\n\nvar noop$1 = function noop() {};\n\nfunction ChatHeader(props) {\n  var currentGroupChannel = props.currentGroupChannel,\n      currentUser = props.currentUser,\n      title = props.title,\n      subTitle = props.subTitle,\n      isMuted = props.isMuted,\n      theme = props.theme,\n      showSearchIcon = props.showSearchIcon,\n      onSearchClick = props.onSearchClick,\n      onActionClick = props.onActionClick;\n  var userId = currentUser.userId;\n\n  var _useContext = useContext(LocalizationContext),\n      stringSet = _useContext.stringSet;\n\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-chat-header\"\n  }, /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-chat-header__left\"\n  }, /*#__PURE__*/React__default.createElement(ChannelAvatar, {\n    theme: theme,\n    channel: currentGroupChannel,\n    userId: userId,\n    height: 32,\n    width: 32\n  }), /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-chat-header__left__title\",\n    type: LabelTypography.H_2,\n    color: LabelColors.ONBACKGROUND_1\n  }, title || getChannelTitle(currentGroupChannel, userId, stringSet)), /*#__PURE__*/React__default.createElement(Label, {\n    className: \"sendbird-chat-header__left__subtitle\",\n    type: LabelTypography.BODY_1,\n    color: LabelColors.ONBACKGROUND_2\n  }, subTitle)), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-chat-header__right\"\n  }, (typeof isMuted === 'string' && isMuted === 'true' || typeof isMuted === 'boolean' && isMuted) && /*#__PURE__*/React__default.createElement(Icon, {\n    className: \"sendbird-chat-header__right__mute\",\n    type: IconTypes.NOTIFICATIONS_OFF_FILLED,\n    width: \"24px\",\n    height: \"24px\"\n  }), showSearchIcon && /*#__PURE__*/React__default.createElement(IconButton, {\n    className: \"sendbird-chat-header__right__search\",\n    width: \"32px\",\n    height: \"32px\",\n    onClick: onSearchClick\n  }, /*#__PURE__*/React__default.createElement(Icon, {\n    type: IconTypes.SEARCH,\n    fillColor: IconColors.PRIMARY,\n    width: \"24px\",\n    height: \"24px\"\n  })), /*#__PURE__*/React__default.createElement(IconButton, {\n    className: \"sendbird-chat-header__right__info\",\n    width: \"32px\",\n    height: \"32px\",\n    onClick: onActionClick\n  }, /*#__PURE__*/React__default.createElement(Icon, {\n    type: IconTypes.INFO,\n    fillColor: IconColors.PRIMARY,\n    width: \"24px\",\n    height: \"24px\"\n  }))));\n}\n\nChatHeader.propTypes = {\n  currentGroupChannel: PropTypes.shape({\n    members: PropTypes.arrayOf(PropTypes.shape({})),\n    coverUrl: PropTypes.string\n  }),\n  currentUser: PropTypes.shape({\n    userId: PropTypes.string\n  }),\n  title: PropTypes.string,\n  subTitle: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),\n  isMuted: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n  theme: PropTypes.string,\n  showSearchIcon: PropTypes.bool,\n  onSearchClick: PropTypes.func,\n  onActionClick: PropTypes.func\n};\nChatHeader.defaultProps = {\n  currentGroupChannel: {},\n  currentUser: {},\n  title: '',\n  subTitle: '',\n  isMuted: false,\n  theme: 'light',\n  showSearchIcon: false,\n  onSearchClick: noop$1,\n  onActionClick: noop$1\n};\n\nvar noop = function noop() {};\n\nvar ConversationPanel = function ConversationPanel(props) {\n  var channelUrl = props.channelUrl,\n      _props$stores = props.stores,\n      sdkStore = _props$stores.sdkStore,\n      userStore = _props$stores.userStore,\n      _props$config = props.config,\n      userId = _props$config.userId,\n      logger = _props$config.logger,\n      pubSub = _props$config.pubSub,\n      isOnline = _props$config.isOnline,\n      theme = _props$config.theme,\n      imageCompression = _props$config.imageCompression,\n      reconnect = props.dispatchers.reconnect,\n      _props$queries = props.queries,\n      queries = _props$queries === void 0 ? {} : _props$queries,\n      startingPoint = props.startingPoint,\n      highlightedMessage = props.highlightedMessage,\n      useReaction = props.useReaction,\n      replyType = props.replyType,\n      showSearchIcon = props.showSearchIcon,\n      onSearchClick = props.onSearchClick,\n      renderChatItem = props.renderChatItem,\n      renderChatHeader = props.renderChatHeader,\n      renderCustomMessage = props.renderCustomMessage,\n      renderUserProfile = props.renderUserProfile,\n      disableUserProfile = props.disableUserProfile,\n      renderMessageInput = props.renderMessageInput,\n      useMessageGrouping = props.useMessageGrouping,\n      onChatHeaderActionClick = props.onChatHeaderActionClick,\n      onBeforeSendUserMessage = props.onBeforeSendUserMessage,\n      onBeforeSendFileMessage = props.onBeforeSendFileMessage,\n      onBeforeUpdateUserMessage = props.onBeforeUpdateUserMessage;\n  var sdk = sdkStore.sdk;\n  var config = props.config;\n  var sdkError = sdkStore.error;\n  var sdkInit = sdkStore.initialized;\n  var user = userStore.user;\n\n  if (queries.messageListQuery) {\n    // eslint-disable-next-line no-console\n    console.warn('messageListQuery has been deprecated, please use messageListParams instead');\n  }\n\n  useEffect(function () {\n    if (renderCustomMessage) {\n      // eslint-disable-next-line no-console\n      console.info('The parameter type of renderCustomMessage will be changed to the object in the next minor update.');\n    }\n  }, []);\n\n  var _useState = useState(startingPoint),\n      _useState2 = _slicedToArray(_useState, 2),\n      intialTimeStamp = _useState2[0],\n      setIntialTimeStamp = _useState2[1];\n\n  useEffect(function () {\n    setIntialTimeStamp(startingPoint);\n  }, [startingPoint, channelUrl]);\n\n  var _useState3 = useState(''),\n      _useState4 = _slicedToArray(_useState3, 2),\n      animatedMessageId = _useState4[0],\n      setAnimatedMessageId = _useState4[1];\n\n  var _useState5 = useState(highlightedMessage),\n      _useState6 = _slicedToArray(_useState5, 2),\n      highLightedMessageId = _useState6[0],\n      setHighLightedMessageId = _useState6[1];\n\n  useEffect(function () {\n    setHighLightedMessageId(highlightedMessage);\n  }, [highlightedMessage]);\n  var userFilledMessageListQuery = queries.messageListParams;\n\n  var _useState7 = useState(null),\n      _useState8 = _slicedToArray(_useState7, 2),\n      quoteMessage = _useState8[0],\n      setQuoteMessage = _useState8[1];\n\n  var _useReducer = useReducer(reducer, messagesInitialState),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      messagesStore = _useReducer2[0],\n      messagesDispatcher = _useReducer2[1];\n\n  var scrollRef = useRef(null);\n  var allMessages = messagesStore.allMessages,\n      loading = messagesStore.loading,\n      initialized = messagesStore.initialized,\n      unreadCount = messagesStore.unreadCount,\n      unreadSince = messagesStore.unreadSince,\n      isInvalid = messagesStore.isInvalid,\n      _messagesStore$curren = messagesStore.currentGroupChannel,\n      currentGroupChannel = _messagesStore$curren === void 0 ? {} : _messagesStore$curren,\n      hasMore = messagesStore.hasMore,\n      lastMessageTimeStamp = messagesStore.lastMessageTimeStamp,\n      hasMoreToBottom = messagesStore.hasMoreToBottom,\n      latestFetchedMessageTimeStamp = messagesStore.latestFetchedMessageTimeStamp,\n      emojiContainer = messagesStore.emojiContainer,\n      readStatus = messagesStore.readStatus;\n  var isFrozen = currentGroupChannel.isFrozen,\n      isBroadcast = currentGroupChannel.isBroadcast,\n      isSuper = currentGroupChannel.isSuper;\n  var _sdk$appInfo = sdk.appInfo,\n      appInfo = _sdk$appInfo === void 0 ? {} : _sdk$appInfo;\n  var usingReaction = appInfo.isUsingReaction && !isBroadcast && !isSuper && useReaction // TODO: Make useReaction independent from appInfo.isUsingReaction\n  ;\n  var userDefinedDisableUserProfile = disableUserProfile || config.disableUserProfile;\n  var userDefinedRenderProfile = renderUserProfile || config.renderUserProfile;\n  var showScrollBot = hasMoreToBottom; // TODO: emojiAllMap, emoijAllList, nicknamesMap => should be moved to messagesStore\n\n  var emojiAllMap = useMemo(function () {\n    return usingReaction ? getAllEmojisMapFromEmojiContainer(emojiContainer) : new Map();\n  }, [emojiContainer]);\n  var emojiAllList = useMemo(function () {\n    return usingReaction ? getAllEmojisFromEmojiContainer$1(emojiContainer) : [];\n  }, [emojiContainer]);\n  var nicknamesMap = useMemo(function () {\n    return usingReaction ? getNicknamesMapFromMembers(currentGroupChannel.members) : new Map();\n  }, [currentGroupChannel.members]); // Scrollup is default scroll for channel\n\n  var onScrollCallback = useScrollCallback({\n    currentGroupChannel: currentGroupChannel,\n    lastMessageTimeStamp: lastMessageTimeStamp,\n    userFilledMessageListQuery: userFilledMessageListQuery,\n    replyType: replyType\n  }, {\n    hasMore: hasMore,\n    logger: logger,\n    messagesDispatcher: messagesDispatcher,\n    sdk: sdk\n  });\n  var scrollToMessage = useScrollToMessage({\n    setIntialTimeStamp: setIntialTimeStamp,\n    setAnimatedMessageId: setAnimatedMessageId,\n    allMessages: allMessages\n  }, {\n    logger: logger\n  }); // onScrollDownCallback is added for navigation to different timestamps on messageSearch\n  // hasMoreToBottom, onScrollDownCallback -> scroll down\n  // hasMore, onScrollCallback -> scroll up(default behavior)\n\n  var onScrollDownCallback = useScrollDownCallback({\n    currentGroupChannel: currentGroupChannel,\n    latestFetchedMessageTimeStamp: latestFetchedMessageTimeStamp,\n    userFilledMessageListQuery: userFilledMessageListQuery,\n    hasMoreToBottom: hasMoreToBottom,\n    replyType: replyType\n  }, {\n    logger: logger,\n    messagesDispatcher: messagesDispatcher,\n    sdk: sdk\n  });\n  var toggleReaction = useToggleReactionCallback({\n    currentGroupChannel: currentGroupChannel\n  }, {\n    logger: logger\n  });\n  var memoizedEmojiListItems = useMemoizedEmojiListItems({\n    emojiContainer: emojiContainer,\n    toggleReaction: toggleReaction\n  }, {\n    useReaction: usingReaction,\n    logger: logger,\n    userId: userId,\n    emojiAllList: emojiAllList\n  }); // to create message-datasource\n  // this hook sets currentGroupChannel asynchronously\n\n  useSetChannel({\n    channelUrl: channelUrl,\n    sdkInit: sdkInit\n  }, {\n    messagesDispatcher: messagesDispatcher,\n    sdk: sdk,\n    logger: logger\n  });\n  useEffect(function () {\n    setQuoteMessage(null);\n  }, [channelUrl]); // Hook to handle ChannelEvents and send values to useReducer using messagesDispatcher\n\n  useHandleChannelEvents({\n    currentGroupChannel: currentGroupChannel,\n    sdkInit: sdkInit,\n    hasMoreToBottom: hasMoreToBottom\n  }, {\n    messagesDispatcher: messagesDispatcher,\n    sdk: sdk,\n    logger: logger,\n    scrollRef: scrollRef,\n    setQuoteMessage: setQuoteMessage\n  }); // hook that fetches messages when channel changes\n  // to be clear here useGetChannel sets currentGroupChannel\n  // and useInitialMessagesFetch executes when currentGroupChannel changes\n  // p.s This one executes on intialTimeStamp change too\n\n  useInitialMessagesFetch({\n    currentGroupChannel: currentGroupChannel,\n    userFilledMessageListQuery: userFilledMessageListQuery,\n    intialTimeStamp: intialTimeStamp,\n    replyType: replyType\n  }, {\n    sdk: sdk,\n    logger: logger,\n    messagesDispatcher: messagesDispatcher\n  }); // handles API calls from withSendbird\n\n  useEffect(function () {\n    var subScriber = pubSubHandler(channelUrl, pubSub, messagesDispatcher);\n    return function () {\n      pubSubHandleRemover(subScriber);\n    };\n  }, [channelUrl, sdkInit]); // handling connection breaks\n\n  useHandleReconnect({\n    isOnline: isOnline,\n    replyType: replyType\n  }, {\n    logger: logger,\n    sdk: sdk,\n    currentGroupChannel: currentGroupChannel,\n    messagesDispatcher: messagesDispatcher,\n    userFilledMessageListQuery: userFilledMessageListQuery\n  }); // callbacks for Message CURD actions\n\n  var deleteMessage = useDeleteMessageCallback({\n    currentGroupChannel: currentGroupChannel,\n    messagesDispatcher: messagesDispatcher\n  }, {\n    logger: logger\n  });\n  var updateMessage = useUpdateMessageCallback({\n    currentGroupChannel: currentGroupChannel,\n    messagesDispatcher: messagesDispatcher,\n    onBeforeUpdateUserMessage: onBeforeUpdateUserMessage\n  }, {\n    logger: logger,\n    sdk: sdk,\n    pubSub: pubSub\n  });\n  var resendMessage = useResendMessageCallback({\n    currentGroupChannel: currentGroupChannel,\n    messagesDispatcher: messagesDispatcher\n  }, {\n    logger: logger\n  });\n\n  var _useSendMessageCallba = useSendMessageCallback({\n    currentGroupChannel: currentGroupChannel,\n    onBeforeSendUserMessage: onBeforeSendUserMessage\n  }, {\n    sdk: sdk,\n    logger: logger,\n    pubSub: pubSub,\n    messagesDispatcher: messagesDispatcher\n  }),\n      _useSendMessageCallba2 = _slicedToArray(_useSendMessageCallba, 2),\n      messageInputRef = _useSendMessageCallba2[0],\n      onSendMessage = _useSendMessageCallba2[1];\n\n  var _useSendFileMessageCa = useSendFileMessageCallback({\n    currentGroupChannel: currentGroupChannel,\n    onBeforeSendFileMessage: onBeforeSendFileMessage,\n    imageCompression: imageCompression\n  }, {\n    sdk: sdk,\n    logger: logger,\n    pubSub: pubSub,\n    messagesDispatcher: messagesDispatcher\n  }),\n      _useSendFileMessageCa2 = _slicedToArray(_useSendFileMessageCa, 1),\n      onSendFileMessage = _useSendFileMessageCa2[0];\n\n  if (!channelUrl) {\n    return /*#__PURE__*/React__default.createElement(\"div\", {\n      className: \"sendbird-conversation\"\n    }, /*#__PURE__*/React__default.createElement(PlaceHolder, {\n      type: PlaceHolderTypes.NO_CHANNELS\n    }));\n  }\n\n  if (isInvalid) {\n    return /*#__PURE__*/React__default.createElement(\"div\", {\n      className: \"sendbird-conversation\"\n    }, /*#__PURE__*/React__default.createElement(PlaceHolder, {\n      type: PlaceHolderTypes.WRONG\n    }));\n  }\n\n  if (sdkError) {\n    return /*#__PURE__*/React__default.createElement(\"div\", {\n      className: \"sendbird-conversation\"\n    }, /*#__PURE__*/React__default.createElement(PlaceHolder, {\n      type: PlaceHolderTypes.WRONG,\n      retryToConnect: function retryToConnect() {\n        logger.info('Channel: reconnecting');\n        reconnect();\n      }\n    }));\n  }\n\n  return /*#__PURE__*/React__default.createElement(UserProfileProvider, {\n    className: \"sendbird-conversation\",\n    disableUserProfile: userDefinedDisableUserProfile,\n    renderUserProfile: userDefinedRenderProfile\n  }, renderChatHeader ? renderChatHeader({\n    channel: currentGroupChannel,\n    user: user\n  }) : /*#__PURE__*/React__default.createElement(ChatHeader, {\n    theme: theme,\n    currentGroupChannel: currentGroupChannel,\n    currentUser: user,\n    showSearchIcon: showSearchIcon,\n    onSearchClick: onSearchClick,\n    onActionClick: onChatHeaderActionClick,\n    subTitle: currentGroupChannel.members && currentGroupChannel.members.length !== 2,\n    isMuted: false\n  }), isFrozen && /*#__PURE__*/React__default.createElement(FrozenNotification, null), unreadCount > 0 && /*#__PURE__*/React__default.createElement(Notification, {\n    count: unreadCount,\n    onClick: function onClick() {\n      if (intialTimeStamp) {\n        setIntialTimeStamp(null);\n        setAnimatedMessageId(null);\n        setHighLightedMessageId(null);\n      } else {\n        scrollIntoLast(); // there is no scroll\n\n        if (scrollRef.current.scrollTop === 0) {\n          currentGroupChannel.markAsRead();\n          messagesDispatcher({\n            type: MARK_AS_READ\n          });\n        }\n      }\n    },\n    time: unreadSince\n  }), loading ? /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-conversation\"\n  }, /*#__PURE__*/React__default.createElement(PlaceHolder, {\n    type: PlaceHolderTypes.LOADING\n  })) : /*#__PURE__*/React__default.createElement(ConversationScroll, {\n    swapParams: sdk && sdk.getErrorFirstCallback && sdk.getErrorFirstCallback(),\n    animatedMessageId: animatedMessageId,\n    highLightedMessageId: highLightedMessageId,\n    userId: userId,\n    hasMore: hasMore,\n    disabled: !isOnline,\n    onScroll: onScrollCallback,\n    onScrollDown: onScrollDownCallback,\n    scrollRef: scrollRef,\n    readStatus: readStatus,\n    useReaction: usingReaction,\n    replyType: replyType,\n    allMessages: allMessages,\n    scrollToMessage: scrollToMessage,\n    emojiAllMap: emojiAllMap,\n    membersMap: nicknamesMap,\n    editDisabled: isDisabledBecauseFrozen(currentGroupChannel),\n    deleteMessage: deleteMessage,\n    updateMessage: updateMessage,\n    resendMessage: resendMessage,\n    toggleReaction: toggleReaction,\n    emojiContainer: emojiContainer,\n    renderChatItem: renderChatItem,\n    quoteMessage: quoteMessage,\n    setQuoteMessage: setQuoteMessage,\n    showScrollBot: showScrollBot,\n    onClickScrollBot: function onClickScrollBot() {\n      setIntialTimeStamp(null);\n      setAnimatedMessageId(null);\n      setHighLightedMessageId(null);\n    },\n    renderCustomMessage: renderCustomMessage,\n    useMessageGrouping: useMessageGrouping,\n    messagesDispatcher: messagesDispatcher,\n    currentGroupChannel: currentGroupChannel,\n    memoizedEmojiListItems: memoizedEmojiListItems\n  }), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-conversation__footer\"\n  }, /*#__PURE__*/React__default.createElement(MessageInputWrapper$1, {\n    channel: currentGroupChannel,\n    user: user,\n    ref: messageInputRef,\n    isOnline: isOnline,\n    initialized: initialized,\n    onSendMessage: onSendMessage,\n    onFileUpload: onSendFileMessage,\n    quoteMessage: quoteMessage,\n    setQuoteMessage: setQuoteMessage,\n    renderMessageInput: renderMessageInput\n  }), /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"sendbird-conversation__footer__typing-indicator\"\n  }, /*#__PURE__*/React__default.createElement(TypingIndicator, {\n    className: \"sendbird-conversation__footer__typing-indicator__text\",\n    channelUrl: channelUrl,\n    sb: sdk,\n    logger: logger\n  }), !isOnline && /*#__PURE__*/React__default.createElement(ConnectionStatus, {\n    sdkInit: sdkInit,\n    sb: sdk,\n    logger: logger\n  }))));\n};\n\nConversationPanel.propTypes = {\n  channelUrl: PropTypes.string,\n  stores: PropTypes.shape({\n    sdkStore: PropTypes.shape({\n      initialized: PropTypes.bool,\n      sdk: PropTypes.shape({\n        getErrorFirstCallback: PropTypes.func,\n        removeChannelHandler: PropTypes.func,\n        GroupChannel: PropTypes.any,\n        ChannelHandler: PropTypes.any,\n        addChannelHandler: PropTypes.func,\n        UserMessageParams: PropTypes.any,\n        FileMessageParams: PropTypes.any,\n        getAllEmoji: PropTypes.func,\n        appInfo: PropTypes.shape({})\n      }),\n      error: PropTypes.bool\n    }),\n    userStore: PropTypes.shape({\n      user: PropTypes.shape({})\n    })\n  }).isRequired,\n  dispatchers: PropTypes.shape({\n    reconnect: PropTypes.func\n  }).isRequired,\n  config: PropTypes.shape({\n    disableUserProfile: PropTypes.bool,\n    renderUserProfile: PropTypes.func,\n    userId: PropTypes.string.isRequired,\n    isOnline: PropTypes.bool.isRequired,\n    theme: PropTypes.string,\n    logger: PropTypes.shape({\n      info: PropTypes.func,\n      error: PropTypes.func,\n      warning: PropTypes.func\n    }),\n    pubSub: PropTypes.shape({\n      subscribe: PropTypes.func,\n      publish: PropTypes.func\n    }),\n    imageCompression: PropTypes.shape({\n      compressionRate: PropTypes.number,\n      resizingWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n      resizingHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\n    })\n  }).isRequired,\n  queries: PropTypes.shape({\n    messageListParams: PropTypes.shape({\n      includeMetaArray: PropTypes.bool,\n      includeParentMessageText: PropTypes.bool,\n      includeReaction: PropTypes.bool,\n      includeReplies: PropTypes.bool,\n      includeThreadInfo: PropTypes.bool,\n      limit: PropTypes.number,\n      reverse: PropTypes.bool,\n      senderUserIdsFilter: PropTypes.arrayOf(PropTypes.string)\n    })\n  }),\n  startingPoint: PropTypes.number,\n  highlightedMessage: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  onBeforeSendUserMessage: PropTypes.func,\n  // onBeforeSendUserMessage(text)\n  onBeforeSendFileMessage: PropTypes.func,\n  // onBeforeSendFileMessage(File)\n  onBeforeUpdateUserMessage: PropTypes.func,\n  renderChatItem: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),\n  renderCustomMessage: PropTypes.func,\n  renderMessageInput: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),\n  renderChatHeader: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),\n  showSearchIcon: PropTypes.bool,\n  onSearchClick: PropTypes.func,\n  onChatHeaderActionClick: PropTypes.func,\n  useReaction: PropTypes.bool,\n  replyType: PropTypes.oneOf(['NONE', 'QUOTE_REPLY', 'THREAD']),\n  disableUserProfile: PropTypes.bool,\n  renderUserProfile: PropTypes.func,\n  useMessageGrouping: PropTypes.bool\n};\nConversationPanel.defaultProps = {\n  channelUrl: null,\n  queries: {},\n  onBeforeSendUserMessage: null,\n  onBeforeSendFileMessage: null,\n  onBeforeUpdateUserMessage: null,\n  startingPoint: null,\n  highlightedMessage: null,\n  renderChatItem: null,\n  renderCustomMessage: null,\n  renderMessageInput: null,\n  renderChatHeader: null,\n  useReaction: true,\n  replyType: 'NONE',\n  showSearchIcon: false,\n  onSearchClick: noop,\n  disableUserProfile: false,\n  renderUserProfile: null,\n  useMessageGrouping: true,\n  onChatHeaderActionClick: noop\n};\nvar getEmojiCategoriesFromEmojiContainer = getEmojiCategoriesFromEmojiContainer$1,\n    getAllEmojisFromEmojiContainer = getAllEmojisFromEmojiContainer$1,\n    getEmojisFromEmojiContainer = getEmojisFromEmojiContainer$1;\nvar Conversation = withSendbirdContext(ConversationPanel);\nexport { ConversationPanel, Conversation as default, getAllEmojisFromEmojiContainer, getEmojiCategoriesFromEmojiContainer, getEmojisFromEmojiContainer };","map":null,"metadata":{},"sourceType":"module"}